import{Z as w,$ as E,R as y,b as r,W as f,G as C,I as N,J as o,H as l,K as a,a0 as m,a1 as I,M as d,L as p,N as h,O as A,a2 as O,v as K,a3 as v}from"./index-52a2ca78.js";import{C as _}from"./baseProvider.esm-472b2c12.js";import"./baseControllers.esm-aa487116.js";const R=()=>({adapterSettings:{network:w.MAINNET,clientId:"",uxMode:E.POPUP},loginSettings:{}});function P(s,e){var i=Object.keys(s);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(s);e&&(t=t.filter(function(c){return Object.getOwnPropertyDescriptor(s,c).enumerable})),i.push.apply(i,t)}return i}function n(s){for(var e=1;e<arguments.length;e++){var i=arguments[e]!=null?arguments[e]:{};e%2?P(Object(i),!0).forEach(function(t){r(s,t,i[t])}):Object.getOwnPropertyDescriptors?Object.defineProperties(s,Object.getOwnPropertyDescriptors(i)):P(Object(i)).forEach(function(t){Object.defineProperty(s,t,Object.getOwnPropertyDescriptor(i,t))})}return s}class b extends y{constructor(){let e=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};super(e),r(this,"name",f.OPENLOGIN),r(this,"adapterNamespace",C.MULTICHAIN),r(this,"type",N.IN_APP),r(this,"openloginInstance",null),r(this,"status",o.NOT_READY),r(this,"currentChainNamespace",l.EIP155),r(this,"openloginOptions",void 0),r(this,"loginSettings",{loginProvider:""}),r(this,"privKeyProvider",null),this.setAdapterSettings(n(n({},e.adapterSettings),{},{chainConfig:e.chainConfig,clientId:e.clientId||"",sessionTime:e.sessionTime,web3AuthNetwork:e.web3AuthNetwork,useCoreKitKey:e.useCoreKitKey})),this.loginSettings=e.loginSettings||{loginProvider:""}}get chainConfigProxy(){return this.chainConfig?n({},this.chainConfig):null}get provider(){var e;return((e=this.privKeyProvider)===null||e===void 0?void 0:e.provider)||null}set provider(e){throw new Error("Not implemented")}async init(e){if(super.checkInitializationRequirements(),!this.clientId)throw a.invalidParams("clientId is required before openlogin's initialization");if(!this.openloginOptions)throw a.invalidParams("openloginOptions is required before openlogin's initialization");let i=!1;if(this.openloginOptions.uxMode===E.REDIRECT||this.openloginOptions.uxMode===E.SESSIONLESS_REDIRECT){const t=m();Object.keys(t).length>0&&t._pid&&(i=!0)}this.openloginOptions=n(n({},this.openloginOptions),{},{replaceUrlOnRedirect:i}),this.openloginInstance=new I(n(n({},this.openloginOptions),{},{clientId:this.clientId,network:this.openloginOptions.network||this.web3AuthNetwork||w.MAINNET})),d.debug("initializing openlogin adapter init"),await this.openloginInstance.init(),this.status=o.READY,this.emit(p.READY,f.OPENLOGIN);try{d.debug("initializing openlogin adapter"),this._getFinalPrivKey()&&(e.autoConnect||i)&&(this.rehydrated=!0,await this.connect())}catch(t){d.error("Failed to connect with cached openlogin provider",t),this.emit("ERRORED",t)}}async connect(){let e=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{loginProvider:""};super.checkConnectionRequirements(),this.status=o.CONNECTING,this.emit(p.CONNECTING,n(n({},e),{},{adapter:f.OPENLOGIN}));try{return await this.connectWithProvider(e),this.provider}catch(i){throw d.error("Failed to connect with openlogin provider",i),this.status=o.READY,this.emit(p.ERRORED,i),i!=null&&i.message.includes("user closed popup")?h.popupClosed():i instanceof A?i:h.connectionError("Failed to login with openlogin")}}async disconnect(){let e=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{cleanup:!1};if(this.status!==o.CONNECTED)throw h.notConnectedError("Not connected with wallet");if(!this.openloginInstance)throw a.notReady("openloginInstance is not ready");await this.openloginInstance.logout(),e.cleanup?(this.status=o.NOT_READY,this.openloginInstance=null,this.privKeyProvider=null):this.status=o.READY,this.rehydrated=!1,this.emit(p.DISCONNECTED)}async authenticateUser(){if(this.status!==o.CONNECTED)throw h.notConnectedError("Not connected with wallet, Please login/connect first");return{idToken:(await this.getUserInfo()).idToken}}async getUserInfo(){if(this.status!==o.CONNECTED)throw h.notConnectedError("Not connected with wallet");if(!this.openloginInstance)throw a.notReady("openloginInstance is not ready");return await this.openloginInstance.getUserInfo()}setAdapterSettings(e){super.setAdapterSettings(e);const i=R();d.info("setting adapter settings",e),this.openloginOptions=n(n(n({},i.adapterSettings),this.openloginOptions),e),e.web3AuthNetwork&&(this.openloginOptions.network=e.web3AuthNetwork),e.useCoreKitKey!==void 0&&(this.openloginOptions.useCoreKitKey=e.useCoreKitKey)}async addChain(e){var i;let t=arguments.length>1&&arguments[1]!==void 0?arguments[1]:!1;super.checkAddChainRequirements(t),(i=this.privKeyProvider)===null||i===void 0||i.addChain(e),this.addChainConfig(e)}async switchChain(e){var i;let t=arguments.length>1&&arguments[1]!==void 0?arguments[1]:!1;super.checkSwitchChainRequirements(e,t),await((i=this.privKeyProvider)===null||i===void 0?void 0:i.switchChain(e)),this.setAdapterSettings({chainConfig:this.getChainConfig(e.chainId)})}_getFinalPrivKey(){var e;if(!this.openloginInstance)return"";let i=this.openloginInstance.privKey;if((e=this.openloginOptions)!==null&&e!==void 0&&e.useCoreKitKey){if(!this.openloginInstance.coreKitKey)throw h.coreKitKeyNotFound();i=this.openloginInstance.coreKitKey}return i}async connectWithProvider(){var e;let i=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{loginProvider:""};if(!this.chainConfig)throw a.invalidParams("chainConfig is required before initialization");if(!this.openloginInstance)throw a.notReady("openloginInstance is not ready");if(!this._getFinalPrivKey()||(e=i.extraLoginOptions)!==null&&e!==void 0&&e.id_token){var c;if(this.loginSettings.curve||(this.loginSettings.curve=this.currentChainNamespace===l.SOLANA?O.ED25519:O.SECP256K1),!i.loginProvider&&!this.loginSettings.loginProvider)throw a.invalidParams("loginProvider is required for login");await this.openloginInstance.login(K(this.loginSettings,i,{extraLoginOptions:n(n({},i.extraLoginOptions||{}),{},{login_hint:i.login_hint||((c=i.extraLoginOptions)===null||c===void 0?void 0:c.login_hint)})}))}let u=this._getFinalPrivKey();if(u){if(this.currentChainNamespace===l.SOLANA){const{getED25519Key:g}=await v(()=>import("./openloginEd25519.esm-a6e3225c.js"),["assets/openloginEd25519.esm-a6e3225c.js","assets/index-52a2ca78.js","assets/index-0e862849.css","assets/nacl-fast-1b518f79.js"]);u=g(u).sk.toString("hex")}if(this.currentChainNamespace===l.SOLANA){const{SolanaPrivateKeyProvider:g}=await v(()=>import("./solanaProvider.esm-be2d3f11.js"),["assets/solanaProvider.esm-be2d3f11.js","assets/index-52a2ca78.js","assets/index-0e862849.css","assets/baseControllers.esm-aa487116.js","assets/baseProvider.esm-472b2c12.js","assets/index.browser.esm-de607001.js","assets/openloginEd25519.esm-a6e3225c.js","assets/nacl-fast-1b518f79.js"]);this.privKeyProvider=new g({config:{chainConfig:this.chainConfig}})}else if(this.currentChainNamespace===l.EIP155){const{EthereumPrivateKeyProvider:g}=await v(()=>import("./ethereumProvider.esm-d61a0d60.js"),["assets/ethereumProvider.esm-d61a0d60.js","assets/index-52a2ca78.js","assets/index-0e862849.css","assets/baseControllers.esm-aa487116.js","assets/baseProvider.esm-472b2c12.js"]);this.privKeyProvider=new g({config:{chainConfig:this.chainConfig}})}else if(this.currentChainNamespace===l.OTHER)this.privKeyProvider=new _;else throw new Error(`Invalid chainNamespace: ${this.currentChainNamespace} found while connecting to wallet`);await this.privKeyProvider.setupProvider(u),this.status=o.CONNECTED,this.emit(p.CONNECTED,{adapter:f.OPENLOGIN,reconnected:this.rehydrated})}}}export{b as OpenloginAdapter,R as getOpenloginDefaultOptions};
