import{f as ki,_ as Ce,E as Ai,s as Ii,g as Ri,B as Bi,W as Pt,c as Js,p as Er,a as Pi,b as xr,u as V,w as kr,S as Ci,v as Oi,d as Zs,e as ze,h as Ct,n as Wt,i as Xs,j as Ti,k as Qn,m as Ge,l as Li,F as Ni,r as Ys,o as $e,q as Mi,t as Ui,x as Fi,y as ft,z as qi,A as Di,C as Qs,D as Ki,G as rt,H as D,I as zi,J as eo,K as to,L as es,M as ts,N as pr,O as rs,P as ji,Q as Hi}from"./index-f3b9eb49.js";import{g as $i,n as Gi}from"./openloginEd25519.esm-a7bc721b.js";var Fr={exports:{}},ns;function Wi(){return ns||(ns=1,function(n){function e(r,s,o,i,a,c,u){try{var l=r[c](u),w=l.value}catch(y){o(y);return}l.done?s(w):Promise.resolve(w).then(i,a)}function t(r){return function(){var s=this,o=arguments;return new Promise(function(i,a){var c=r.apply(s,o);function u(w){e(c,i,a,u,l,"next",w)}function l(w){e(c,i,a,u,l,"throw",w)}u(void 0)})}}n.exports=t,n.exports.__esModule=!0,n.exports.default=n.exports}(Fr)),Fr.exports}var qr={exports:{}},Dr={exports:{}},ss;function Qt(){return ss||(ss=1,function(n){function e(t){"@babel/helpers - typeof";return n.exports=e=typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?function(r){return typeof r}:function(r){return r&&typeof Symbol=="function"&&r.constructor===Symbol&&r!==Symbol.prototype?"symbol":typeof r},n.exports.__esModule=!0,n.exports.default=n.exports,e(t)}n.exports=e,n.exports.__esModule=!0,n.exports.default=n.exports}(Dr)),Dr.exports}var os;function Vi(){return os||(os=1,function(n){var e=Qt().default;function t(){n.exports=t=function(){return r},n.exports.__esModule=!0,n.exports.default=n.exports;var r={},s=Object.prototype,o=s.hasOwnProperty,i=Object.defineProperty||function(C,A,B){C[A]=B.value},a=typeof Symbol=="function"?Symbol:{},c=a.iterator||"@@iterator",u=a.asyncIterator||"@@asyncIterator",l=a.toStringTag||"@@toStringTag";function w(C,A,B){return Object.defineProperty(C,A,{value:B,enumerable:!0,configurable:!0,writable:!0}),C[A]}try{w({},"")}catch{w=function(B,x,S){return B[x]=S}}function y(C,A,B,x){var S=A&&A.prototype instanceof p?A:p,I=Object.create(S.prototype),q=new pe(x||[]);return i(I,"_invoke",{value:F(C,B,q)}),I}function h(C,A,B){try{return{type:"normal",arg:C.call(A,B)}}catch(x){return{type:"throw",arg:x}}}r.wrap=y;var m={};function p(){}function b(){}function _(){}var E={};w(E,c,function(){return this});var d=Object.getPrototypeOf,R=d&&d(d(oe([])));R&&R!==s&&o.call(R,c)&&(E=R);var v=_.prototype=p.prototype=Object.create(E);function M(C){["next","throw","return"].forEach(function(A){w(C,A,function(B){return this._invoke(A,B)})})}function T(C,A){function B(S,I,q,G){var W=h(C[S],C,I);if(W.type!=="throw"){var Q=W.arg,te=Q.value;return te&&e(te)=="object"&&o.call(te,"__await")?A.resolve(te.__await).then(function(Y){B("next",Y,q,G)},function(Y){B("throw",Y,q,G)}):A.resolve(te).then(function(Y){Q.value=Y,q(Q)},function(Y){return B("throw",Y,q,G)})}G(W.arg)}var x;i(this,"_invoke",{value:function(I,q){function G(){return new A(function(W,Q){B(I,q,W,Q)})}return x=x?x.then(G,G):G()}})}function F(C,A,B){var x="suspendedStart";return function(S,I){if(x==="executing")throw new Error("Generator is already running");if(x==="completed"){if(S==="throw")throw I;return Je()}for(B.method=S,B.arg=I;;){var q=B.delegate;if(q){var G=X(q,B);if(G){if(G===m)continue;return G}}if(B.method==="next")B.sent=B._sent=B.arg;else if(B.method==="throw"){if(x==="suspendedStart")throw x="completed",B.arg;B.dispatchException(B.arg)}else B.method==="return"&&B.abrupt("return",B.arg);x="executing";var W=h(C,A,B);if(W.type==="normal"){if(x=B.done?"completed":"suspendedYield",W.arg===m)continue;return{value:W.arg,done:B.done}}W.type==="throw"&&(x="completed",B.method="throw",B.arg=W.arg)}}}function X(C,A){var B=A.method,x=C.iterator[B];if(x===void 0)return A.delegate=null,B==="throw"&&C.iterator.return&&(A.method="return",A.arg=void 0,X(C,A),A.method==="throw")||B!=="return"&&(A.method="throw",A.arg=new TypeError("The iterator does not provide a '"+B+"' method")),m;var S=h(x,C.iterator,A.arg);if(S.type==="throw")return A.method="throw",A.arg=S.arg,A.delegate=null,m;var I=S.arg;return I?I.done?(A[C.resultName]=I.value,A.next=C.nextLoc,A.method!=="return"&&(A.method="next",A.arg=void 0),A.delegate=null,m):I:(A.method="throw",A.arg=new TypeError("iterator result is not an object"),A.delegate=null,m)}function ce(C){var A={tryLoc:C[0]};1 in C&&(A.catchLoc=C[1]),2 in C&&(A.finallyLoc=C[2],A.afterLoc=C[3]),this.tryEntries.push(A)}function ue(C){var A=C.completion||{};A.type="normal",delete A.arg,C.completion=A}function pe(C){this.tryEntries=[{tryLoc:"root"}],C.forEach(ce,this),this.reset(!0)}function oe(C){if(C){var A=C[c];if(A)return A.call(C);if(typeof C.next=="function")return C;if(!isNaN(C.length)){var B=-1,x=function S(){for(;++B<C.length;)if(o.call(C,B))return S.value=C[B],S.done=!1,S;return S.value=void 0,S.done=!0,S};return x.next=x}}return{next:Je}}function Je(){return{value:void 0,done:!0}}return b.prototype=_,i(v,"constructor",{value:_,configurable:!0}),i(_,"constructor",{value:b,configurable:!0}),b.displayName=w(_,l,"GeneratorFunction"),r.isGeneratorFunction=function(C){var A=typeof C=="function"&&C.constructor;return!!A&&(A===b||(A.displayName||A.name)==="GeneratorFunction")},r.mark=function(C){return Object.setPrototypeOf?Object.setPrototypeOf(C,_):(C.__proto__=_,w(C,l,"GeneratorFunction")),C.prototype=Object.create(v),C},r.awrap=function(C){return{__await:C}},M(T.prototype),w(T.prototype,u,function(){return this}),r.AsyncIterator=T,r.async=function(C,A,B,x,S){S===void 0&&(S=Promise);var I=new T(y(C,A,B,x),S);return r.isGeneratorFunction(A)?I:I.next().then(function(q){return q.done?q.value:I.next()})},M(v),w(v,l,"Generator"),w(v,c,function(){return this}),w(v,"toString",function(){return"[object Generator]"}),r.keys=function(C){var A=Object(C),B=[];for(var x in A)B.push(x);return B.reverse(),function S(){for(;B.length;){var I=B.pop();if(I in A)return S.value=I,S.done=!1,S}return S.done=!0,S}},r.values=oe,pe.prototype={constructor:pe,reset:function(A){if(this.prev=0,this.next=0,this.sent=this._sent=void 0,this.done=!1,this.delegate=null,this.method="next",this.arg=void 0,this.tryEntries.forEach(ue),!A)for(var B in this)B.charAt(0)==="t"&&o.call(this,B)&&!isNaN(+B.slice(1))&&(this[B]=void 0)},stop:function(){this.done=!0;var A=this.tryEntries[0].completion;if(A.type==="throw")throw A.arg;return this.rval},dispatchException:function(A){if(this.done)throw A;var B=this;function x(Q,te){return q.type="throw",q.arg=A,B.next=Q,te&&(B.method="next",B.arg=void 0),!!te}for(var S=this.tryEntries.length-1;S>=0;--S){var I=this.tryEntries[S],q=I.completion;if(I.tryLoc==="root")return x("end");if(I.tryLoc<=this.prev){var G=o.call(I,"catchLoc"),W=o.call(I,"finallyLoc");if(G&&W){if(this.prev<I.catchLoc)return x(I.catchLoc,!0);if(this.prev<I.finallyLoc)return x(I.finallyLoc)}else if(G){if(this.prev<I.catchLoc)return x(I.catchLoc,!0)}else{if(!W)throw new Error("try statement without catch or finally");if(this.prev<I.finallyLoc)return x(I.finallyLoc)}}}},abrupt:function(A,B){for(var x=this.tryEntries.length-1;x>=0;--x){var S=this.tryEntries[x];if(S.tryLoc<=this.prev&&o.call(S,"finallyLoc")&&this.prev<S.finallyLoc){var I=S;break}}I&&(A==="break"||A==="continue")&&I.tryLoc<=B&&B<=I.finallyLoc&&(I=null);var q=I?I.completion:{};return q.type=A,q.arg=B,I?(this.method="next",this.next=I.finallyLoc,m):this.complete(q)},complete:function(A,B){if(A.type==="throw")throw A.arg;return A.type==="break"||A.type==="continue"?this.next=A.arg:A.type==="return"?(this.rval=this.arg=A.arg,this.method="return",this.next="end"):A.type==="normal"&&B&&(this.next=B),m},finish:function(A){for(var B=this.tryEntries.length-1;B>=0;--B){var x=this.tryEntries[B];if(x.finallyLoc===A)return this.complete(x.completion,x.afterLoc),ue(x),m}},catch:function(A){for(var B=this.tryEntries.length-1;B>=0;--B){var x=this.tryEntries[B];if(x.tryLoc===A){var S=x.completion;if(S.type==="throw"){var I=S.arg;ue(x)}return I}}throw new Error("illegal catch attempt")},delegateYield:function(A,B,x){return this.delegate={iterator:oe(A),resultName:B,nextLoc:x},this.method==="next"&&(this.arg=void 0),m}},r}n.exports=t,n.exports.__esModule=!0,n.exports.default=n.exports}(qr)),qr.exports}var Kr,is;function Ji(){if(is)return Kr;is=1;var n=Vi()();Kr=n;try{regeneratorRuntime=n}catch{typeof globalThis=="object"?globalThis.regeneratorRuntime=n:Function("r","regeneratorRuntime = r")(n)}return Kr}var Z={},mt={};Object.defineProperty(mt,"__esModule",{value:!0});mt.EthereumProviderError=mt.EthereumRpcError=void 0;const Zi=ki;class ro extends Error{constructor(e,t,r){if(!Number.isInteger(e))throw new Error('"code" must be an integer.');if(!t||typeof t!="string")throw new Error('"message" must be a nonempty string.');super(t),this.code=e,r!==void 0&&(this.data=r)}serialize(){const e={code:this.code,message:this.message};return this.data!==void 0&&(e.data=this.data),this.stack&&(e.stack=this.stack),e}toString(){return Zi.default(this.serialize(),Qi,2)}}mt.EthereumRpcError=ro;class Xi extends ro{constructor(e,t,r){if(!Yi(e))throw new Error('"code" must be an integer such that: 1000 <= code <= 4999');super(e,t,r)}}mt.EthereumProviderError=Xi;function Yi(n){return Number.isInteger(n)&&n>=1e3&&n<=4999}function Qi(n,e){if(e!=="[Circular]")return e}var wn={},wt={};Object.defineProperty(wt,"__esModule",{value:!0});wt.errorValues=wt.errorCodes=void 0;wt.errorCodes={rpc:{invalidInput:-32e3,resourceNotFound:-32001,resourceUnavailable:-32002,transactionRejected:-32003,methodNotSupported:-32004,limitExceeded:-32005,parse:-32700,invalidRequest:-32600,methodNotFound:-32601,invalidParams:-32602,internal:-32603},provider:{userRejectedRequest:4001,unauthorized:4100,unsupportedMethod:4200,disconnected:4900,chainDisconnected:4901}};wt.errorValues={"-32700":{standard:"JSON RPC 2.0",message:"Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."},"-32600":{standard:"JSON RPC 2.0",message:"The JSON sent is not a valid Request object."},"-32601":{standard:"JSON RPC 2.0",message:"The method does not exist / is not available."},"-32602":{standard:"JSON RPC 2.0",message:"Invalid method parameter(s)."},"-32603":{standard:"JSON RPC 2.0",message:"Internal JSON-RPC error."},"-32000":{standard:"EIP-1474",message:"Invalid input."},"-32001":{standard:"EIP-1474",message:"Resource not found."},"-32002":{standard:"EIP-1474",message:"Resource unavailable."},"-32003":{standard:"EIP-1474",message:"Transaction rejected."},"-32004":{standard:"EIP-1474",message:"Method not supported."},"-32005":{standard:"EIP-1474",message:"Request limit exceeded."},4001:{standard:"EIP-1193",message:"User rejected the request."},4100:{standard:"EIP-1193",message:"The requested account and/or method has not been authorized by the user."},4200:{standard:"EIP-1193",message:"The requested method is not supported by this Ethereum provider."},4900:{standard:"EIP-1193",message:"The provider is disconnected from all chains."},4901:{standard:"EIP-1193",message:"The provider is disconnected from the specified chain."}};(function(n){Object.defineProperty(n,"__esModule",{value:!0}),n.serializeError=n.isValidCode=n.getMessageFromCode=n.JSON_RPC_SERVER_ERROR_MESSAGE=void 0;const e=wt,t=mt,r=e.errorCodes.rpc.internal,s="Unspecified error message. This is a bug, please report it.",o={code:r,message:i(r)};n.JSON_RPC_SERVER_ERROR_MESSAGE="Unspecified server error.";function i(y,h=s){if(Number.isInteger(y)){const m=y.toString();if(w(e.errorValues,m))return e.errorValues[m].message;if(u(y))return n.JSON_RPC_SERVER_ERROR_MESSAGE}return h}n.getMessageFromCode=i;function a(y){if(!Number.isInteger(y))return!1;const h=y.toString();return!!(e.errorValues[h]||u(y))}n.isValidCode=a;function c(y,{fallbackError:h=o,shouldIncludeStack:m=!1}={}){var p,b;if(!h||!Number.isInteger(h.code)||typeof h.message!="string")throw new Error("Must provide fallback error with integer number code and string message.");if(y instanceof t.EthereumRpcError)return y.serialize();const _={};if(y&&typeof y=="object"&&!Array.isArray(y)&&w(y,"code")&&a(y.code)){const d=y;_.code=d.code,d.message&&typeof d.message=="string"?(_.message=d.message,w(d,"data")&&(_.data=d.data)):(_.message=i(_.code),_.data={originalError:l(y)})}else{_.code=h.code;const d=(p=y)===null||p===void 0?void 0:p.message;_.message=d&&typeof d=="string"?d:h.message,_.data={originalError:l(y)}}const E=(b=y)===null||b===void 0?void 0:b.stack;return m&&y&&E&&typeof E=="string"&&(_.stack=E),_}n.serializeError=c;function u(y){return y>=-32099&&y<=-32e3}function l(y){return y&&typeof y=="object"&&!Array.isArray(y)?Object.assign({},y):y}function w(y,h){return Object.prototype.hasOwnProperty.call(y,h)}})(wn);var Ar={};Object.defineProperty(Ar,"__esModule",{value:!0});Ar.ethErrors=void 0;const bn=mt,no=wn,_e=wt;Ar.ethErrors={rpc:{parse:n=>De(_e.errorCodes.rpc.parse,n),invalidRequest:n=>De(_e.errorCodes.rpc.invalidRequest,n),invalidParams:n=>De(_e.errorCodes.rpc.invalidParams,n),methodNotFound:n=>De(_e.errorCodes.rpc.methodNotFound,n),internal:n=>De(_e.errorCodes.rpc.internal,n),server:n=>{if(!n||typeof n!="object"||Array.isArray(n))throw new Error("Ethereum RPC Server errors must provide single object argument.");const{code:e}=n;if(!Number.isInteger(e)||e>-32005||e<-32099)throw new Error('"code" must be an integer such that: -32099 <= code <= -32005');return De(e,n)},invalidInput:n=>De(_e.errorCodes.rpc.invalidInput,n),resourceNotFound:n=>De(_e.errorCodes.rpc.resourceNotFound,n),resourceUnavailable:n=>De(_e.errorCodes.rpc.resourceUnavailable,n),transactionRejected:n=>De(_e.errorCodes.rpc.transactionRejected,n),methodNotSupported:n=>De(_e.errorCodes.rpc.methodNotSupported,n),limitExceeded:n=>De(_e.errorCodes.rpc.limitExceeded,n)},provider:{userRejectedRequest:n=>Dt(_e.errorCodes.provider.userRejectedRequest,n),unauthorized:n=>Dt(_e.errorCodes.provider.unauthorized,n),unsupportedMethod:n=>Dt(_e.errorCodes.provider.unsupportedMethod,n),disconnected:n=>Dt(_e.errorCodes.provider.disconnected,n),chainDisconnected:n=>Dt(_e.errorCodes.provider.chainDisconnected,n),custom:n=>{if(!n||typeof n!="object"||Array.isArray(n))throw new Error("Ethereum Provider custom errors must provide single object argument.");const{code:e,message:t,data:r}=n;if(!t||typeof t!="string")throw new Error('"message" must be a nonempty string');return new bn.EthereumProviderError(e,t,r)}}};function De(n,e){const[t,r]=so(e);return new bn.EthereumRpcError(n,t||no.getMessageFromCode(n),r)}function Dt(n,e){const[t,r]=so(e);return new bn.EthereumProviderError(n,t||no.getMessageFromCode(n),r)}function so(n){if(n){if(typeof n=="string")return[n];if(typeof n=="object"&&!Array.isArray(n)){const{message:e,data:t}=n;if(e&&typeof e!="string")throw new Error("Must specify string message.");return[e||void 0,t]}}return[]}(function(n){Object.defineProperty(n,"__esModule",{value:!0}),n.getMessageFromCode=n.serializeError=n.EthereumProviderError=n.EthereumRpcError=n.ethErrors=n.errorCodes=void 0;const e=mt;Object.defineProperty(n,"EthereumRpcError",{enumerable:!0,get:function(){return e.EthereumRpcError}}),Object.defineProperty(n,"EthereumProviderError",{enumerable:!0,get:function(){return e.EthereumProviderError}});const t=wn;Object.defineProperty(n,"serializeError",{enumerable:!0,get:function(){return t.serializeError}}),Object.defineProperty(n,"getMessageFromCode",{enumerable:!0,get:function(){return t.getMessageFromCode}});const r=Ar;Object.defineProperty(n,"ethErrors",{enumerable:!0,get:function(){return r.ethErrors}});const s=wt;Object.defineProperty(n,"errorCodes",{enumerable:!0,get:function(){return s.errorCodes}})})(Z);function as(n,e,t){try{Reflect.apply(n,e,t)}catch(r){setTimeout(()=>{throw r})}}function ea(n){const e=n.length,t=new Array(e);for(let r=0;r<e;r+=1)t[r]=n[r];return t}class ta extends Ai{emit(e){let t=e==="error";const r=this._events;if(r!==void 0)t=t&&r.error===void 0;else if(!t)return!1;for(var s=arguments.length,o=new Array(s>1?s-1:0),i=1;i<s;i++)o[i-1]=arguments[i];if(t){let c;if(o.length>0&&([c]=o),c instanceof Error)throw c;const u=new Error(`Unhandled error.${c?` (${c.message})`:""}`);throw u.context=c,u}const a=r[e];if(a===void 0)return!1;if(typeof a=="function")as(a,this,o);else{const c=a.length,u=ea(a);for(let l=0;l<c;l+=1)as(u[l],this,o)}return!0}}class Kt extends Error{constructor(e){let{code:t,message:r,data:s}=e;if(!Number.isInteger(t))throw new Error("code must be an integer");if(!r||typeof r!="string")throw new Error("message must be string");super(r),Ce(this,"code",void 0),Ce(this,"data",void 0),this.code=t,s!==void 0&&(this.data=s)}toString(){return Ii({code:this.code,message:this.message,data:this.data,stack:this.stack})}}function ra(n){return(e,t,r,s)=>{const o=n[e.method];return o===void 0?r():typeof o=="function"?o(e,t,r,s):(t.result=o,s())}}function er(n){return async(e,t,r,s)=>{let o;const i=new Promise(l=>{o=l});let a=null,c=!1;const u=async()=>{c=!0,r(l=>{a=l,o()}),await i};try{await n(e,t,u),c?(await i,a(null)):s(null)}catch(l){a?a(l):s(l)}}}function cs(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);e&&(r=r.filter(function(s){return Object.getOwnPropertyDescriptor(n,s).enumerable})),t.push.apply(t,r)}return t}function na(n){for(var e=1;e<arguments.length;e++){var t=arguments[e]!=null?arguments[e]:{};e%2?cs(Object(t),!0).forEach(function(r){Ce(n,r,t[r])}):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):cs(Object(t)).forEach(function(r){Object.defineProperty(n,r,Object.getOwnPropertyDescriptor(t,r))})}return n}class Le extends ta{constructor(){super(),Ce(this,"_middleware",void 0),this._middleware=[]}static async _runAllMiddleware(e,t,r){const s=[];let o=null,i=!1;for(const a of r)if([o,i]=await Le._runMiddleware(e,t,a,s),i)break;return[o,i,s.reverse()]}static _runMiddleware(e,t,r,s){return new Promise(o=>{const i=c=>{const u=c||t.error;u&&(t.error=Z.serializeError(u)),o([u,!0])},a=c=>{t.error?i(t.error):(c&&(typeof c!="function"&&i(new Kt({code:-32603,message:"JRPCEngine: 'next' return handlers must be functions"})),s.push(c)),o([null,!1]))};try{r(e,t,a,i)}catch(c){i(c)}})}static async _runReturnHandlers(e){for(const t of e)await new Promise((r,s)=>{t(o=>o?s(o):r())})}static _checkForCompletion(e,t,r){if(!("result"in t)&&!("error"in t))throw new Kt({code:-32603,message:"Response has no error or result for request"});if(!r)throw new Kt({code:-32603,message:"Nothing ended request"})}push(e){this._middleware.push(e)}handle(e,t){if(t&&typeof t!="function")throw new Error('"callback" must be a function if provided.');return Array.isArray(e)?t?this._handleBatch(e,t):this._handleBatch(e):t?this._handle(e,t):this._promiseHandle(e)}asMiddleware(){return async(e,t,r,s)=>{try{const[o,i,a]=await Le._runAllMiddleware(e,t,this._middleware);return i?(await Le._runReturnHandlers(a),s(o)):r(async c=>{try{await Le._runReturnHandlers(a)}catch(u){return c(u)}return c()})}catch(o){return s(o)}}}async _handleBatch(e,t){try{const r=await Promise.all(e.map(this._promiseHandle.bind(this)));return t?t(null,r):r}catch(r){if(t)return t(r);throw r}}_promiseHandle(e){return new Promise(t=>{this._handle(e,(r,s)=>{t(s)})})}async _handle(e,t){if(!e||Array.isArray(e)||typeof e!="object"){const i=new Kt({code:-32603,message:"request must be plain object"});return t(i,{id:void 0,jsonrpc:"2.0",error:i})}if(typeof e.method!="string"){const i=new Kt({code:-32603,message:"method must be string"});return t(i,{id:e.id,jsonrpc:"2.0",error:i})}const r=na({},e),s={id:r.id,jsonrpc:r.jsonrpc};let o=null;try{await this._processRequest(r,s)}catch(i){o=i}return o&&(delete s.result,s.error||(s.error=Z.serializeError(o))),t(o,s)}async _processRequest(e,t){const[r,s,o]=await Le._runAllMiddleware(e,t,this._middleware);if(Le._checkForCompletion(e,t,s),await Le._runReturnHandlers(o),r)throw r}}function tr(n){const e=new Le;return n.forEach(t=>e.push(t)),e.asMiddleware()}function us(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);e&&(r=r.filter(function(s){return Object.getOwnPropertyDescriptor(n,s).enumerable})),t.push.apply(t,r)}return t}function ls(n){for(var e=1;e<arguments.length;e++){var t=arguments[e]!=null?arguments[e]:{};e%2?us(Object(t),!0).forEach(function(r){Ce(n,r,t[r])}):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):us(Object(t)).forEach(function(r){Object.defineProperty(n,r,Object.getOwnPropertyDescriptor(t,r))})}return n}class vn extends Bi{constructor(e){let{config:t,state:r}=e;if(super({config:t,state:r}),Ce(this,"_providerEngineProxy",null),!t.chainConfig)throw Pt.invalidProviderConfigError("Please provide chainConfig");if(!t.chainConfig.chainId)throw Pt.invalidProviderConfigError("Please provide chainId inside chainConfig");if(!t.chainConfig.rpcTarget)throw Pt.invalidProviderConfigError("Please provide rpcTarget inside chainConfig");this.defaultState={chainId:"loading"},this.defaultConfig={chainConfig:t.chainConfig,networks:{[t.chainConfig.chainId]:t.chainConfig}},super.initialize()}get provider(){return this._providerEngineProxy}set provider(e){throw new Error("Method not implemented.")}addChain(e){if(!e.chainId||!e.rpcTarget)throw Z.ethErrors.rpc.invalidParams("chainId is required");this.configure({networks:ls(ls({},this.config.networks),{},{[e.chainId]:e})})}getChainConfig(e){var t;const r=(t=this.config.networks)===null||t===void 0?void 0:t[e];if(!r)throw Z.ethErrors.rpc.invalidRequest(`Chain ${e} is not supported, please add chainConfig for it`);return r}getProviderEngineProxy(){return this._providerEngineProxy}updateProviderEngineProxy(e){this._providerEngineProxy?this._providerEngineProxy.setTarget(e):this._providerEngineProxy=Js(e)}}class ds{constructor(){Ce(this,"_providerEngineProxy",null)}get provider(){return this._providerEngineProxy}set provider(e){throw new Error("Method not implemented.")}addChain(e){throw new Error("Method not implemented.")}async setupProvider(e){const t=this.getPrivKeyMiddleware(e),r=new Le;r.push(t);const s=Er(r);this.updateProviderEngineProxy(s)}async switchChain(e){return Promise.resolve()}getProviderEngineProxy(){return this._providerEngineProxy}updateProviderEngineProxy(e){this._providerEngineProxy?this._providerEngineProxy.setTarget(e):this._providerEngineProxy=Js(e)}getPrivKeyMiddleware(e){const t={getPrivatekey:async()=>e};return this.createPrivKeyMiddleware(t)}createPrivKeyMiddleware(e){let{getPrivatekey:t}=e;async function r(s,o){o.result=await t()}return ra({private_key:er(r)})}}Ce(ds,"getProviderInstance",async n=>{const e=new ds;return await e.setupProvider(n.privKey),e});Ri();var cr=Pi.Buffer;function sa(n){if(n.length>=255)throw new TypeError("Alphabet too long");for(var e=new Uint8Array(256),t=0;t<e.length;t++)e[t]=255;for(var r=0;r<n.length;r++){var s=n.charAt(r),o=s.charCodeAt(0);if(e[o]!==255)throw new TypeError(s+" is ambiguous");e[o]=r}var i=n.length,a=n.charAt(0),c=Math.log(i)/Math.log(256),u=Math.log(256)/Math.log(i);function l(h){if((Array.isArray(h)||h instanceof Uint8Array)&&(h=cr.from(h)),!cr.isBuffer(h))throw new TypeError("Expected Buffer");if(h.length===0)return"";for(var m=0,p=0,b=0,_=h.length;b!==_&&h[b]===0;)b++,m++;for(var E=(_-b)*u+1>>>0,d=new Uint8Array(E);b!==_;){for(var R=h[b],v=0,M=E-1;(R!==0||v<p)&&M!==-1;M--,v++)R+=256*d[M]>>>0,d[M]=R%i>>>0,R=R/i>>>0;if(R!==0)throw new Error("Non-zero carry");p=v,b++}for(var T=E-p;T!==E&&d[T]===0;)T++;for(var F=a.repeat(m);T<E;++T)F+=n.charAt(d[T]);return F}function w(h){if(typeof h!="string")throw new TypeError("Expected String");if(h.length===0)return cr.alloc(0);for(var m=0,p=0,b=0;h[m]===a;)p++,m++;for(var _=(h.length-m)*c+1>>>0,E=new Uint8Array(_);h[m];){var d=e[h.charCodeAt(m)];if(d===255)return;for(var R=0,v=_-1;(d!==0||R<b)&&v!==-1;v--,R++)d+=i*E[v]>>>0,E[v]=d%256>>>0,d=d/256>>>0;if(d!==0)throw new Error("Non-zero carry");b=R,m++}for(var M=_-b;M!==_&&E[M]===0;)M++;var T=cr.allocUnsafe(p+(_-M));T.fill(0,0,p);for(var F=p;M!==_;)T[F++]=E[M++];return T}function y(h){var m=w(h);if(m)return m;throw new Error("Non-base"+i+" character")}return{encode:l,decodeUnsafe:w,decode:y}}var oa=sa,ia=oa,aa="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",oo=ia(aa);const ie=xr(oo),[ca,ua]=V.split(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(n=>BigInt(n))),lt=new Uint32Array(80),dt=new Uint32Array(80);class Ir extends Ci{constructor(){super(128,64,16,!1),this.Ah=1779033703,this.Al=-205731576,this.Bh=-1150833019,this.Bl=-2067093701,this.Ch=1013904242,this.Cl=-23791573,this.Dh=-1521486534,this.Dl=1595750129,this.Eh=1359893119,this.El=-1377402159,this.Fh=-1694144372,this.Fl=725511199,this.Gh=528734635,this.Gl=-79577749,this.Hh=1541459225,this.Hl=327033209}get(){const{Ah:e,Al:t,Bh:r,Bl:s,Ch:o,Cl:i,Dh:a,Dl:c,Eh:u,El:l,Fh:w,Fl:y,Gh:h,Gl:m,Hh:p,Hl:b}=this;return[e,t,r,s,o,i,a,c,u,l,w,y,h,m,p,b]}set(e,t,r,s,o,i,a,c,u,l,w,y,h,m,p,b){this.Ah=e|0,this.Al=t|0,this.Bh=r|0,this.Bl=s|0,this.Ch=o|0,this.Cl=i|0,this.Dh=a|0,this.Dl=c|0,this.Eh=u|0,this.El=l|0,this.Fh=w|0,this.Fl=y|0,this.Gh=h|0,this.Gl=m|0,this.Hh=p|0,this.Hl=b|0}process(e,t){for(let d=0;d<16;d++,t+=4)lt[d]=e.getUint32(t),dt[d]=e.getUint32(t+=4);for(let d=16;d<80;d++){const R=lt[d-15]|0,v=dt[d-15]|0,M=V.rotrSH(R,v,1)^V.rotrSH(R,v,8)^V.shrSH(R,v,7),T=V.rotrSL(R,v,1)^V.rotrSL(R,v,8)^V.shrSL(R,v,7),F=lt[d-2]|0,X=dt[d-2]|0,ce=V.rotrSH(F,X,19)^V.rotrBH(F,X,61)^V.shrSH(F,X,6),ue=V.rotrSL(F,X,19)^V.rotrBL(F,X,61)^V.shrSL(F,X,6),pe=V.add4L(T,ue,dt[d-7],dt[d-16]),oe=V.add4H(pe,M,ce,lt[d-7],lt[d-16]);lt[d]=oe|0,dt[d]=pe|0}let{Ah:r,Al:s,Bh:o,Bl:i,Ch:a,Cl:c,Dh:u,Dl:l,Eh:w,El:y,Fh:h,Fl:m,Gh:p,Gl:b,Hh:_,Hl:E}=this;for(let d=0;d<80;d++){const R=V.rotrSH(w,y,14)^V.rotrSH(w,y,18)^V.rotrBH(w,y,41),v=V.rotrSL(w,y,14)^V.rotrSL(w,y,18)^V.rotrBL(w,y,41),M=w&h^~w&p,T=y&m^~y&b,F=V.add5L(E,v,T,ua[d],dt[d]),X=V.add5H(F,_,R,M,ca[d],lt[d]),ce=F|0,ue=V.rotrSH(r,s,28)^V.rotrBH(r,s,34)^V.rotrBH(r,s,39),pe=V.rotrSL(r,s,28)^V.rotrBL(r,s,34)^V.rotrBL(r,s,39),oe=r&o^r&a^o&a,Je=s&i^s&c^i&c;_=p|0,E=b|0,p=h|0,b=m|0,h=w|0,m=y|0,{h:w,l:y}=V.add(u|0,l|0,X|0,ce|0),u=a|0,l=c|0,a=o|0,c=i|0,o=r|0,i=s|0;const C=V.add3L(ce,pe,Je);r=V.add3H(C,X,ue,oe),s=C|0}({h:r,l:s}=V.add(this.Ah|0,this.Al|0,r|0,s|0)),{h:o,l:i}=V.add(this.Bh|0,this.Bl|0,o|0,i|0),{h:a,l:c}=V.add(this.Ch|0,this.Cl|0,a|0,c|0),{h:u,l}=V.add(this.Dh|0,this.Dl|0,u|0,l|0),{h:w,l:y}=V.add(this.Eh|0,this.El|0,w|0,y|0),{h,l:m}=V.add(this.Fh|0,this.Fl|0,h|0,m|0),{h:p,l:b}=V.add(this.Gh|0,this.Gl|0,p|0,b|0),{h:_,l:E}=V.add(this.Hh|0,this.Hl|0,_|0,E|0),this.set(r,s,o,i,a,c,u,l,w,y,h,m,p,b,_,E)}roundClean(){lt.fill(0),dt.fill(0)}destroy(){this.buffer.fill(0),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}class la extends Ir{constructor(){super(),this.Ah=-1942145080,this.Al=424955298,this.Bh=1944164710,this.Bl=-1982016298,this.Ch=502970286,this.Cl=855612546,this.Dh=1738396948,this.Dl=1479516111,this.Eh=258812777,this.El=2077511080,this.Fh=2011393907,this.Fl=79989058,this.Gh=1067287976,this.Gl=1780299464,this.Hh=286451373,this.Hl=-1848208735,this.outputLen=28}}class da extends Ir{constructor(){super(),this.Ah=573645204,this.Al=-64227540,this.Bh=-1621794909,this.Bl=-934517566,this.Ch=596883563,this.Cl=1867755857,this.Dh=-1774684391,this.Dl=1497426621,this.Eh=-1775747358,this.El=-1467023389,this.Fh=-1101128155,this.Fl=1401305490,this.Gh=721525244,this.Gl=746961066,this.Hh=246885852,this.Hl=-2117784414,this.outputLen=32}}class fa extends Ir{constructor(){super(),this.Ah=-876896931,this.Al=-1056596264,this.Bh=1654270250,this.Bl=914150663,this.Ch=-1856437926,this.Cl=812702999,this.Dh=355462360,this.Dl=-150054599,this.Eh=1731405415,this.El=-4191439,this.Fh=-1900787065,this.Fl=1750603025,this.Gh=-619958771,this.Gl=1694076839,this.Hh=1203062813,this.Hl=-1090891868,this.outputLen=48}}const Sn=kr(()=>new Ir);kr(()=>new la);kr(()=>new da);kr(()=>new fa);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Xe=BigInt(0),Ke=BigInt(1),ur=BigInt(2),ha=BigInt(8),pa={zip215:!0};function ga(n){const e=Oi(n);return Zs(n,{hash:"function",a:"bigint",d:"bigint",randomBytes:"function"},{adjustScalarBytes:"function",domain:"function",uvRatio:"function",mapToCurve:"function"}),Object.freeze({...e})}function _n(n){const e=ga(n),{Fp:t,n:r,prehash:s,hash:o,randomBytes:i,nByteLength:a,h:c}=e,u=ur**BigInt(a*8),l=t.create,w=e.uvRatio||((x,S)=>{try{return{isValid:!0,value:t.sqrt(x*t.inv(S))}}catch{return{isValid:!1,value:Xe}}}),y=e.adjustScalarBytes||(x=>x),h=e.domain||((x,S,I)=>{if(S.length||I)throw new Error("Contexts/pre-hash are not supported");return x}),m=x=>typeof x=="bigint"&&Xe<x,p=(x,S)=>m(x)&&m(S)&&x<S,b=x=>x===Xe||p(x,u);function _(x,S){if(p(x,S))return x;throw new Error(`Expected valid scalar < ${S}, got ${typeof x} ${x}`)}function E(x){return x===Xe?x:_(x,r)}const d=new Map;function R(x){if(!(x instanceof v))throw new Error("ExtendedPoint expected")}class v{constructor(S,I,q,G){if(this.ex=S,this.ey=I,this.ez=q,this.et=G,!b(S))throw new Error("x required");if(!b(I))throw new Error("y required");if(!b(q))throw new Error("z required");if(!b(G))throw new Error("t required")}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static fromAffine(S){if(S instanceof v)throw new Error("extended point not allowed");const{x:I,y:q}=S||{};if(!b(I)||!b(q))throw new Error("invalid affine point");return new v(I,q,Ke,l(I*q))}static normalizeZ(S){const I=t.invertBatch(S.map(q=>q.ez));return S.map((q,G)=>q.toAffine(I[G])).map(v.fromAffine)}_setWindowSize(S){this._WINDOW_SIZE=S,d.delete(this)}assertValidity(){const{a:S,d:I}=e;if(this.is0())throw new Error("bad point: ZERO");const{ex:q,ey:G,ez:W,et:Q}=this,te=l(q*q),Y=l(G*G),ae=l(W*W),Se=l(ae*ae),Be=l(te*S),Ze=l(ae*l(Be+Y)),Te=l(Se+l(I*l(te*Y)));if(Ze!==Te)throw new Error("bad point: equation left != right (1)");const ut=l(q*G),bt=l(W*Q);if(ut!==bt)throw new Error("bad point: equation left != right (2)")}equals(S){R(S);const{ex:I,ey:q,ez:G}=this,{ex:W,ey:Q,ez:te}=S,Y=l(I*te),ae=l(W*G),Se=l(q*te),Be=l(Q*G);return Y===ae&&Se===Be}is0(){return this.equals(v.ZERO)}negate(){return new v(l(-this.ex),this.ey,this.ez,l(-this.et))}double(){const{a:S}=e,{ex:I,ey:q,ez:G}=this,W=l(I*I),Q=l(q*q),te=l(ur*l(G*G)),Y=l(S*W),ae=I+q,Se=l(l(ae*ae)-W-Q),Be=Y+Q,Ze=Be-te,Te=Y-Q,ut=l(Se*Ze),bt=l(Be*Te),ir=l(Se*Te),ar=l(Ze*Be);return new v(ut,bt,ar,ir)}add(S){R(S);const{a:I,d:q}=e,{ex:G,ey:W,ez:Q,et:te}=this,{ex:Y,ey:ae,ez:Se,et:Be}=S;if(I===BigInt(-1)){const Gn=l((W-G)*(ae+Y)),Wn=l((W+G)*(ae-Y)),Ur=l(Wn-Gn);if(Ur===Xe)return this.double();const Vn=l(Q*ur*Be),Jn=l(te*ur*Se),Zn=Jn+Vn,Xn=Wn+Gn,Yn=Jn-Vn,Si=l(Zn*Ur),_i=l(Xn*Yn),Ei=l(Zn*Yn),xi=l(Ur*Xn);return new v(Si,_i,xi,Ei)}const Ze=l(G*Y),Te=l(W*ae),ut=l(te*q*Be),bt=l(Q*Se),ir=l((G+W)*(Y+ae)-Ze-Te),ar=bt-ut,Hn=bt+ut,$n=l(Te-I*Ze),mi=l(ir*ar),wi=l(Hn*$n),bi=l(ir*$n),vi=l(ar*Hn);return new v(mi,wi,vi,bi)}subtract(S){return this.add(S.negate())}wNAF(S){return F.wNAFCached(this,d,S,v.normalizeZ)}multiply(S){const{p:I,f:q}=this.wNAF(_(S,r));return v.normalizeZ([I,q])[0]}multiplyUnsafe(S){let I=E(S);return I===Xe?T:this.equals(T)||I===Ke?this:this.equals(M)?this.wNAF(I).p:F.unsafeLadder(this,I)}isSmallOrder(){return this.multiplyUnsafe(c).is0()}isTorsionFree(){return F.unsafeLadder(this,r).is0()}toAffine(S){const{ex:I,ey:q,ez:G}=this,W=this.is0();S==null&&(S=W?ha:t.inv(G));const Q=l(I*S),te=l(q*S),Y=l(G*S);if(W)return{x:Xe,y:Ke};if(Y!==Ke)throw new Error("invZ was invalid");return{x:Q,y:te}}clearCofactor(){const{h:S}=e;return S===Ke?this:this.multiplyUnsafe(S)}static fromHex(S,I=!1){const{d:q,a:G}=e,W=t.BYTES;S=ze("pointHex",S,W);const Q=S.slice(),te=S[W-1];Q[W-1]=te&-129;const Y=Ct(Q);Y===Xe||(I?_(Y,u):_(Y,t.ORDER));const ae=l(Y*Y),Se=l(ae-Ke),Be=l(q*ae-G);let{isValid:Ze,value:Te}=w(Se,Be);if(!Ze)throw new Error("Point.fromHex: invalid y coordinate");const ut=(Te&Ke)===Ke;return(te&128)!==0!==ut&&(Te=l(-Te)),v.fromAffine({x:Te,y:Y})}static fromPrivateKey(S){return ue(S).point}toRawBytes(){const{x:S,y:I}=this.toAffine(),q=Wt(I,t.BYTES);return q[q.length-1]|=S&Ke?128:0,q}toHex(){return Xs(this.toRawBytes())}}v.BASE=new v(e.Gx,e.Gy,Ke,l(e.Gx*e.Gy)),v.ZERO=new v(Xe,Ke,Ke,Xe);const{BASE:M,ZERO:T}=v,F=Ti(v,a*8);function X(x){return Ge(x,r)}function ce(x){return X(Ct(x))}function ue(x){const S=a;x=ze("private key",x,S);const I=ze("hashed private key",o(x),2*S),q=y(I.slice(0,S)),G=I.slice(S,2*S),W=ce(q),Q=M.multiply(W),te=Q.toRawBytes();return{head:q,prefix:G,scalar:W,point:Q,pointBytes:te}}function pe(x){return ue(x).pointBytes}function oe(x=new Uint8Array,...S){const I=Qn(...S);return ce(o(h(I,ze("context",x),!!s)))}function Je(x,S,I={}){x=ze("message",x),s&&(x=s(x));const{prefix:q,scalar:G,pointBytes:W}=ue(S),Q=oe(I.context,q,x),te=M.multiply(Q).toRawBytes(),Y=oe(I.context,te,W,x),ae=X(Q+Y*G);E(ae);const Se=Qn(te,Wt(ae,t.BYTES));return ze("result",Se,a*2)}const C=pa;function A(x,S,I,q=C){const{context:G,zip215:W}=q,Q=t.BYTES;x=ze("signature",x,2*Q),S=ze("message",S),s&&(S=s(S));const te=Ct(x.slice(Q,2*Q));let Y,ae,Se;try{Y=v.fromHex(I,W),ae=v.fromHex(x.slice(0,Q),W),Se=M.multiplyUnsafe(te)}catch{return!1}const Be=oe(G,ae.toRawBytes(),Y.toRawBytes(),S);return ae.add(Y.multiplyUnsafe(Be)).subtract(Se).clearCofactor().equals(v.ZERO)}return M._setWindowSize(8),{CURVE:e,getPublicKey:pe,sign:Je,verify:A,ExtendedPoint:v,utils:{getExtendedPublicKey:ue,randomPrivateKey:()=>i(t.BYTES),precompute(x=8,S=v.BASE){return S._setWindowSize(x),S.multiply(BigInt(3)),S}}}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const zt=BigInt(0),zr=BigInt(1);function ya(n){return Zs(n,{a:"bigint"},{montgomeryBits:"isSafeInteger",nByteLength:"isSafeInteger",adjustScalarBytes:"function",domain:"function",powPminus2:"function",Gu:"bigint"}),Object.freeze({...n})}function ma(n){const e=ya(n),{P:t}=e,r=d=>Ge(d,t),s=e.montgomeryBits,o=Math.ceil(s/8),i=e.nByteLength,a=e.adjustScalarBytes||(d=>d),c=e.powPminus2||(d=>Li(d,t-BigInt(2),t));function u(d,R,v){const M=r(d*(R-v));return R=r(R-M),v=r(v+M),[R,v]}function l(d){if(typeof d=="bigint"&&zt<=d&&d<t)return d;throw new Error("Expected valid scalar 0 < scalar < CURVE.P")}const w=(e.a-BigInt(2))/BigInt(4);function y(d,R){const v=l(d),M=l(R),T=v;let F=zr,X=zt,ce=v,ue=zr,pe=zt,oe;for(let C=BigInt(s-1);C>=zt;C--){const A=M>>C&zr;pe^=A,oe=u(pe,F,ce),F=oe[0],ce=oe[1],oe=u(pe,X,ue),X=oe[0],ue=oe[1],pe=A;const B=F+X,x=r(B*B),S=F-X,I=r(S*S),q=x-I,G=ce+ue,W=ce-ue,Q=r(W*B),te=r(G*S),Y=Q+te,ae=Q-te;ce=r(Y*Y),ue=r(T*r(ae*ae)),F=r(x*I),X=r(q*(x+r(w*q)))}oe=u(pe,F,ce),F=oe[0],ce=oe[1],oe=u(pe,X,ue),X=oe[0],ue=oe[1];const Je=c(X);return r(F*Je)}function h(d){return Wt(r(d),o)}function m(d){const R=ze("u coordinate",d,o);return i===o&&(R[i-1]&=127),Ct(R)}function p(d){const R=ze("scalar",d);if(R.length!==o&&R.length!==i)throw new Error(`Expected ${o} or ${i} bytes, got ${R.length}`);return Ct(a(R))}function b(d,R){const v=m(R),M=p(d),T=y(v,M);if(T===zt)throw new Error("Invalid private or public key received");return h(T)}const _=h(e.Gu);function E(d){return b(d,_)}return{scalarMult:b,scalarMultBase:E,getSharedSecret:(d,R)=>b(d,R),getPublicKey:d=>E(d),utils:{randomPrivateKey:()=>e.randomBytes(e.nByteLength)},GuBytes:_}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Vt=BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),fs=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752"),wa=BigInt(0),et=BigInt(1),gr=BigInt(2),ba=BigInt(5),hs=BigInt(10),va=BigInt(20),Sa=BigInt(40),ps=BigInt(80);function io(n){const e=Vt,r=n*n%e*n%e,s=$e(r,gr,e)*r%e,o=$e(s,et,e)*n%e,i=$e(o,ba,e)*o%e,a=$e(i,hs,e)*i%e,c=$e(a,va,e)*a%e,u=$e(c,Sa,e)*c%e,l=$e(u,ps,e)*u%e,w=$e(l,ps,e)*u%e,y=$e(w,hs,e)*i%e;return{pow_p_5_8:$e(y,gr,e)*n%e,b2:r}}function ao(n){return n[0]&=248,n[31]&=127,n[31]|=64,n}function En(n,e){const t=Vt,r=Ge(e*e*e,t),s=Ge(r*r*e,t),o=io(n*s).pow_p_5_8;let i=Ge(n*r*o,t);const a=Ge(e*i*i,t),c=i,u=Ge(i*fs,t),l=a===n,w=a===Ge(-n,t),y=a===Ge(-n*fs,t);return l&&(i=c),(w||y)&&(i=u),ft(i,t)&&(i=Ge(-i,t)),{isValid:l||w,value:i}}const U=Ni(Vt,void 0,!0),xn={a:BigInt(-1),d:BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),Fp:U,n:BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),h:BigInt(8),Gx:BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),Gy:BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),hash:Sn,randomBytes:Ys,adjustScalarBytes:ao,uvRatio:En},ge=_n(xn);function co(n,e,t){if(e.length>255)throw new Error("Context is too big");return qi(Di("SigEd25519 no Ed25519 collisions"),new Uint8Array([t?1:0,e.length]),e,n)}_n({...xn,domain:co});_n({...xn,domain:co,prehash:Sn});ma({P:Vt,a:BigInt(486662),montgomeryBits:255,nByteLength:32,Gu:BigInt(9),powPminus2:n=>{const e=Vt,{pow_p_5_8:t,b2:r}=io(n);return Ge($e(t,BigInt(3),e)*r,e)},adjustScalarBytes:ao,randomBytes:Ys});const _a=(U.ORDER+BigInt(3))/BigInt(8),Ea=U.pow(gr,_a),gs=U.sqrt(U.neg(U.ONE)),xa=(U.ORDER-BigInt(5))/BigInt(8),ys=BigInt(486662);function ka(n){let e=U.sqr(n);e=U.mul(e,gr);let t=U.add(e,U.ONE),r=U.neg(ys),s=U.sqr(t),o=U.mul(s,t),i=U.mul(e,ys);i=U.mul(i,r),i=U.add(i,s),i=U.mul(i,r);let a=U.sqr(o);s=U.sqr(a),a=U.mul(a,o),a=U.mul(a,i),s=U.mul(s,a);let c=U.pow(s,xa);c=U.mul(c,a);let u=U.mul(c,gs);s=U.sqr(c),s=U.mul(s,o);let l=U.eql(s,i),w=U.cmov(u,c,l),y=U.mul(r,e),h=U.mul(c,n);h=U.mul(h,Ea);let m=U.mul(h,gs),p=U.mul(i,e);s=U.sqr(h),s=U.mul(s,o);let b=U.eql(s,p),_=U.cmov(m,h,b);s=U.sqr(w),s=U.mul(s,o);let E=U.eql(s,i),d=U.cmov(y,r,E),R=U.cmov(_,w,E),v=U.isOdd(R);return R=U.cmov(R,U.neg(R),E!==v),{xMn:d,xMd:t,yMn:R,yMd:et}}const Aa=Mi(U,U.neg(BigInt(486664)));function Ia(n){const{xMn:e,xMd:t,yMn:r,yMd:s}=ka(n);let o=U.mul(e,s);o=U.mul(o,Aa);let i=U.mul(t,r),a=U.sub(e,t),c=U.add(e,t),u=U.mul(i,c),l=U.eql(u,U.ZERO);o=U.cmov(o,U.ZERO,l),i=U.cmov(i,U.ONE,l),a=U.cmov(a,U.ONE,l),c=U.cmov(c,U.ONE,l);const w=U.invertBatch([i,c]);return{x:U.mul(o,w[0]),y:U.mul(a,w[1])}}Ui(ge.ExtendedPoint,n=>Ia(n[0]),{DST:"edwards25519_XMD:SHA-512_ELL2_RO_",encodeDST:"edwards25519_XMD:SHA-512_ELL2_NU_",p:U.ORDER,m:1,k:128,expand:"xmd",hash:Sn});function jr(n){if(!(n instanceof Ne))throw new Error("RistrettoPoint expected")}const fn=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752"),Ra=BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235"),Ba=BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578"),Pa=BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838"),Ca=BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952"),ms=n=>En(et,n),Oa=BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"),Hr=n=>ge.CURVE.Fp.create(Ct(n)&Oa);function ws(n){const{d:e}=ge.CURVE,t=ge.CURVE.Fp.ORDER,r=ge.CURVE.Fp.create,s=r(fn*n*n),o=r((s+et)*Pa);let i=BigInt(-1);const a=r((i-e*s)*r(s+e));let{isValid:c,value:u}=En(o,a),l=r(u*n);ft(l,t)||(l=r(-l)),c||(u=l),c||(i=s);const w=r(i*(s-et)*Ca-a),y=u*u,h=r((u+u)*a),m=r(w*Ra),p=r(et-y),b=r(et+y);return new ge.ExtendedPoint(r(h*b),r(p*m),r(m*b),r(h*p))}class Ne{constructor(e){this.ep=e}static fromAffine(e){return new Ne(ge.ExtendedPoint.fromAffine(e))}static hashToCurve(e){e=ze("ristrettoHash",e,64);const t=Hr(e.slice(0,32)),r=ws(t),s=Hr(e.slice(32,64)),o=ws(s);return new Ne(r.add(o))}static fromHex(e){e=ze("ristrettoHex",e,32);const{a:t,d:r}=ge.CURVE,s=ge.CURVE.Fp.ORDER,o=ge.CURVE.Fp.create,i="RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint",a=Hr(e);if(!Fi(Wt(a,32),e)||ft(a,s))throw new Error(i);const c=o(a*a),u=o(et+t*c),l=o(et-t*c),w=o(u*u),y=o(l*l),h=o(t*r*w-y),{isValid:m,value:p}=ms(o(h*y)),b=o(p*l),_=o(p*b*h);let E=o((a+a)*b);ft(E,s)&&(E=o(-E));const d=o(u*_),R=o(E*d);if(!m||ft(R,s)||d===wa)throw new Error(i);return new Ne(new ge.ExtendedPoint(E,d,et,R))}toRawBytes(){let{ex:e,ey:t,ez:r,et:s}=this.ep;const o=ge.CURVE.Fp.ORDER,i=ge.CURVE.Fp.create,a=i(i(r+t)*i(r-t)),c=i(e*t),u=i(c*c),{value:l}=ms(i(a*u)),w=i(l*a),y=i(l*c),h=i(w*y*s);let m;if(ft(s*h,o)){let b=i(t*fn),_=i(e*fn);e=b,t=_,m=i(w*Ba)}else m=y;ft(e*h,o)&&(t=i(-t));let p=i((r-t)*m);return ft(p,o)&&(p=i(-p)),Wt(p,32)}toHex(){return Xs(this.toRawBytes())}toString(){return this.toHex()}equals(e){jr(e);const{ex:t,ey:r}=this.ep,{ex:s,ey:o}=e.ep,i=ge.CURVE.Fp.create,a=i(t*o)===i(r*s),c=i(r*o)===i(t*s);return a||c}add(e){return jr(e),new Ne(this.ep.add(e.ep))}subtract(e){return jr(e),new Ne(this.ep.subtract(e.ep))}multiply(e){return new Ne(this.ep.multiply(e))}multiplyUnsafe(e){return new Ne(this.ep.multiplyUnsafe(e))}}Ne.BASE=new Ne(ge.ExtendedPoint.BASE);Ne.ZERO=new Ne(ge.ExtendedPoint.ZERO);var ve={};function it(n,e,t){return e<=n&&n<=t}function Rr(n){if(n===void 0)return{};if(n===Object(n))return n;throw TypeError("Could not convert argument to dictionary")}function Ta(n){for(var e=String(n),t=e.length,r=0,s=[];r<t;){var o=e.charCodeAt(r);if(o<55296||o>57343)s.push(o);else if(56320<=o&&o<=57343)s.push(65533);else if(55296<=o&&o<=56319)if(r===t-1)s.push(65533);else{var i=n.charCodeAt(r+1);if(56320<=i&&i<=57343){var a=o&1023,c=i&1023;s.push(65536+(a<<10)+c),r+=1}else s.push(65533)}r+=1}return s}function La(n){for(var e="",t=0;t<n.length;++t){var r=n[t];r<=65535?e+=String.fromCharCode(r):(r-=65536,e+=String.fromCharCode((r>>10)+55296,(r&1023)+56320))}return e}var yr=-1;function kn(n){this.tokens=[].slice.call(n)}kn.prototype={endOfStream:function(){return!this.tokens.length},read:function(){return this.tokens.length?this.tokens.shift():yr},prepend:function(n){if(Array.isArray(n))for(var e=n;e.length;)this.tokens.unshift(e.pop());else this.tokens.unshift(n)},push:function(n){if(Array.isArray(n))for(var e=n;e.length;)this.tokens.push(e.shift());else this.tokens.push(n)}};var Lt=-1;function $r(n,e){if(n)throw TypeError("Decoder error");return e||65533}var mr="utf-8";function wr(n,e){if(!(this instanceof wr))return new wr(n,e);if(n=n!==void 0?String(n).toLowerCase():mr,n!==mr)throw new Error("Encoding not supported. Only utf-8 is supported");e=Rr(e),this._streaming=!1,this._BOMseen=!1,this._decoder=null,this._fatal=!!e.fatal,this._ignoreBOM=!!e.ignoreBOM,Object.defineProperty(this,"encoding",{value:"utf-8"}),Object.defineProperty(this,"fatal",{value:this._fatal}),Object.defineProperty(this,"ignoreBOM",{value:this._ignoreBOM})}wr.prototype={decode:function(e,t){var r;typeof e=="object"&&e instanceof ArrayBuffer?r=new Uint8Array(e):typeof e=="object"&&"buffer"in e&&e.buffer instanceof ArrayBuffer?r=new Uint8Array(e.buffer,e.byteOffset,e.byteLength):r=new Uint8Array(0),t=Rr(t),this._streaming||(this._decoder=new Na({fatal:this._fatal}),this._BOMseen=!1),this._streaming=!!t.stream;for(var s=new kn(r),o=[],i;!s.endOfStream()&&(i=this._decoder.handler(s,s.read()),i!==Lt);)i!==null&&(Array.isArray(i)?o.push.apply(o,i):o.push(i));if(!this._streaming){do{if(i=this._decoder.handler(s,s.read()),i===Lt)break;i!==null&&(Array.isArray(i)?o.push.apply(o,i):o.push(i))}while(!s.endOfStream());this._decoder=null}return o.length&&["utf-8"].indexOf(this.encoding)!==-1&&!this._ignoreBOM&&!this._BOMseen&&(o[0]===65279?(this._BOMseen=!0,o.shift()):this._BOMseen=!0),La(o)}};function br(n,e){if(!(this instanceof br))return new br(n,e);if(n=n!==void 0?String(n).toLowerCase():mr,n!==mr)throw new Error("Encoding not supported. Only utf-8 is supported");e=Rr(e),this._streaming=!1,this._encoder=null,this._options={fatal:!!e.fatal},Object.defineProperty(this,"encoding",{value:"utf-8"})}br.prototype={encode:function(e,t){e=e?String(e):"",t=Rr(t),this._streaming||(this._encoder=new Ma(this._options)),this._streaming=!!t.stream;for(var r=[],s=new kn(Ta(e)),o;!s.endOfStream()&&(o=this._encoder.handler(s,s.read()),o!==Lt);)Array.isArray(o)?r.push.apply(r,o):r.push(o);if(!this._streaming){for(;o=this._encoder.handler(s,s.read()),o!==Lt;)Array.isArray(o)?r.push.apply(r,o):r.push(o);this._encoder=null}return new Uint8Array(r)}};function Na(n){var e=n.fatal,t=0,r=0,s=0,o=128,i=191;this.handler=function(a,c){if(c===yr&&s!==0)return s=0,$r(e);if(c===yr)return Lt;if(s===0){if(it(c,0,127))return c;if(it(c,194,223))s=1,t=c-192;else if(it(c,224,239))c===224&&(o=160),c===237&&(i=159),s=2,t=c-224;else if(it(c,240,244))c===240&&(o=144),c===244&&(i=143),s=3,t=c-240;else return $r(e);return t=t<<6*s,null}if(!it(c,o,i))return t=s=r=0,o=128,i=191,a.prepend(c),$r(e);if(o=128,i=191,r+=1,t+=c-128<<6*(s-r),r!==s)return null;var u=t;return t=s=r=0,u}}function Ma(n){n.fatal,this.handler=function(e,t){if(t===yr)return Lt;if(it(t,0,127))return t;var r,s;it(t,128,2047)?(r=1,s=192):it(t,2048,65535)?(r=2,s=224):it(t,65536,1114111)&&(r=3,s=240);for(var o=[(t>>6*r)+s];r>0;){var i=t>>6*(r-1);o.push(128|i&63),r-=1}return o}}const Ua=Object.freeze(Object.defineProperty({__proto__:null,TextDecoder:wr,TextEncoder:br},Symbol.toStringTag,{value:"Module"})),Fa=Qs(Ua);var qa=rt&&rt.__createBinding||(Object.create?function(n,e,t,r){r===void 0&&(r=t),Object.defineProperty(n,r,{enumerable:!0,get:function(){return e[t]}})}:function(n,e,t,r){r===void 0&&(r=t),n[r]=e[t]}),Da=rt&&rt.__setModuleDefault||(Object.create?function(n,e){Object.defineProperty(n,"default",{enumerable:!0,value:e})}:function(n,e){n.default=e}),nt=rt&&rt.__decorate||function(n,e,t,r){var s=arguments.length,o=s<3?e:r===null?r=Object.getOwnPropertyDescriptor(e,t):r,i;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")o=Reflect.decorate(n,e,t,r);else for(var a=n.length-1;a>=0;a--)(i=n[a])&&(o=(s<3?i(o):s>3?i(e,t,o):i(e,t))||o);return s>3&&o&&Object.defineProperty(e,t,o),o},Ka=rt&&rt.__importStar||function(n){if(n&&n.__esModule)return n;var e={};if(n!=null)for(var t in n)t!=="default"&&Object.hasOwnProperty.call(n,t)&&qa(e,n,t);return Da(e,n),e},uo=rt&&rt.__importDefault||function(n){return n&&n.__esModule?n:{default:n}};Object.defineProperty(ve,"__esModule",{value:!0});var lo=ve.deserializeUnchecked=mo=ve.deserialize=yo=ve.serialize=ve.BinaryReader=ve.BinaryWriter=ve.BorshError=ve.baseDecode=ve.baseEncode=void 0;const pt=uo(Ki),fo=uo(oo),za=Ka(Fa),ja=typeof TextDecoder!="function"?za.TextDecoder:TextDecoder,Ha=new ja("utf-8",{fatal:!0});function $a(n){return typeof n=="string"&&(n=D.from(n,"utf8")),fo.default.encode(D.from(n))}ve.baseEncode=$a;function Ga(n){return D.from(fo.default.decode(n))}ve.baseDecode=Ga;const Gr=1024;class Re extends Error{constructor(e){super(e),this.fieldPath=[],this.originalMessage=e}addToFieldPath(e){this.fieldPath.splice(0,0,e),this.message=this.originalMessage+": "+this.fieldPath.join(".")}}ve.BorshError=Re;class ho{constructor(){this.buf=D.alloc(Gr),this.length=0}maybeResize(){this.buf.length<16+this.length&&(this.buf=D.concat([this.buf,D.alloc(Gr)]))}writeU8(e){this.maybeResize(),this.buf.writeUInt8(e,this.length),this.length+=1}writeU16(e){this.maybeResize(),this.buf.writeUInt16LE(e,this.length),this.length+=2}writeU32(e){this.maybeResize(),this.buf.writeUInt32LE(e,this.length),this.length+=4}writeU64(e){this.maybeResize(),this.writeBuffer(D.from(new pt.default(e).toArray("le",8)))}writeU128(e){this.maybeResize(),this.writeBuffer(D.from(new pt.default(e).toArray("le",16)))}writeU256(e){this.maybeResize(),this.writeBuffer(D.from(new pt.default(e).toArray("le",32)))}writeU512(e){this.maybeResize(),this.writeBuffer(D.from(new pt.default(e).toArray("le",64)))}writeBuffer(e){this.buf=D.concat([D.from(this.buf.subarray(0,this.length)),e,D.alloc(Gr)]),this.length+=e.length}writeString(e){this.maybeResize();const t=D.from(e,"utf8");this.writeU32(t.length),this.writeBuffer(t)}writeFixedArray(e){this.writeBuffer(D.from(e))}writeArray(e,t){this.maybeResize(),this.writeU32(e.length);for(const r of e)this.maybeResize(),t(r)}toArray(){return this.buf.subarray(0,this.length)}}ve.BinaryWriter=ho;function st(n,e,t){const r=t.value;t.value=function(...s){try{return r.apply(this,s)}catch(o){if(o instanceof RangeError){const i=o.code;if(["ERR_BUFFER_OUT_OF_BOUNDS","ERR_OUT_OF_RANGE"].indexOf(i)>=0)throw new Re("Reached the end of buffer when deserializing")}throw o}}}class qe{constructor(e){this.buf=e,this.offset=0}readU8(){const e=this.buf.readUInt8(this.offset);return this.offset+=1,e}readU16(){const e=this.buf.readUInt16LE(this.offset);return this.offset+=2,e}readU32(){const e=this.buf.readUInt32LE(this.offset);return this.offset+=4,e}readU64(){const e=this.readBuffer(8);return new pt.default(e,"le")}readU128(){const e=this.readBuffer(16);return new pt.default(e,"le")}readU256(){const e=this.readBuffer(32);return new pt.default(e,"le")}readU512(){const e=this.readBuffer(64);return new pt.default(e,"le")}readBuffer(e){if(this.offset+e>this.buf.length)throw new Re(`Expected buffer length ${e} isn't within bounds`);const t=this.buf.slice(this.offset,this.offset+e);return this.offset+=e,t}readString(){const e=this.readU32(),t=this.readBuffer(e);try{return Ha.decode(t)}catch(r){throw new Re(`Error decoding UTF-8 string: ${r}`)}}readFixedArray(e){return new Uint8Array(this.readBuffer(e))}readArray(e){const t=this.readU32(),r=Array();for(let s=0;s<t;++s)r.push(e());return r}}nt([st],qe.prototype,"readU8",null);nt([st],qe.prototype,"readU16",null);nt([st],qe.prototype,"readU32",null);nt([st],qe.prototype,"readU64",null);nt([st],qe.prototype,"readU128",null);nt([st],qe.prototype,"readU256",null);nt([st],qe.prototype,"readU512",null);nt([st],qe.prototype,"readString",null);nt([st],qe.prototype,"readFixedArray",null);nt([st],qe.prototype,"readArray",null);ve.BinaryReader=qe;function po(n){return n.charAt(0).toUpperCase()+n.slice(1)}function vt(n,e,t,r,s){try{if(typeof r=="string")s[`write${po(r)}`](t);else if(r instanceof Array)if(typeof r[0]=="number"){if(t.length!==r[0])throw new Re(`Expecting byte array of length ${r[0]}, but got ${t.length} bytes`);s.writeFixedArray(t)}else if(r.length===2&&typeof r[1]=="number"){if(t.length!==r[1])throw new Re(`Expecting byte array of length ${r[1]}, but got ${t.length} bytes`);for(let o=0;o<r[1];o++)vt(n,null,t[o],r[0],s)}else s.writeArray(t,o=>{vt(n,e,o,r[0],s)});else if(r.kind!==void 0)switch(r.kind){case"option":{t==null?s.writeU8(0):(s.writeU8(1),vt(n,e,t,r.type,s));break}case"map":{s.writeU32(t.size),t.forEach((o,i)=>{vt(n,e,i,r.key,s),vt(n,e,o,r.value,s)});break}default:throw new Re(`FieldType ${r} unrecognized`)}else go(n,t,s)}catch(o){throw o instanceof Re&&o.addToFieldPath(e),o}}function go(n,e,t){if(typeof e.borshSerialize=="function"){e.borshSerialize(t);return}const r=n.get(e.constructor);if(!r)throw new Re(`Class ${e.constructor.name} is missing in schema`);if(r.kind==="struct")r.fields.map(([s,o])=>{vt(n,s,e[s],o,t)});else if(r.kind==="enum"){const s=e[r.field];for(let o=0;o<r.values.length;++o){const[i,a]=r.values[o];if(i===s){t.writeU8(o),vt(n,i,e[i],a,t);break}}}else throw new Re(`Unexpected schema kind: ${r.kind} for ${e.constructor.name}`)}function Wa(n,e,t=ho){const r=new t;return go(n,e,r),r.toArray()}var yo=ve.serialize=Wa;function St(n,e,t,r){try{if(typeof t=="string")return r[`read${po(t)}`]();if(t instanceof Array){if(typeof t[0]=="number")return r.readFixedArray(t[0]);if(typeof t[1]=="number"){const s=[];for(let o=0;o<t[1];o++)s.push(St(n,null,t[0],r));return s}else return r.readArray(()=>St(n,e,t[0],r))}if(t.kind==="option")return r.readU8()?St(n,e,t.type,r):void 0;if(t.kind==="map"){let s=new Map;const o=r.readU32();for(let i=0;i<o;i++){const a=St(n,e,t.key,r),c=St(n,e,t.value,r);s.set(a,c)}return s}return An(n,t,r)}catch(s){throw s instanceof Re&&s.addToFieldPath(e),s}}function An(n,e,t){if(typeof e.borshDeserialize=="function")return e.borshDeserialize(t);const r=n.get(e);if(!r)throw new Re(`Class ${e.name} is missing in schema`);if(r.kind==="struct"){const s={};for(const[o,i]of n.get(e).fields)s[o]=St(n,o,i,t);return new e(s)}if(r.kind==="enum"){const s=t.readU8();if(s>=r.values.length)throw new Re(`Enum index: ${s} is out of range`);const[o,i]=r.values[s],a=St(n,o,i,t);return new e({[o]:a})}throw new Re(`Unexpected schema kind: ${r.kind} for ${e.constructor.name}`)}function Va(n,e,t,r=qe){const s=new r(t),o=An(n,e,s);if(s.offset<t.length)throw new Re(`Unexpected ${t.length-s.offset} bytes after deserialized data`);return o}var mo=ve.deserialize=Va;function Ja(n,e,t,r=qe){const s=new r(t);return An(n,e,s)}lo=ve.deserializeUnchecked=Ja;var g={};Object.defineProperty(g,"__esModule",{value:!0});g.s16=g.s8=g.nu64be=g.u48be=g.u40be=g.u32be=g.u24be=g.u16be=be=g.nu64=g.u48=g.u40=j=g.u32=g.u24=je=g.u16=ne=g.u8=_t=g.offset=g.greedy=g.Constant=g.UTF8=g.CString=g.Blob=g.Boolean=g.BitField=g.BitStructure=g.VariantLayout=g.Union=g.UnionLayoutDiscriminator=g.UnionDiscriminator=g.Structure=g.Sequence=g.DoubleBE=g.Double=g.FloatBE=g.Float=g.NearInt64BE=g.NearInt64=g.NearUInt64BE=g.NearUInt64=g.IntBE=g.Int=g.UIntBE=g.UInt=g.OffsetLayout=g.GreedyCount=g.ExternalLayout=g.bindConstructorLayout=g.nameWithProperty=g.Layout=g.uint8ArrayToBuffer=g.checkUint8Array=void 0;g.constant=g.utf8=g.cstr=le=g.blob=g.unionLayoutDiscriminator=g.union=Ie=g.seq=g.bits=K=g.struct=g.f64be=g.f64=g.f32be=g.f32=g.ns64be=g.s48be=g.s40be=g.s32be=g.s24be=g.s16be=Me=g.ns64=g.s48=g.s40=g.s32=g.s24=void 0;const In=zi;function Ut(n){if(!(n instanceof Uint8Array))throw new TypeError("b must be a Uint8Array")}g.checkUint8Array=Ut;function re(n){return Ut(n),In.Buffer.from(n.buffer,n.byteOffset,n.length)}g.uint8ArrayToBuffer=re;class se{constructor(e,t){if(!Number.isInteger(e))throw new TypeError("span must be an integer");this.span=e,this.property=t}makeDestinationObject(){return{}}getSpan(e,t){if(0>this.span)throw new RangeError("indeterminate span");return this.span}replicate(e){const t=Object.create(this.constructor.prototype);return Object.assign(t,this),t.property=e,t}fromArray(e){}}g.Layout=se;function Rn(n,e){return e.property?n+"["+e.property+"]":n}g.nameWithProperty=Rn;function Za(n,e){if(typeof n!="function")throw new TypeError("Class must be constructor");if(Object.prototype.hasOwnProperty.call(n,"layout_"))throw new Error("Class is already bound to a layout");if(!(e&&e instanceof se))throw new TypeError("layout must be a Layout");if(Object.prototype.hasOwnProperty.call(e,"boundConstructor_"))throw new Error("layout is already bound to a constructor");n.layout_=e,e.boundConstructor_=n,e.makeDestinationObject=()=>new n,Object.defineProperty(n.prototype,"encode",{value(t,r){return e.encode(this,t,r)},writable:!0}),Object.defineProperty(n,"decode",{value(t,r){return e.decode(t,r)},writable:!0})}g.bindConstructorLayout=Za;class Pe extends se{isCount(){throw new Error("ExternalLayout is abstract")}}g.ExternalLayout=Pe;class wo extends Pe{constructor(e=1,t){if(!Number.isInteger(e)||0>=e)throw new TypeError("elementSpan must be a (positive) integer");super(-1,t),this.elementSpan=e}isCount(){return!0}decode(e,t=0){Ut(e);const r=e.length-t;return Math.floor(r/this.elementSpan)}encode(e,t,r){return 0}}g.GreedyCount=wo;class Bn extends Pe{constructor(e,t=0,r){if(!(e instanceof se))throw new TypeError("layout must be a Layout");if(!Number.isInteger(t))throw new TypeError("offset must be integer or undefined");super(e.span,r||e.property),this.layout=e,this.offset=t}isCount(){return this.layout instanceof He||this.layout instanceof We}decode(e,t=0){return this.layout.decode(e,t+this.offset)}encode(e,t,r=0){return this.layout.encode(e,t,r+this.offset)}}g.OffsetLayout=Bn;class He extends se{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return re(e).readUIntLE(t,this.span)}encode(e,t,r=0){return re(t).writeUIntLE(e,r,this.span),this.span}}g.UInt=He;class We extends se{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return re(e).readUIntBE(t,this.span)}encode(e,t,r=0){return re(t).writeUIntBE(e,r,this.span),this.span}}g.UIntBE=We;class Et extends se{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return re(e).readIntLE(t,this.span)}encode(e,t,r=0){return re(t).writeIntLE(e,r,this.span),this.span}}g.Int=Et;class Ft extends se{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return re(e).readIntBE(t,this.span)}encode(e,t,r=0){return re(t).writeIntBE(e,r,this.span),this.span}}g.IntBE=Ft;const hn=Math.pow(2,32);function Br(n){const e=Math.floor(n/hn),t=n-e*hn;return{hi32:e,lo32:t}}function Pr(n,e){return n*hn+e}class bo extends se{constructor(e){super(8,e)}decode(e,t=0){const r=re(e),s=r.readUInt32LE(t),o=r.readUInt32LE(t+4);return Pr(o,s)}encode(e,t,r=0){const s=Br(e),o=re(t);return o.writeUInt32LE(s.lo32,r),o.writeUInt32LE(s.hi32,r+4),8}}g.NearUInt64=bo;class vo extends se{constructor(e){super(8,e)}decode(e,t=0){const r=re(e),s=r.readUInt32BE(t),o=r.readUInt32BE(t+4);return Pr(s,o)}encode(e,t,r=0){const s=Br(e),o=re(t);return o.writeUInt32BE(s.hi32,r),o.writeUInt32BE(s.lo32,r+4),8}}g.NearUInt64BE=vo;class So extends se{constructor(e){super(8,e)}decode(e,t=0){const r=re(e),s=r.readUInt32LE(t),o=r.readInt32LE(t+4);return Pr(o,s)}encode(e,t,r=0){const s=Br(e),o=re(t);return o.writeUInt32LE(s.lo32,r),o.writeInt32LE(s.hi32,r+4),8}}g.NearInt64=So;class _o extends se{constructor(e){super(8,e)}decode(e,t=0){const r=re(e),s=r.readInt32BE(t),o=r.readUInt32BE(t+4);return Pr(s,o)}encode(e,t,r=0){const s=Br(e),o=re(t);return o.writeInt32BE(s.hi32,r),o.writeUInt32BE(s.lo32,r+4),8}}g.NearInt64BE=_o;class Eo extends se{constructor(e){super(4,e)}decode(e,t=0){return re(e).readFloatLE(t)}encode(e,t,r=0){return re(t).writeFloatLE(e,r),4}}g.Float=Eo;class xo extends se{constructor(e){super(4,e)}decode(e,t=0){return re(e).readFloatBE(t)}encode(e,t,r=0){return re(t).writeFloatBE(e,r),4}}g.FloatBE=xo;class ko extends se{constructor(e){super(8,e)}decode(e,t=0){return re(e).readDoubleLE(t)}encode(e,t,r=0){return re(t).writeDoubleLE(e,r),8}}g.Double=ko;class Ao extends se{constructor(e){super(8,e)}decode(e,t=0){return re(e).readDoubleBE(t)}encode(e,t,r=0){return re(t).writeDoubleBE(e,r),8}}g.DoubleBE=Ao;class Io extends se{constructor(e,t,r){if(!(e instanceof se))throw new TypeError("elementLayout must be a Layout");if(!(t instanceof Pe&&t.isCount()||Number.isInteger(t)&&0<=t))throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");let s=-1;!(t instanceof Pe)&&0<e.span&&(s=t*e.span),super(s,r),this.elementLayout=e,this.count=t}getSpan(e,t=0){if(0<=this.span)return this.span;let r=0,s=this.count;if(s instanceof Pe&&(s=s.decode(e,t)),0<this.elementLayout.span)r=s*this.elementLayout.span;else{let o=0;for(;o<s;)r+=this.elementLayout.getSpan(e,t+r),++o}return r}decode(e,t=0){const r=[];let s=0,o=this.count;for(o instanceof Pe&&(o=o.decode(e,t));s<o;)r.push(this.elementLayout.decode(e,t)),t+=this.elementLayout.getSpan(e,t),s+=1;return r}encode(e,t,r=0){const s=this.elementLayout,o=e.reduce((i,a)=>i+s.encode(a,t,r+i),0);return this.count instanceof Pe&&this.count.encode(e.length,t,r),o}}g.Sequence=Io;class Ro extends se{constructor(e,t,r){if(!(Array.isArray(e)&&e.reduce((o,i)=>o&&i instanceof se,!0)))throw new TypeError("fields must be array of Layout instances");typeof t=="boolean"&&r===void 0&&(r=t,t=void 0);for(const o of e)if(0>o.span&&o.property===void 0)throw new Error("fields cannot contain unnamed variable-length layout");let s=-1;try{s=e.reduce((o,i)=>o+i.getSpan(),0)}catch{}super(s,t),this.fields=e,this.decodePrefixes=!!r}getSpan(e,t=0){if(0<=this.span)return this.span;let r=0;try{r=this.fields.reduce((s,o)=>{const i=o.getSpan(e,t);return t+=i,s+i},0)}catch{throw new RangeError("indeterminate span")}return r}decode(e,t=0){Ut(e);const r=this.makeDestinationObject();for(const s of this.fields)if(s.property!==void 0&&(r[s.property]=s.decode(e,t)),t+=s.getSpan(e,t),this.decodePrefixes&&e.length===t)break;return r}encode(e,t,r=0){const s=r;let o=0,i=0;for(const a of this.fields){let c=a.span;if(i=0<c?c:0,a.property!==void 0){const u=e[a.property];u!==void 0&&(i=a.encode(u,t,r),0>c&&(c=a.getSpan(t,r)))}o=r,r+=c}return o+i-s}fromArray(e){const t=this.makeDestinationObject();for(const r of this.fields)r.property!==void 0&&0<e.length&&(t[r.property]=e.shift());return t}layoutFor(e){if(typeof e!="string")throw new TypeError("property must be string");for(const t of this.fields)if(t.property===e)return t}offsetOf(e){if(typeof e!="string")throw new TypeError("property must be string");let t=0;for(const r of this.fields){if(r.property===e)return t;0>r.span?t=-1:0<=t&&(t+=r.span)}}}g.Structure=Ro;class Pn{constructor(e){this.property=e}decode(e,t){throw new Error("UnionDiscriminator is abstract")}encode(e,t,r){throw new Error("UnionDiscriminator is abstract")}}g.UnionDiscriminator=Pn;class vr extends Pn{constructor(e,t){if(!(e instanceof Pe&&e.isCount()))throw new TypeError("layout must be an unsigned integer ExternalLayout");super(t||e.property||"variant"),this.layout=e}decode(e,t){return this.layout.decode(e,t)}encode(e,t,r){return this.layout.encode(e,t,r)}}g.UnionLayoutDiscriminator=vr;class Cn extends se{constructor(e,t,r){let s;if(e instanceof He||e instanceof We)s=new vr(new Bn(e));else if(e instanceof Pe&&e.isCount())s=new vr(e);else if(e instanceof Pn)s=e;else throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");if(t===void 0&&(t=null),!(t===null||t instanceof se))throw new TypeError("defaultLayout must be null or a Layout");if(t!==null){if(0>t.span)throw new Error("defaultLayout must have constant span");t.property===void 0&&(t=t.replicate("content"))}let o=-1;t&&(o=t.span,0<=o&&(e instanceof He||e instanceof We)&&(o+=s.layout.span)),super(o,r),this.discriminator=s,this.usesPrefixDiscriminator=e instanceof He||e instanceof We,this.defaultLayout=t,this.registry={};let i=this.defaultGetSourceVariant.bind(this);this.getSourceVariant=function(a){return i(a)},this.configGetSourceVariant=function(a){i=a.bind(this)}}getSpan(e,t=0){if(0<=this.span)return this.span;const r=this.getVariant(e,t);if(!r)throw new Error("unable to determine span for unrecognized variant");return r.getSpan(e,t)}defaultGetSourceVariant(e){if(Object.prototype.hasOwnProperty.call(e,this.discriminator.property)){if(this.defaultLayout&&this.defaultLayout.property&&Object.prototype.hasOwnProperty.call(e,this.defaultLayout.property))return;const t=this.registry[e[this.discriminator.property]];if(t&&(!t.layout||t.property&&Object.prototype.hasOwnProperty.call(e,t.property)))return t}else for(const t in this.registry){const r=this.registry[t];if(r.property&&Object.prototype.hasOwnProperty.call(e,r.property))return r}throw new Error("unable to infer src variant")}decode(e,t=0){let r;const s=this.discriminator,o=s.decode(e,t),i=this.registry[o];if(i===void 0){const a=this.defaultLayout;let c=0;this.usesPrefixDiscriminator&&(c=s.layout.span),r=this.makeDestinationObject(),r[s.property]=o,r[a.property]=a.decode(e,t+c)}else r=i.decode(e,t);return r}encode(e,t,r=0){const s=this.getSourceVariant(e);if(s===void 0){const o=this.discriminator,i=this.defaultLayout;let a=0;return this.usesPrefixDiscriminator&&(a=o.layout.span),o.encode(e[o.property],t,r),a+i.encode(e[i.property],t,r+a)}return s.encode(e,t,r)}addVariant(e,t,r){const s=new Bo(this,e,t,r);return this.registry[e]=s,s}getVariant(e,t=0){let r;return e instanceof Uint8Array?r=this.discriminator.decode(e,t):r=e,this.registry[r]}}g.Union=Cn;class Bo extends se{constructor(e,t,r,s){if(!(e instanceof Cn))throw new TypeError("union must be a Union");if(!Number.isInteger(t)||0>t)throw new TypeError("variant must be a (non-negative) integer");if(typeof r=="string"&&s===void 0&&(s=r,r=null),r){if(!(r instanceof se))throw new TypeError("layout must be a Layout");if(e.defaultLayout!==null&&0<=r.span&&r.span>e.defaultLayout.span)throw new Error("variant span exceeds span of containing union");if(typeof s!="string")throw new TypeError("variant must have a String property")}let o=e.span;0>e.span&&(o=r?r.span:0,0<=o&&e.usesPrefixDiscriminator&&(o+=e.discriminator.layout.span)),super(o,s),this.union=e,this.variant=t,this.layout=r||null}getSpan(e,t=0){if(0<=this.span)return this.span;let r=0;this.union.usesPrefixDiscriminator&&(r=this.union.discriminator.layout.span);let s=0;return this.layout&&(s=this.layout.getSpan(e,t+r)),r+s}decode(e,t=0){const r=this.makeDestinationObject();if(this!==this.union.getVariant(e,t))throw new Error("variant mismatch");let s=0;return this.union.usesPrefixDiscriminator&&(s=this.union.discriminator.layout.span),this.layout?r[this.property]=this.layout.decode(e,t+s):this.property?r[this.property]=!0:this.union.usesPrefixDiscriminator&&(r[this.union.discriminator.property]=this.variant),r}encode(e,t,r=0){let s=0;if(this.union.usesPrefixDiscriminator&&(s=this.union.discriminator.layout.span),this.layout&&!Object.prototype.hasOwnProperty.call(e,this.property))throw new TypeError("variant lacks property "+this.property);this.union.discriminator.encode(this.variant,t,r);let o=s;if(this.layout&&(this.layout.encode(e[this.property],t,r+s),o+=this.layout.getSpan(t,r+s),0<=this.union.span&&o>this.union.span))throw new Error("encoded variant overruns containing union");return o}fromArray(e){if(this.layout)return this.layout.fromArray(e)}}g.VariantLayout=Bo;function It(n){return 0>n&&(n+=4294967296),n}class On extends se{constructor(e,t,r){if(!(e instanceof He||e instanceof We))throw new TypeError("word must be a UInt or UIntBE layout");if(typeof t=="string"&&r===void 0&&(r=t,t=!1),4<e.span)throw new RangeError("word cannot exceed 32 bits");super(e.span,r),this.word=e,this.msb=!!t,this.fields=[];let s=0;this._packedSetValue=function(o){return s=It(o),this},this._packedGetValue=function(){return s}}decode(e,t=0){const r=this.makeDestinationObject(),s=this.word.decode(e,t);this._packedSetValue(s);for(const o of this.fields)o.property!==void 0&&(r[o.property]=o.decode(e));return r}encode(e,t,r=0){const s=this.word.decode(t,r);this._packedSetValue(s);for(const o of this.fields)if(o.property!==void 0){const i=e[o.property];i!==void 0&&o.encode(i)}return this.word.encode(this._packedGetValue(),t,r)}addField(e,t){const r=new Tn(this,e,t);return this.fields.push(r),r}addBoolean(e){const t=new Po(this,e);return this.fields.push(t),t}fieldFor(e){if(typeof e!="string")throw new TypeError("property must be string");for(const t of this.fields)if(t.property===e)return t}}g.BitStructure=On;class Tn{constructor(e,t,r){if(!(e instanceof On))throw new TypeError("container must be a BitStructure");if(!Number.isInteger(t)||0>=t)throw new TypeError("bits must be positive integer");const s=8*e.span,o=e.fields.reduce((i,a)=>i+a.bits,0);if(t+o>s)throw new Error("bits too long for span remainder ("+(s-o)+" of "+s+" remain)");this.container=e,this.bits=t,this.valueMask=(1<<t)-1,t===32&&(this.valueMask=4294967295),this.start=o,this.container.msb&&(this.start=s-o-t),this.wordMask=It(this.valueMask<<this.start),this.property=r}decode(e,t){const r=this.container._packedGetValue();return It(r&this.wordMask)>>>this.start}encode(e){if(typeof e!="number"||!Number.isInteger(e)||e!==It(e&this.valueMask))throw new TypeError(Rn("BitField.encode",this)+" value must be integer not exceeding "+this.valueMask);const t=this.container._packedGetValue(),r=It(e<<this.start);this.container._packedSetValue(It(t&~this.wordMask)|r)}}g.BitField=Tn;let Po=class extends Tn{constructor(e,t){super(e,1,t)}decode(e,t){return!!super.decode(e,t)}encode(e){typeof e=="boolean"&&(e=+e),super.encode(e)}};g.Boolean=Po;class Co extends se{constructor(e,t){if(!(e instanceof Pe&&e.isCount()||Number.isInteger(e)&&0<=e))throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");let r=-1;e instanceof Pe||(r=e),super(r,t),this.length=e}getSpan(e,t){let r=this.span;return 0>r&&(r=this.length.decode(e,t)),r}decode(e,t=0){let r=this.span;return 0>r&&(r=this.length.decode(e,t)),re(e).slice(t,t+r)}encode(e,t,r){let s=this.length;if(this.length instanceof Pe&&(s=e.length),!(e instanceof Uint8Array&&s===e.length))throw new TypeError(Rn("Blob.encode",this)+" requires (length "+s+") Uint8Array as src");if(r+s>t.length)throw new RangeError("encoding overruns Uint8Array");const o=re(e);return re(t).write(o.toString("hex"),r,s,"hex"),this.length instanceof Pe&&this.length.encode(s,t,r),s}}g.Blob=Co;class Oo extends se{constructor(e){super(-1,e)}getSpan(e,t=0){Ut(e);let r=t;for(;r<e.length&&e[r]!==0;)r+=1;return 1+r-t}decode(e,t=0){const r=this.getSpan(e,t);return re(e).slice(t,t+r-1).toString("utf-8")}encode(e,t,r=0){typeof e!="string"&&(e=String(e));const s=In.Buffer.from(e,"utf8"),o=s.length;if(r+o>t.length)throw new RangeError("encoding overruns Buffer");const i=re(t);return s.copy(i,r),i[r+o]=0,o+1}}g.CString=Oo;class To extends se{constructor(e,t){if(typeof e=="string"&&t===void 0&&(t=e,e=void 0),e===void 0)e=-1;else if(!Number.isInteger(e))throw new TypeError("maxSpan must be an integer");super(-1,t),this.maxSpan=e}getSpan(e,t=0){return Ut(e),e.length-t}decode(e,t=0){const r=this.getSpan(e,t);if(0<=this.maxSpan&&this.maxSpan<r)throw new RangeError("text length exceeds maxSpan");return re(e).slice(t,t+r).toString("utf-8")}encode(e,t,r=0){typeof e!="string"&&(e=String(e));const s=In.Buffer.from(e,"utf8"),o=s.length;if(0<=this.maxSpan&&this.maxSpan<o)throw new RangeError("text length exceeds maxSpan");if(r+o>t.length)throw new RangeError("encoding overruns Buffer");return s.copy(re(t),r),o}}g.UTF8=To;class Lo extends se{constructor(e,t){super(0,t),this.value=e}decode(e,t){return this.value}encode(e,t,r){return 0}}g.Constant=Lo;g.greedy=(n,e)=>new wo(n,e);var _t=g.offset=(n,e,t)=>new Bn(n,e,t),ne=g.u8=n=>new He(1,n),je=g.u16=n=>new He(2,n);g.u24=n=>new He(3,n);var j=g.u32=n=>new He(4,n);g.u40=n=>new He(5,n);g.u48=n=>new He(6,n);var be=g.nu64=n=>new bo(n);g.u16be=n=>new We(2,n);g.u24be=n=>new We(3,n);g.u32be=n=>new We(4,n);g.u40be=n=>new We(5,n);g.u48be=n=>new We(6,n);g.nu64be=n=>new vo(n);g.s8=n=>new Et(1,n);g.s16=n=>new Et(2,n);g.s24=n=>new Et(3,n);g.s32=n=>new Et(4,n);g.s40=n=>new Et(5,n);g.s48=n=>new Et(6,n);var Me=g.ns64=n=>new So(n);g.s16be=n=>new Ft(2,n);g.s24be=n=>new Ft(3,n);g.s32be=n=>new Ft(4,n);g.s40be=n=>new Ft(5,n);g.s48be=n=>new Ft(6,n);g.ns64be=n=>new _o(n);g.f32=n=>new Eo(n);g.f32be=n=>new xo(n);g.f64=n=>new ko(n);g.f64be=n=>new Ao(n);var K=g.struct=(n,e,t)=>new Ro(n,e,t);g.bits=(n,e,t)=>new On(n,e,t);var Ie=g.seq=(n,e,t)=>new Io(n,e,t);g.union=(n,e,t)=>new Cn(n,e,t);g.unionLayoutDiscriminator=(n,e)=>new vr(n,e);var le=g.blob=(n,e)=>new Co(n,e);g.cstr=n=>new Oo(n);g.utf8=(n,e)=>new To(n,e);g.constant=(n,e)=>new Lo(n,e);var rr={};Object.defineProperty(rr,"__esModule",{value:!0});function Xa(n){{const e=D.from(n);e.reverse();const t=e.toString("hex");return t.length===0?BigInt(0):BigInt(`0x${t}`)}}var Ya=rr.toBigIntLE=Xa;function Qa(n){{const e=n.toString("hex");return e.length===0?BigInt(0):BigInt(`0x${e}`)}}rr.toBigIntBE=Qa;function ec(n,e){{const t=n.toString(16),r=D.from(t.padStart(e*2,"0").slice(0,e*2),"hex");return r.reverse(),r}}var tc=rr.toBufferLE=ec;function rc(n,e){{const t=n.toString(16);return D.from(t.padStart(e*2,"0").slice(0,e*2),"hex")}}rr.toBufferBE=rc;class nc extends TypeError{constructor(e,t){let r;const{message:s,...o}=e,{path:i}=e,a=i.length===0?s:"At path: "+i.join(".")+" -- "+s;super(a),Object.assign(this,o),this.name=this.constructor.name,this.failures=()=>{var c;return(c=r)!=null?c:r=[e,...t()]}}}function sc(n){return yt(n)&&typeof n[Symbol.iterator]=="function"}function yt(n){return typeof n=="object"&&n!=null}function Ve(n){return typeof n=="string"?JSON.stringify(n):""+n}function oc(n){const{done:e,value:t}=n.next();return e?void 0:t}function ic(n,e,t,r){if(n===!0)return;n===!1?n={}:typeof n=="string"&&(n={message:n});const{path:s,branch:o}=e,{type:i}=t,{refinement:a,message:c="Expected a value of type `"+i+"`"+(a?" with refinement `"+a+"`":"")+", but received: `"+Ve(r)+"`"}=n;return{value:r,type:i,refinement:a,key:s[s.length-1],path:s,branch:o,...n,message:c}}function*bs(n,e,t,r){sc(n)||(n=[n]);for(const s of n){const o=ic(s,e,t,r);o&&(yield o)}}function*Ln(n,e,t={}){const{path:r=[],branch:s=[n],coerce:o=!1,mask:i=!1}=t,a={path:r,branch:s};if(o&&(n=e.coercer(n,a),i&&e.type!=="type"&&yt(e.schema)&&yt(n)&&!Array.isArray(n)))for(const u in n)e.schema[u]===void 0&&delete n[u];let c=!0;for(const u of e.validator(n,a))c=!1,yield[u,void 0];for(let[u,l,w]of e.entries(n,a)){const y=Ln(l,w,{path:u===void 0?r:[...r,u],branch:u===void 0?s:[...s,l],coerce:o,mask:i});for(const h of y)h[0]?(c=!1,yield[h[0],void 0]):o&&(l=h[1],u===void 0?n=l:n instanceof Map?n.set(u,l):n instanceof Set?n.add(l):yt(n)&&(n[u]=l))}if(c)for(const u of e.refiner(n,a))c=!1,yield[u,void 0];c&&(yield[void 0,n])}let ot=class{constructor(e){const{type:t,schema:r,validator:s,refiner:o,coercer:i=c=>c,entries:a=function*(){}}=e;this.type=t,this.schema=r,this.entries=a,this.coercer=i,s?this.validator=(c,u)=>{const l=s(c,u);return bs(l,u,this,c)}:this.validator=()=>[],o?this.refiner=(c,u)=>{const l=o(c,u);return bs(l,u,this,c)}:this.refiner=()=>[]}assert(e){return ac(e,this)}create(e){return O(e,this)}is(e){return No(e,this)}mask(e){return cc(e,this)}validate(e,t={}){return nr(e,this,t)}};function ac(n,e){const t=nr(n,e);if(t[0])throw t[0]}function O(n,e){const t=nr(n,e,{coerce:!0});if(t[0])throw t[0];return t[1]}function cc(n,e){const t=nr(n,e,{coerce:!0,mask:!0});if(t[0])throw t[0];return t[1]}function No(n,e){return!nr(n,e)[0]}function nr(n,e,t={}){const r=Ln(n,e,t),s=oc(r);return s[0]?[new nc(s[0],function*(){for(const i of r)i[0]&&(yield i[0])}),void 0]:[void 0,s[1]]}function xt(n,e){return new ot({type:n,schema:null,validator:e})}function uc(){return xt("any",()=>!0)}function L(n){return new ot({type:"array",schema:n,*entries(e){if(n&&Array.isArray(e))for(const[t,r]of e.entries())yield[t,r,n]},coercer(e){return Array.isArray(e)?e.slice():e},validator(e){return Array.isArray(e)||"Expected an array value, but received: "+Ve(e)}})}function at(){return xt("boolean",n=>typeof n=="boolean")}function Nn(n){return xt("instance",e=>e instanceof n||"Expected a `"+n.name+"` instance, but received: "+Ve(e))}function he(n){const e=Ve(n),t=typeof n;return new ot({type:"literal",schema:t==="string"||t==="number"||t==="boolean"?n:null,validator(r){return r===n||"Expected the literal `"+e+"`, but received: "+Ve(r)}})}function lc(){return xt("never",()=>!1)}function N(n){return new ot({...n,validator:(e,t)=>e===null||n.validator(e,t),refiner:(e,t)=>e===null||n.refiner(e,t)})}function f(){return xt("number",n=>typeof n=="number"&&!isNaN(n)||"Expected a number, but received: "+Ve(n))}function $(n){return new ot({...n,validator:(e,t)=>e===void 0||n.validator(e,t),refiner:(e,t)=>e===void 0||n.refiner(e,t)})}function Mo(n,e){return new ot({type:"record",schema:null,*entries(t){if(yt(t))for(const r in t){const s=t[r];yield[r,r,n],yield[r,s,e]}},validator(t){return yt(t)||"Expected an object, but received: "+Ve(t)}})}function P(){return xt("string",n=>typeof n=="string"||"Expected a string, but received: "+Ve(n))}function Mn(n){const e=lc();return new ot({type:"tuple",schema:null,*entries(t){if(Array.isArray(t)){const r=Math.max(n.length,t.length);for(let s=0;s<r;s++)yield[s,t[s],n[s]||e]}},validator(t){return Array.isArray(t)||"Expected an array, but received: "+Ve(t)}})}function k(n){const e=Object.keys(n);return new ot({type:"type",schema:n,*entries(t){if(yt(t))for(const r of e)yield[r,t[r],n[r]]},validator(t){return yt(t)||"Expected an object, but received: "+Ve(t)}})}function Oe(n){const e=n.map(t=>t.type).join(" | ");return new ot({type:"union",schema:null,validator(t,r){const s=[];for(const o of n){const[...i]=Ln(t,o,r),[a]=i;if(a[0])for(const[c]of i)c&&s.push(c);else return[]}return["Expected the value to satisfy a union of `"+e+"`, but received: "+Ve(t),...s]}})}function sr(){return xt("unknown",()=>!0)}function or(n,e,t){return new ot({...n,coercer:(r,s)=>No(r,e)?n.coercer(t(r,s),s):n.coercer(r,s)})}var lr,dc=new Uint8Array(16);function Uo(){if(!lr&&(lr=typeof crypto<"u"&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto)||typeof msCrypto<"u"&&typeof msCrypto.getRandomValues=="function"&&msCrypto.getRandomValues.bind(msCrypto),!lr))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return lr(dc)}const fc=/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;function Cr(n){return typeof n=="string"&&fc.test(n)}var we=[];for(var Wr=0;Wr<256;++Wr)we.push((Wr+256).toString(16).substr(1));function Or(n){var e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:0,t=(we[n[e+0]]+we[n[e+1]]+we[n[e+2]]+we[n[e+3]]+"-"+we[n[e+4]]+we[n[e+5]]+"-"+we[n[e+6]]+we[n[e+7]]+"-"+we[n[e+8]]+we[n[e+9]]+"-"+we[n[e+10]]+we[n[e+11]]+we[n[e+12]]+we[n[e+13]]+we[n[e+14]]+we[n[e+15]]).toLowerCase();if(!Cr(t))throw TypeError("Stringified UUID is invalid");return t}var vs,Vr,Jr=0,Zr=0;function hc(n,e,t){var r=e&&t||0,s=e||new Array(16);n=n||{};var o=n.node||vs,i=n.clockseq!==void 0?n.clockseq:Vr;if(o==null||i==null){var a=n.random||(n.rng||Uo)();o==null&&(o=vs=[a[0]|1,a[1],a[2],a[3],a[4],a[5]]),i==null&&(i=Vr=(a[6]<<8|a[7])&16383)}var c=n.msecs!==void 0?n.msecs:Date.now(),u=n.nsecs!==void 0?n.nsecs:Zr+1,l=c-Jr+(u-Zr)/1e4;if(l<0&&n.clockseq===void 0&&(i=i+1&16383),(l<0||c>Jr)&&n.nsecs===void 0&&(u=0),u>=1e4)throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");Jr=c,Zr=u,Vr=i,c+=122192928e5;var w=((c&268435455)*1e4+u)%4294967296;s[r++]=w>>>24&255,s[r++]=w>>>16&255,s[r++]=w>>>8&255,s[r++]=w&255;var y=c/4294967296*1e4&268435455;s[r++]=y>>>8&255,s[r++]=y&255,s[r++]=y>>>24&15|16,s[r++]=y>>>16&255,s[r++]=i>>>8|128,s[r++]=i&255;for(var h=0;h<6;++h)s[r+h]=o[h];return e||Or(s)}function Fo(n){if(!Cr(n))throw TypeError("Invalid UUID");var e,t=new Uint8Array(16);return t[0]=(e=parseInt(n.slice(0,8),16))>>>24,t[1]=e>>>16&255,t[2]=e>>>8&255,t[3]=e&255,t[4]=(e=parseInt(n.slice(9,13),16))>>>8,t[5]=e&255,t[6]=(e=parseInt(n.slice(14,18),16))>>>8,t[7]=e&255,t[8]=(e=parseInt(n.slice(19,23),16))>>>8,t[9]=e&255,t[10]=(e=parseInt(n.slice(24,36),16))/1099511627776&255,t[11]=e/4294967296&255,t[12]=e>>>24&255,t[13]=e>>>16&255,t[14]=e>>>8&255,t[15]=e&255,t}function pc(n){n=unescape(encodeURIComponent(n));for(var e=[],t=0;t<n.length;++t)e.push(n.charCodeAt(t));return e}var gc="6ba7b810-9dad-11d1-80b4-00c04fd430c8",yc="6ba7b811-9dad-11d1-80b4-00c04fd430c8";function qo(n,e,t){function r(s,o,i,a){if(typeof s=="string"&&(s=pc(s)),typeof o=="string"&&(o=Fo(o)),o.length!==16)throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");var c=new Uint8Array(16+s.length);if(c.set(o),c.set(s,o.length),c=t(c),c[6]=c[6]&15|e,c[8]=c[8]&63|128,i){a=a||0;for(var u=0;u<16;++u)i[a+u]=c[u];return i}return Or(c)}try{r.name=n}catch{}return r.DNS=gc,r.URL=yc,r}function mc(n){if(typeof n=="string"){var e=unescape(encodeURIComponent(n));n=new Uint8Array(e.length);for(var t=0;t<e.length;++t)n[t]=e.charCodeAt(t)}return wc(bc(vc(n),n.length*8))}function wc(n){for(var e=[],t=n.length*32,r="0123456789abcdef",s=0;s<t;s+=8){var o=n[s>>5]>>>s%32&255,i=parseInt(r.charAt(o>>>4&15)+r.charAt(o&15),16);e.push(i)}return e}function Do(n){return(n+64>>>9<<4)+14+1}function bc(n,e){n[e>>5]|=128<<e%32,n[Do(e)-1]=e;for(var t=1732584193,r=-271733879,s=-1732584194,o=271733878,i=0;i<n.length;i+=16){var a=t,c=r,u=s,l=o;t=Ee(t,r,s,o,n[i],7,-680876936),o=Ee(o,t,r,s,n[i+1],12,-389564586),s=Ee(s,o,t,r,n[i+2],17,606105819),r=Ee(r,s,o,t,n[i+3],22,-1044525330),t=Ee(t,r,s,o,n[i+4],7,-176418897),o=Ee(o,t,r,s,n[i+5],12,1200080426),s=Ee(s,o,t,r,n[i+6],17,-1473231341),r=Ee(r,s,o,t,n[i+7],22,-45705983),t=Ee(t,r,s,o,n[i+8],7,1770035416),o=Ee(o,t,r,s,n[i+9],12,-1958414417),s=Ee(s,o,t,r,n[i+10],17,-42063),r=Ee(r,s,o,t,n[i+11],22,-1990404162),t=Ee(t,r,s,o,n[i+12],7,1804603682),o=Ee(o,t,r,s,n[i+13],12,-40341101),s=Ee(s,o,t,r,n[i+14],17,-1502002290),r=Ee(r,s,o,t,n[i+15],22,1236535329),t=xe(t,r,s,o,n[i+1],5,-165796510),o=xe(o,t,r,s,n[i+6],9,-1069501632),s=xe(s,o,t,r,n[i+11],14,643717713),r=xe(r,s,o,t,n[i],20,-373897302),t=xe(t,r,s,o,n[i+5],5,-701558691),o=xe(o,t,r,s,n[i+10],9,38016083),s=xe(s,o,t,r,n[i+15],14,-660478335),r=xe(r,s,o,t,n[i+4],20,-405537848),t=xe(t,r,s,o,n[i+9],5,568446438),o=xe(o,t,r,s,n[i+14],9,-1019803690),s=xe(s,o,t,r,n[i+3],14,-187363961),r=xe(r,s,o,t,n[i+8],20,1163531501),t=xe(t,r,s,o,n[i+13],5,-1444681467),o=xe(o,t,r,s,n[i+2],9,-51403784),s=xe(s,o,t,r,n[i+7],14,1735328473),r=xe(r,s,o,t,n[i+12],20,-1926607734),t=ke(t,r,s,o,n[i+5],4,-378558),o=ke(o,t,r,s,n[i+8],11,-2022574463),s=ke(s,o,t,r,n[i+11],16,1839030562),r=ke(r,s,o,t,n[i+14],23,-35309556),t=ke(t,r,s,o,n[i+1],4,-1530992060),o=ke(o,t,r,s,n[i+4],11,1272893353),s=ke(s,o,t,r,n[i+7],16,-155497632),r=ke(r,s,o,t,n[i+10],23,-1094730640),t=ke(t,r,s,o,n[i+13],4,681279174),o=ke(o,t,r,s,n[i],11,-358537222),s=ke(s,o,t,r,n[i+3],16,-722521979),r=ke(r,s,o,t,n[i+6],23,76029189),t=ke(t,r,s,o,n[i+9],4,-640364487),o=ke(o,t,r,s,n[i+12],11,-421815835),s=ke(s,o,t,r,n[i+15],16,530742520),r=ke(r,s,o,t,n[i+2],23,-995338651),t=Ae(t,r,s,o,n[i],6,-198630844),o=Ae(o,t,r,s,n[i+7],10,1126891415),s=Ae(s,o,t,r,n[i+14],15,-1416354905),r=Ae(r,s,o,t,n[i+5],21,-57434055),t=Ae(t,r,s,o,n[i+12],6,1700485571),o=Ae(o,t,r,s,n[i+3],10,-1894986606),s=Ae(s,o,t,r,n[i+10],15,-1051523),r=Ae(r,s,o,t,n[i+1],21,-2054922799),t=Ae(t,r,s,o,n[i+8],6,1873313359),o=Ae(o,t,r,s,n[i+15],10,-30611744),s=Ae(s,o,t,r,n[i+6],15,-1560198380),r=Ae(r,s,o,t,n[i+13],21,1309151649),t=Ae(t,r,s,o,n[i+4],6,-145523070),o=Ae(o,t,r,s,n[i+11],10,-1120210379),s=Ae(s,o,t,r,n[i+2],15,718787259),r=Ae(r,s,o,t,n[i+9],21,-343485551),t=gt(t,a),r=gt(r,c),s=gt(s,u),o=gt(o,l)}return[t,r,s,o]}function vc(n){if(n.length===0)return[];for(var e=n.length*8,t=new Uint32Array(Do(e)),r=0;r<e;r+=8)t[r>>5]|=(n[r/8]&255)<<r%32;return t}function gt(n,e){var t=(n&65535)+(e&65535),r=(n>>16)+(e>>16)+(t>>16);return r<<16|t&65535}function Sc(n,e){return n<<e|n>>>32-e}function Tr(n,e,t,r,s,o){return gt(Sc(gt(gt(e,n),gt(r,o)),s),t)}function Ee(n,e,t,r,s,o,i){return Tr(e&t|~e&r,n,e,s,o,i)}function xe(n,e,t,r,s,o,i){return Tr(e&r|t&~r,n,e,s,o,i)}function ke(n,e,t,r,s,o,i){return Tr(e^t^r,n,e,s,o,i)}function Ae(n,e,t,r,s,o,i){return Tr(t^(e|~r),n,e,s,o,i)}var _c=qo("v3",48,mc);const Ec=_c;function xc(n,e,t){n=n||{};var r=n.random||(n.rng||Uo)();if(r[6]=r[6]&15|64,r[8]=r[8]&63|128,e){t=t||0;for(var s=0;s<16;++s)e[t+s]=r[s];return e}return Or(r)}function kc(n,e,t,r){switch(n){case 0:return e&t^~e&r;case 1:return e^t^r;case 2:return e&t^e&r^t&r;case 3:return e^t^r}}function Xr(n,e){return n<<e|n>>>32-e}function Ac(n){var e=[1518500249,1859775393,2400959708,3395469782],t=[1732584193,4023233417,2562383102,271733878,3285377520];if(typeof n=="string"){var r=unescape(encodeURIComponent(n));n=[];for(var s=0;s<r.length;++s)n.push(r.charCodeAt(s))}else Array.isArray(n)||(n=Array.prototype.slice.call(n));n.push(128);for(var o=n.length/4+2,i=Math.ceil(o/16),a=new Array(i),c=0;c<i;++c){for(var u=new Uint32Array(16),l=0;l<16;++l)u[l]=n[c*64+l*4]<<24|n[c*64+l*4+1]<<16|n[c*64+l*4+2]<<8|n[c*64+l*4+3];a[c]=u}a[i-1][14]=(n.length-1)*8/Math.pow(2,32),a[i-1][14]=Math.floor(a[i-1][14]),a[i-1][15]=(n.length-1)*8&4294967295;for(var w=0;w<i;++w){for(var y=new Uint32Array(80),h=0;h<16;++h)y[h]=a[w][h];for(var m=16;m<80;++m)y[m]=Xr(y[m-3]^y[m-8]^y[m-14]^y[m-16],1);for(var p=t[0],b=t[1],_=t[2],E=t[3],d=t[4],R=0;R<80;++R){var v=Math.floor(R/20),M=Xr(p,5)+kc(v,b,_,E)+d+e[v]+y[R]>>>0;d=E,E=_,_=Xr(b,30)>>>0,b=p,p=M}t[0]=t[0]+p>>>0,t[1]=t[1]+b>>>0,t[2]=t[2]+_>>>0,t[3]=t[3]+E>>>0,t[4]=t[4]+d>>>0}return[t[0]>>24&255,t[0]>>16&255,t[0]>>8&255,t[0]&255,t[1]>>24&255,t[1]>>16&255,t[1]>>8&255,t[1]&255,t[2]>>24&255,t[2]>>16&255,t[2]>>8&255,t[2]&255,t[3]>>24&255,t[3]>>16&255,t[3]>>8&255,t[3]&255,t[4]>>24&255,t[4]>>16&255,t[4]>>8&255,t[4]&255]}var Ic=qo("v5",80,Ac);const Rc=Ic,Bc="00000000-0000-0000-0000-000000000000";function Pc(n){if(!Cr(n))throw TypeError("Invalid UUID");return parseInt(n.substr(14,1),16)}const Cc=Object.freeze(Object.defineProperty({__proto__:null,NIL:Bc,parse:Fo,stringify:Or,v1:hc,v3:Ec,v4:xc,v5:Rc,validate:Cr,version:Pc},Symbol.toStringTag,{value:"Module"})),Ko=Qs(Cc),Oc=Ko.v4,Tc=function(n,e,t,r){if(typeof n!="string")throw new TypeError(n+" must be a string");r=r||{};const s=typeof r.version=="number"?r.version:2;if(s!==1&&s!==2)throw new TypeError(s+" must be 1 or 2");const o={method:n};if(s===2&&(o.jsonrpc="2.0"),e){if(typeof e!="object"&&!Array.isArray(e))throw new TypeError(e+" must be an object, array or omitted");o.params=e}if(typeof t>"u"){const i=typeof r.generator=="function"?r.generator:function(){return Oc()};o.id=i(o,r)}else s===2&&t===null?r.notificationIdNull&&(o.id=null):o.id=t;return o};var Lc=Tc;const Nc=Ko.v4,Mc=Lc,Jt=function(n,e){if(!(this instanceof Jt))return new Jt(n,e);e||(e={}),this.options={reviver:typeof e.reviver<"u"?e.reviver:null,replacer:typeof e.replacer<"u"?e.replacer:null,generator:typeof e.generator<"u"?e.generator:function(){return Nc()},version:typeof e.version<"u"?e.version:2,notificationIdNull:typeof e.notificationIdNull=="boolean"?e.notificationIdNull:!1},this.callServer=n};var Uc=Jt;Jt.prototype.request=function(n,e,t,r){const s=this;let o=null;const i=Array.isArray(n)&&typeof e=="function";if(this.options.version===1&&i)throw new TypeError("JSON-RPC 1.0 does not support batching");if(i||!i&&n&&typeof n=="object"&&typeof e=="function")r=e,o=n;else{typeof t=="function"&&(r=t,t=void 0);const u=typeof r=="function";try{o=Mc(n,e,t,{generator:this.options.generator,version:this.options.version,notificationIdNull:this.options.notificationIdNull})}catch(l){if(u)return r(l);throw l}if(!u)return o}let c;try{c=JSON.stringify(o,this.options.replacer)}catch(u){return r(u)}return this.callServer(c,function(u,l){s._parseResponse(u,l,r)}),o};Jt.prototype._parseResponse=function(n,e,t){if(n){t(n);return}if(!e)return t();let r;try{r=JSON.parse(e,this.options.reviver)}catch(s){return t(s)}if(t.length===3)if(Array.isArray(r)){const s=function(i){return typeof i.error<"u"},o=function(i){return!s(i)};return t(null,r.filter(s),r.filter(o))}else return t(null,r.error,r.result);t(null,r)};const Fc=xr(Uc);var zo={},jo={exports:{}};(function(n){function e(t){return t&&t.__esModule?t:{default:t}}n.exports=e,n.exports.__esModule=!0,n.exports.default=n.exports})(jo);var Ho=jo.exports,Yr={exports:{}},Ss;function $o(){return Ss||(Ss=1,function(n){function e(t,r){if(!(t instanceof r))throw new TypeError("Cannot call a class as a function")}n.exports=e,n.exports.__esModule=!0,n.exports.default=n.exports}(Yr)),Yr.exports}var Qr={exports:{}},en={exports:{}},tn={exports:{}},_s;function qc(){return _s||(_s=1,function(n){var e=Qt().default;function t(r,s){if(e(r)!=="object"||r===null)return r;var o=r[Symbol.toPrimitive];if(o!==void 0){var i=o.call(r,s||"default");if(e(i)!=="object")return i;throw new TypeError("@@toPrimitive must return a primitive value.")}return(s==="string"?String:Number)(r)}n.exports=t,n.exports.__esModule=!0,n.exports.default=n.exports}(tn)),tn.exports}var Es;function Dc(){return Es||(Es=1,function(n){var e=Qt().default,t=qc();function r(s){var o=t(s,"string");return e(o)==="symbol"?o:String(o)}n.exports=r,n.exports.__esModule=!0,n.exports.default=n.exports}(en)),en.exports}var xs;function Go(){return xs||(xs=1,function(n){var e=Dc();function t(s,o){for(var i=0;i<o.length;i++){var a=o[i];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(s,e(a.key),a)}}function r(s,o,i){return o&&t(s.prototype,o),i&&t(s,i),Object.defineProperty(s,"prototype",{writable:!1}),s}n.exports=r,n.exports.__esModule=!0,n.exports.default=n.exports}(Qr)),Qr.exports}var rn={exports:{}},nn={exports:{}},ks;function Kc(){return ks||(ks=1,function(n){function e(t,r){return n.exports=e=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(o,i){return o.__proto__=i,o},n.exports.__esModule=!0,n.exports.default=n.exports,e(t,r)}n.exports=e,n.exports.__esModule=!0,n.exports.default=n.exports}(nn)),nn.exports}var As;function Wo(){return As||(As=1,function(n){var e=Kc();function t(r,s){if(typeof s!="function"&&s!==null)throw new TypeError("Super expression must either be null or a function");r.prototype=Object.create(s&&s.prototype,{constructor:{value:r,writable:!0,configurable:!0}}),Object.defineProperty(r,"prototype",{writable:!1}),s&&e(r,s)}n.exports=t,n.exports.__esModule=!0,n.exports.default=n.exports}(rn)),rn.exports}var sn={exports:{}},on={exports:{}},Is;function zc(){return Is||(Is=1,function(n){function e(t){if(t===void 0)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}n.exports=e,n.exports.__esModule=!0,n.exports.default=n.exports}(on)),on.exports}var Rs;function Vo(){return Rs||(Rs=1,function(n){var e=Qt().default,t=zc();function r(s,o){if(o&&(e(o)==="object"||typeof o=="function"))return o;if(o!==void 0)throw new TypeError("Derived constructors may only return object or undefined");return t(s)}n.exports=r,n.exports.__esModule=!0,n.exports.default=n.exports}(sn)),sn.exports}var an={exports:{}},Bs;function Jo(){return Bs||(Bs=1,function(n){function e(t){return n.exports=e=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(s){return s.__proto__||Object.getPrototypeOf(s)},n.exports.__esModule=!0,n.exports.default=n.exports,e(t)}n.exports=e,n.exports.__esModule=!0,n.exports.default=n.exports}(an)),an.exports}(function(n){var e=Ho;Object.defineProperty(n,"__esModule",{value:!0}),n.default=void 0;var t=e(Ji()),r=e(Wi()),s=e(Qt()),o=e($o()),i=e(Go()),a=e(Wo()),c=e(Vo()),u=e(Jo()),l=eo;function w(p){var b=y();return function(){var E=(0,u.default)(p),d;if(b){var R=(0,u.default)(this).constructor;d=Reflect.construct(E,arguments,R)}else d=E.apply(this,arguments);return(0,c.default)(this,d)}}function y(){if(typeof Reflect>"u"||!Reflect.construct||Reflect.construct.sham)return!1;if(typeof Proxy=="function")return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){})),!0}catch{return!1}}var h=function(p,b){var _={};for(var E in p)Object.prototype.hasOwnProperty.call(p,E)&&b.indexOf(E)<0&&(_[E]=p[E]);if(p!=null&&typeof Object.getOwnPropertySymbols=="function")for(var d=0,E=Object.getOwnPropertySymbols(p);d<E.length;d++)b.indexOf(E[d])<0&&Object.prototype.propertyIsEnumerable.call(p,E[d])&&(_[E[d]]=p[E[d]]);return _},m=function(p){(0,a.default)(_,p);var b=w(_);function _(E){var d,R=arguments.length>1&&arguments[1]!==void 0?arguments[1]:"ws://localhost:8080",v=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{},M=arguments.length>3?arguments[3]:void 0;(0,o.default)(this,_);var T=v.autoconnect,F=T===void 0?!0:T,X=v.reconnect,ce=X===void 0?!0:X,ue=v.reconnect_interval,pe=ue===void 0?1e3:ue,oe=v.max_reconnects,Je=oe===void 0?5:oe,C=h(v,["autoconnect","reconnect","reconnect_interval","max_reconnects"]);return d=b.call(this),d.webSocketFactory=E,d.queue={},d.rpc_id=0,d.address=R,d.autoconnect=F,d.ready=!1,d.reconnect=ce,d.reconnect_timer_id=void 0,d.reconnect_interval=pe,d.max_reconnects=Je,d.rest_options=C,d.current_reconnects=0,d.generate_request_id=M||function(){return++d.rpc_id},d.autoconnect&&d._connect(d.address,Object.assign({autoconnect:d.autoconnect,reconnect:d.reconnect,reconnect_interval:d.reconnect_interval,max_reconnects:d.max_reconnects},d.rest_options)),d}return(0,i.default)(_,[{key:"connect",value:function(){this.socket||this._connect(this.address,Object.assign({autoconnect:this.autoconnect,reconnect:this.reconnect,reconnect_interval:this.reconnect_interval,max_reconnects:this.max_reconnects},this.rest_options))}},{key:"call",value:function(d,R,v,M){var T=this;return!M&&(0,s.default)(v)==="object"&&(M=v,v=null),new Promise(function(F,X){if(!T.ready)return X(new Error("socket not ready"));var ce=T.generate_request_id(d,R),ue={jsonrpc:"2.0",method:d,params:R||null,id:ce};T.socket.send(JSON.stringify(ue),M,function(pe){if(pe)return X(pe);T.queue[ce]={promise:[F,X]},v&&(T.queue[ce].timeout=setTimeout(function(){delete T.queue[ce],X(new Error("reply timeout"))},v))})})}},{key:"login",value:function(){var E=(0,r.default)(t.default.mark(function R(v){var M;return t.default.wrap(function(F){for(;;)switch(F.prev=F.next){case 0:return F.next=2,this.call("rpc.login",v);case 2:if(M=F.sent,M){F.next=5;break}throw new Error("authentication failed");case 5:return F.abrupt("return",M);case 6:case"end":return F.stop()}},R,this)}));function d(R){return E.apply(this,arguments)}return d}()},{key:"listMethods",value:function(){var E=(0,r.default)(t.default.mark(function R(){return t.default.wrap(function(M){for(;;)switch(M.prev=M.next){case 0:return M.next=2,this.call("__listMethods");case 2:return M.abrupt("return",M.sent);case 3:case"end":return M.stop()}},R,this)}));function d(){return E.apply(this,arguments)}return d}()},{key:"notify",value:function(d,R){var v=this;return new Promise(function(M,T){if(!v.ready)return T(new Error("socket not ready"));var F={jsonrpc:"2.0",method:d,params:R||null};v.socket.send(JSON.stringify(F),function(X){if(X)return T(X);M()})})}},{key:"subscribe",value:function(){var E=(0,r.default)(t.default.mark(function R(v){var M;return t.default.wrap(function(F){for(;;)switch(F.prev=F.next){case 0:return typeof v=="string"&&(v=[v]),F.next=3,this.call("rpc.on",v);case 3:if(M=F.sent,!(typeof v=="string"&&M[v]!=="ok")){F.next=6;break}throw new Error("Failed subscribing to an event '"+v+"' with: "+M[v]);case 6:return F.abrupt("return",M);case 7:case"end":return F.stop()}},R,this)}));function d(R){return E.apply(this,arguments)}return d}()},{key:"unsubscribe",value:function(){var E=(0,r.default)(t.default.mark(function R(v){var M;return t.default.wrap(function(F){for(;;)switch(F.prev=F.next){case 0:return typeof v=="string"&&(v=[v]),F.next=3,this.call("rpc.off",v);case 3:if(M=F.sent,!(typeof v=="string"&&M[v]!=="ok")){F.next=6;break}throw new Error("Failed unsubscribing from an event with: "+M);case 6:return F.abrupt("return",M);case 7:case"end":return F.stop()}},R,this)}));function d(R){return E.apply(this,arguments)}return d}()},{key:"close",value:function(d,R){this.socket.close(d||1e3,R)}},{key:"_connect",value:function(d,R){var v=this;clearTimeout(this.reconnect_timer_id),this.socket=this.webSocketFactory(d,R),this.socket.addEventListener("open",function(){v.ready=!0,v.emit("open"),v.current_reconnects=0}),this.socket.addEventListener("message",function(M){var T=M.data;T instanceof ArrayBuffer&&(T=D.from(T).toString());try{T=JSON.parse(T)}catch{return}if(T.notification&&v.listeners(T.notification).length){if(!Object.keys(T.params).length)return v.emit(T.notification);var F=[T.notification];if(T.params.constructor===Object)F.push(T.params);else for(var X=0;X<T.params.length;X++)F.push(T.params[X]);return Promise.resolve().then(function(){v.emit.apply(v,F)})}if(!v.queue[T.id])return T.method&&T.params?Promise.resolve().then(function(){v.emit(T.method,T.params)}):void 0;"error"in T=="result"in T&&v.queue[T.id].promise[1](new Error('Server response malformed. Response must include either "result" or "error", but not both.')),v.queue[T.id].timeout&&clearTimeout(v.queue[T.id].timeout),T.error?v.queue[T.id].promise[1](T.error):v.queue[T.id].promise[0](T.result),delete v.queue[T.id]}),this.socket.addEventListener("error",function(M){return v.emit("error",M)}),this.socket.addEventListener("close",function(M){var T=M.code,F=M.reason;v.ready&&setTimeout(function(){return v.emit("close",T,F)},0),v.ready=!1,v.socket=void 0,T!==1e3&&(v.current_reconnects++,v.reconnect&&(v.max_reconnects>v.current_reconnects||v.max_reconnects===0)&&(v.reconnect_timer_id=setTimeout(function(){return v._connect(d,R)},v.reconnect_interval)))})}}]),_}(l.EventEmitter);n.default=m})(zo);const jc=xr(zo);var Zo={};(function(n){var e=Ho;Object.defineProperty(n,"__esModule",{value:!0}),n.default=w;var t=e($o()),r=e(Go()),s=e(Wo()),o=e(Vo()),i=e(Jo()),a=eo;function c(y){var h=u();return function(){var p=(0,i.default)(y),b;if(h){var _=(0,i.default)(this).constructor;b=Reflect.construct(p,arguments,_)}else b=p.apply(this,arguments);return(0,o.default)(this,b)}}function u(){if(typeof Reflect>"u"||!Reflect.construct||Reflect.construct.sham)return!1;if(typeof Proxy=="function")return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){})),!0}catch{return!1}}var l=function(y){(0,s.default)(m,y);var h=c(m);function m(p,b,_){var E;return(0,t.default)(this,m),E=h.call(this),E.socket=new window.WebSocket(p,_),E.socket.onopen=function(){return E.emit("open")},E.socket.onmessage=function(d){return E.emit("message",d.data)},E.socket.onerror=function(d){return E.emit("error",d)},E.socket.onclose=function(d){E.emit("close",d.code,d.reason)},E}return(0,r.default)(m,[{key:"send",value:function(b,_,E){var d=E||_;try{this.socket.send(b),d()}catch(R){d(R)}}},{key:"close",value:function(b,_){this.socket.close(b,_)}},{key:"addEventListener",value:function(b,_,E){this.socket.addEventListener(b,_,E)}}]),m}(a.EventEmitter);function w(y,h){return new l(y,h)}})(Zo);const Hc=xr(Zo);ge.utils.randomPrivateKey;const Ps=()=>{const n=ge.utils.randomPrivateKey(),e=pn(n),t=new Uint8Array(64);return t.set(n),t.set(e,32),{publicKey:e,secretKey:t}},pn=ge.getPublicKey;function Cs(n){try{return ge.ExtendedPoint.fromHex(n),!0}catch{return!1}}const Xo=(n,e)=>ge.sign(n,e.slice(0,32)),$c=ge.verify,Nt=n=>D.isBuffer(n)?n:n instanceof Uint8Array?D.from(n.buffer,n.byteOffset,n.byteLength):D.from(n);class Gc{constructor(e){Object.assign(this,e)}encode(){return D.from(yo(hr,this))}static decode(e){return mo(hr,this,e)}static decodeUnchecked(e){return lo(hr,this,e)}}const hr=new Map;let Yo;const Wc=32,tt=32;function Vc(n){return n._bn!==void 0}let Os=1;Yo=Symbol.toStringTag;class H extends Gc{constructor(e){if(super({}),this._bn=void 0,Vc(e))this._bn=e._bn;else{if(typeof e=="string"){const t=ie.decode(e);if(t.length!=tt)throw new Error("Invalid public key input");this._bn=new es(t)}else this._bn=new es(e);if(this._bn.byteLength()>tt)throw new Error("Invalid public key input")}}static unique(){const e=new H(Os);return Os+=1,new H(e.toBuffer())}equals(e){return this._bn.eq(e._bn)}toBase58(){return ie.encode(this.toBytes())}toJSON(){return this.toBase58()}toBytes(){const e=this.toBuffer();return new Uint8Array(e.buffer,e.byteOffset,e.byteLength)}toBuffer(){const e=this._bn.toArrayLike(D);if(e.length===tt)return e;const t=D.alloc(32);return e.copy(t,32-e.length),t}get[Yo](){return`PublicKey(${this.toString()})`}toString(){return this.toBase58()}static async createWithSeed(e,t,r){const s=D.concat([e.toBuffer(),D.from(t),r.toBuffer()]),o=ts(s);return new H(o)}static createProgramAddressSync(e,t){let r=D.alloc(0);e.forEach(function(o){if(o.length>Wc)throw new TypeError("Max seed length exceeded");r=D.concat([r,Nt(o)])}),r=D.concat([r,t.toBuffer(),D.from("ProgramDerivedAddress")]);const s=ts(r);if(Cs(s))throw new Error("Invalid seeds, address must fall off the curve");return new H(s)}static async createProgramAddress(e,t){return this.createProgramAddressSync(e,t)}static findProgramAddressSync(e,t){let r=255,s;for(;r!=0;){try{const o=e.concat(D.from([r]));s=this.createProgramAddressSync(o,t)}catch(o){if(o instanceof TypeError)throw o;r--;continue}return[s,r]}throw new Error("Unable to find a viable program address nonce")}static async findProgramAddress(e,t){return this.findProgramAddressSync(e,t)}static isOnCurve(e){const t=new H(e);return Cs(t.toBytes())}}H.default=new H("11111111111111111111111111111111");hr.set(H,{kind:"struct",fields:[["_bn","u256"]]});new H("BPFLoader1111111111111111111111111111111111");const Ot=1280-40-8,Un=127,Zt=64;class Qo extends Error{constructor(e){super(`Signature ${e} has expired: block height exceeded.`),this.signature=void 0,this.signature=e}}Object.defineProperty(Qo.prototype,"name",{value:"TransactionExpiredBlockheightExceededError"});class ei extends Error{constructor(e,t){super(`Transaction was not confirmed in ${t.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ${e} using the Solana Explorer or CLI tools.`),this.signature=void 0,this.signature=e}}Object.defineProperty(ei.prototype,"name",{value:"TransactionExpiredTimeoutError"});class Ht extends Error{constructor(e){super(`Signature ${e} has expired: the nonce is no longer valid.`),this.signature=void 0,this.signature=e}}Object.defineProperty(Ht.prototype,"name",{value:"TransactionExpiredNonceInvalidError"});class Sr{constructor(e,t){this.staticAccountKeys=void 0,this.accountKeysFromLookups=void 0,this.staticAccountKeys=e,this.accountKeysFromLookups=t}keySegments(){const e=[this.staticAccountKeys];return this.accountKeysFromLookups&&(e.push(this.accountKeysFromLookups.writable),e.push(this.accountKeysFromLookups.readonly)),e}get(e){for(const t of this.keySegments()){if(e<t.length)return t[e];e-=t.length}}get length(){return this.keySegments().flat().length}compileInstructions(e){if(this.length>255+1)throw new Error("Account index overflow encountered during compilation");const r=new Map;this.keySegments().flat().forEach((o,i)=>{r.set(o.toBase58(),i)});const s=o=>{const i=r.get(o.toBase58());if(i===void 0)throw new Error("Encountered an unknown instruction account key during compilation");return i};return e.map(o=>({programIdIndex:s(o.programId),accountKeyIndexes:o.keys.map(i=>s(i.pubkey)),data:o.data}))}}const ee=(n="publicKey")=>le(32,n),Jc=(n="signature")=>le(64,n),Bt=(n="string")=>{const e=K([j("length"),j("lengthPadding"),le(_t(j(),-8),"chars")],n),t=e.decode.bind(e),r=e.encode.bind(e),s=e;return s.decode=(o,i)=>t(o,i).chars.toString(),s.encode=(o,i,a)=>{const c={chars:D.from(o,"utf8")};return r(c,i,a)},s.alloc=o=>j().span+j().span+D.from(o,"utf8").length,s},Zc=(n="authorized")=>K([ee("staker"),ee("withdrawer")],n),Xc=(n="lockup")=>K([Me("unixTimestamp"),Me("epoch"),ee("custodian")],n),Yc=(n="voteInit")=>K([ee("nodePubkey"),ee("authorizedVoter"),ee("authorizedWithdrawer"),ne("commission")],n),Qc=(n="voteAuthorizeWithSeedArgs")=>K([j("voteAuthorizationType"),ee("currentAuthorityDerivedKeyOwnerPubkey"),Bt("currentAuthorityDerivedKeySeed"),ee("newAuthorized")],n);function Ue(n){let e=0,t=0;for(;;){let r=n.shift();if(e|=(r&127)<<t*7,t+=1,!(r&128))break}return e}function Fe(n,e){let t=e;for(;;){let r=t&127;if(t>>=7,t==0){n.push(r);break}else r|=128,n.push(r)}}function de(n,e){if(!n)throw new Error(e||"Assertion failed")}class Lr{constructor(e,t){this.payer=void 0,this.keyMetaMap=void 0,this.payer=e,this.keyMetaMap=t}static compile(e,t){const r=new Map,s=i=>{const a=i.toBase58();let c=r.get(a);return c===void 0&&(c={isSigner:!1,isWritable:!1,isInvoked:!1},r.set(a,c)),c},o=s(t);o.isSigner=!0,o.isWritable=!0;for(const i of e){s(i.programId).isInvoked=!0;for(const a of i.keys){const c=s(a.pubkey);c.isSigner||(c.isSigner=a.isSigner),c.isWritable||(c.isWritable=a.isWritable)}}return new Lr(t,r)}getMessageComponents(){const e=[...this.keyMetaMap.entries()];de(e.length<=256,"Max static account keys length exceeded");const t=e.filter(([,c])=>c.isSigner&&c.isWritable),r=e.filter(([,c])=>c.isSigner&&!c.isWritable),s=e.filter(([,c])=>!c.isSigner&&c.isWritable),o=e.filter(([,c])=>!c.isSigner&&!c.isWritable),i={numRequiredSignatures:t.length+r.length,numReadonlySignedAccounts:r.length,numReadonlyUnsignedAccounts:o.length};{de(t.length>0,"Expected at least one writable signer key");const[c]=t[0];de(c===this.payer.toBase58(),"Expected first writable signer key to be the fee payer")}const a=[...t.map(([c])=>new H(c)),...r.map(([c])=>new H(c)),...s.map(([c])=>new H(c)),...o.map(([c])=>new H(c))];return[i,a]}extractTableLookup(e){const[t,r]=this.drainKeysFoundInLookupTable(e.state.addresses,i=>!i.isSigner&&!i.isInvoked&&i.isWritable),[s,o]=this.drainKeysFoundInLookupTable(e.state.addresses,i=>!i.isSigner&&!i.isInvoked&&!i.isWritable);if(!(t.length===0&&s.length===0))return[{accountKey:e.key,writableIndexes:t,readonlyIndexes:s},{writable:r,readonly:o}]}drainKeysFoundInLookupTable(e,t){const r=new Array,s=new Array;for(const[o,i]of this.keyMetaMap.entries())if(t(i)){const a=new H(o),c=e.findIndex(u=>u.equals(a));c>=0&&(de(c<256,"Max lookup table index exceeded"),r.push(c),s.push(a),this.keyMetaMap.delete(o))}return[r,s]}}class ct{constructor(e){this.header=void 0,this.accountKeys=void 0,this.recentBlockhash=void 0,this.instructions=void 0,this.indexToProgramIds=new Map,this.header=e.header,this.accountKeys=e.accountKeys.map(t=>new H(t)),this.recentBlockhash=e.recentBlockhash,this.instructions=e.instructions,this.instructions.forEach(t=>this.indexToProgramIds.set(t.programIdIndex,this.accountKeys[t.programIdIndex]))}get version(){return"legacy"}get staticAccountKeys(){return this.accountKeys}get compiledInstructions(){return this.instructions.map(e=>({programIdIndex:e.programIdIndex,accountKeyIndexes:e.accounts,data:ie.decode(e.data)}))}get addressTableLookups(){return[]}getAccountKeys(){return new Sr(this.staticAccountKeys)}static compile(e){const t=Lr.compile(e.instructions,e.payerKey),[r,s]=t.getMessageComponents(),i=new Sr(s).compileInstructions(e.instructions).map(a=>({programIdIndex:a.programIdIndex,accounts:a.accountKeyIndexes,data:ie.encode(a.data)}));return new ct({header:r,accountKeys:s,recentBlockhash:e.recentBlockhash,instructions:i})}isAccountSigner(e){return e<this.header.numRequiredSignatures}isAccountWritable(e){const t=this.header.numRequiredSignatures;if(e>=this.header.numRequiredSignatures){const r=e-t,o=this.accountKeys.length-t-this.header.numReadonlyUnsignedAccounts;return r<o}else{const r=t-this.header.numReadonlySignedAccounts;return e<r}}isProgramId(e){return this.indexToProgramIds.has(e)}programIds(){return[...this.indexToProgramIds.values()]}nonProgramIds(){return this.accountKeys.filter((e,t)=>!this.isProgramId(t))}serialize(){const e=this.accountKeys.length;let t=[];Fe(t,e);const r=this.instructions.map(w=>{const{accounts:y,programIdIndex:h}=w,m=Array.from(ie.decode(w.data));let p=[];Fe(p,y.length);let b=[];return Fe(b,m.length),{programIdIndex:h,keyIndicesCount:D.from(p),keyIndices:y,dataLength:D.from(b),data:m}});let s=[];Fe(s,r.length);let o=D.alloc(Ot);D.from(s).copy(o);let i=s.length;r.forEach(w=>{const h=K([ne("programIdIndex"),le(w.keyIndicesCount.length,"keyIndicesCount"),Ie(ne("keyIndex"),w.keyIndices.length,"keyIndices"),le(w.dataLength.length,"dataLength"),Ie(ne("userdatum"),w.data.length,"data")]).encode(w,o,i);i+=h}),o=o.slice(0,i);const a=K([le(1,"numRequiredSignatures"),le(1,"numReadonlySignedAccounts"),le(1,"numReadonlyUnsignedAccounts"),le(t.length,"keyCount"),Ie(ee("key"),e,"keys"),ee("recentBlockhash")]),c={numRequiredSignatures:D.from([this.header.numRequiredSignatures]),numReadonlySignedAccounts:D.from([this.header.numReadonlySignedAccounts]),numReadonlyUnsignedAccounts:D.from([this.header.numReadonlyUnsignedAccounts]),keyCount:D.from(t),keys:this.accountKeys.map(w=>Nt(w.toBytes())),recentBlockhash:ie.decode(this.recentBlockhash)};let u=D.alloc(2048);const l=a.encode(c,u);return o.copy(u,l),u.slice(0,l+o.length)}static from(e){let t=[...e];const r=t.shift();if(r!==(r&Un))throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");const s=t.shift(),o=t.shift(),i=Ue(t);let a=[];for(let y=0;y<i;y++){const h=t.slice(0,tt);t=t.slice(tt),a.push(new H(D.from(h)))}const c=t.slice(0,tt);t=t.slice(tt);const u=Ue(t);let l=[];for(let y=0;y<u;y++){const h=t.shift(),m=Ue(t),p=t.slice(0,m);t=t.slice(m);const b=Ue(t),_=t.slice(0,b),E=ie.encode(D.from(_));t=t.slice(b),l.push({programIdIndex:h,accounts:p,data:E})}const w={header:{numRequiredSignatures:r,numReadonlySignedAccounts:s,numReadonlyUnsignedAccounts:o},recentBlockhash:ie.encode(D.from(c)),accountKeys:a,instructions:l};return new ct(w)}}class Xt{constructor(e){this.header=void 0,this.staticAccountKeys=void 0,this.recentBlockhash=void 0,this.compiledInstructions=void 0,this.addressTableLookups=void 0,this.header=e.header,this.staticAccountKeys=e.staticAccountKeys,this.recentBlockhash=e.recentBlockhash,this.compiledInstructions=e.compiledInstructions,this.addressTableLookups=e.addressTableLookups}get version(){return 0}get numAccountKeysFromLookups(){let e=0;for(const t of this.addressTableLookups)e+=t.readonlyIndexes.length+t.writableIndexes.length;return e}getAccountKeys(e){let t;if(e&&"accountKeysFromLookups"in e&&e.accountKeysFromLookups){if(this.numAccountKeysFromLookups!=e.accountKeysFromLookups.writable.length+e.accountKeysFromLookups.readonly.length)throw new Error("Failed to get account keys because of a mismatch in the number of account keys from lookups");t=e.accountKeysFromLookups}else if(e&&"addressLookupTableAccounts"in e&&e.addressLookupTableAccounts)t=this.resolveAddressTableLookups(e.addressLookupTableAccounts);else if(this.addressTableLookups.length>0)throw new Error("Failed to get account keys because address table lookups were not resolved");return new Sr(this.staticAccountKeys,t)}isAccountSigner(e){return e<this.header.numRequiredSignatures}isAccountWritable(e){const t=this.header.numRequiredSignatures,r=this.staticAccountKeys.length;if(e>=r){const s=e-r,o=this.addressTableLookups.reduce((i,a)=>i+a.writableIndexes.length,0);return s<o}else if(e>=this.header.numRequiredSignatures){const s=e-t,i=r-t-this.header.numReadonlyUnsignedAccounts;return s<i}else{const s=t-this.header.numReadonlySignedAccounts;return e<s}}resolveAddressTableLookups(e){const t={writable:[],readonly:[]};for(const r of this.addressTableLookups){const s=e.find(o=>o.key.equals(r.accountKey));if(!s)throw new Error(`Failed to find address lookup table account for table key ${r.accountKey.toBase58()}`);for(const o of r.writableIndexes)if(o<s.state.addresses.length)t.writable.push(s.state.addresses[o]);else throw new Error(`Failed to find address for index ${o} in address lookup table ${r.accountKey.toBase58()}`);for(const o of r.readonlyIndexes)if(o<s.state.addresses.length)t.readonly.push(s.state.addresses[o]);else throw new Error(`Failed to find address for index ${o} in address lookup table ${r.accountKey.toBase58()}`)}return t}static compile(e){const t=Lr.compile(e.instructions,e.payerKey),r=new Array,s={writable:new Array,readonly:new Array},o=e.addressLookupTableAccounts||[];for(const l of o){const w=t.extractTableLookup(l);if(w!==void 0){const[y,{writable:h,readonly:m}]=w;r.push(y),s.writable.push(...h),s.readonly.push(...m)}}const[i,a]=t.getMessageComponents(),u=new Sr(a,s).compileInstructions(e.instructions);return new Xt({header:i,staticAccountKeys:a,recentBlockhash:e.recentBlockhash,compiledInstructions:u,addressTableLookups:r})}serialize(){const e=Array();Fe(e,this.staticAccountKeys.length);const t=this.serializeInstructions(),r=Array();Fe(r,this.compiledInstructions.length);const s=this.serializeAddressTableLookups(),o=Array();Fe(o,this.addressTableLookups.length);const i=K([ne("prefix"),K([ne("numRequiredSignatures"),ne("numReadonlySignedAccounts"),ne("numReadonlyUnsignedAccounts")],"header"),le(e.length,"staticAccountKeysLength"),Ie(ee(),this.staticAccountKeys.length,"staticAccountKeys"),ee("recentBlockhash"),le(r.length,"instructionsLength"),le(t.length,"serializedInstructions"),le(o.length,"addressTableLookupsLength"),le(s.length,"serializedAddressTableLookups")]),a=new Uint8Array(Ot),c=128,u=i.encode({prefix:c,header:this.header,staticAccountKeysLength:new Uint8Array(e),staticAccountKeys:this.staticAccountKeys.map(l=>l.toBytes()),recentBlockhash:ie.decode(this.recentBlockhash),instructionsLength:new Uint8Array(r),serializedInstructions:t,addressTableLookupsLength:new Uint8Array(o),serializedAddressTableLookups:s},a);return a.slice(0,u)}serializeInstructions(){let e=0;const t=new Uint8Array(Ot);for(const r of this.compiledInstructions){const s=Array();Fe(s,r.accountKeyIndexes.length);const o=Array();Fe(o,r.data.length);const i=K([ne("programIdIndex"),le(s.length,"encodedAccountKeyIndexesLength"),Ie(ne(),r.accountKeyIndexes.length,"accountKeyIndexes"),le(o.length,"encodedDataLength"),le(r.data.length,"data")]);e+=i.encode({programIdIndex:r.programIdIndex,encodedAccountKeyIndexesLength:new Uint8Array(s),accountKeyIndexes:r.accountKeyIndexes,encodedDataLength:new Uint8Array(o),data:r.data},t,e)}return t.slice(0,e)}serializeAddressTableLookups(){let e=0;const t=new Uint8Array(Ot);for(const r of this.addressTableLookups){const s=Array();Fe(s,r.writableIndexes.length);const o=Array();Fe(o,r.readonlyIndexes.length);const i=K([ee("accountKey"),le(s.length,"encodedWritableIndexesLength"),Ie(ne(),r.writableIndexes.length,"writableIndexes"),le(o.length,"encodedReadonlyIndexesLength"),Ie(ne(),r.readonlyIndexes.length,"readonlyIndexes")]);e+=i.encode({accountKey:r.accountKey.toBytes(),encodedWritableIndexesLength:new Uint8Array(s),writableIndexes:r.writableIndexes,encodedReadonlyIndexesLength:new Uint8Array(o),readonlyIndexes:r.readonlyIndexes},t,e)}return t.slice(0,e)}static deserialize(e){let t=[...e];const r=t.shift(),s=r&Un;de(r!==s,"Expected versioned message but received legacy message");const o=s;de(o===0,`Expected versioned message with version 0 but found version ${o}`);const i={numRequiredSignatures:t.shift(),numReadonlySignedAccounts:t.shift(),numReadonlyUnsignedAccounts:t.shift()},a=[],c=Ue(t);for(let m=0;m<c;m++)a.push(new H(t.splice(0,tt)));const u=ie.encode(t.splice(0,tt)),l=Ue(t),w=[];for(let m=0;m<l;m++){const p=t.shift(),b=Ue(t),_=t.splice(0,b),E=Ue(t),d=new Uint8Array(t.splice(0,E));w.push({programIdIndex:p,accountKeyIndexes:_,data:d})}const y=Ue(t),h=[];for(let m=0;m<y;m++){const p=new H(t.splice(0,tt)),b=Ue(t),_=t.splice(0,b),E=Ue(t),d=t.splice(0,E);h.push({accountKey:p,writableIndexes:_,readonlyIndexes:d})}return new Xt({header:i,staticAccountKeys:a,recentBlockhash:u,compiledInstructions:w,addressTableLookups:h})}}const ti={deserializeMessageVersion(n){const e=n[0],t=e&Un;return t===e?"legacy":t},deserialize:n=>{const e=ti.deserializeMessageVersion(n);if(e==="legacy")return ct.from(n);if(e===0)return Xt.deserialize(n);throw new Error(`Transaction message version ${e} deserialization is not supported`)}};let Ye;(function(n){n[n.BLOCKHEIGHT_EXCEEDED=0]="BLOCKHEIGHT_EXCEEDED",n[n.PROCESSED=1]="PROCESSED",n[n.TIMED_OUT=2]="TIMED_OUT",n[n.NONCE_INVALID=3]="NONCE_INVALID"})(Ye||(Ye={}));const eu=D.alloc(Zt).fill(0);class Ts{constructor(e){this.keys=void 0,this.programId=void 0,this.data=D.alloc(0),this.programId=e.programId,this.keys=e.keys,e.data&&(this.data=e.data)}toJSON(){return{keys:this.keys.map(({pubkey:e,isSigner:t,isWritable:r})=>({pubkey:e.toJSON(),isSigner:t,isWritable:r})),programId:this.programId.toJSON(),data:[...this.data]}}}class ht{get signature(){return this.signatures.length>0?this.signatures[0].signature:null}constructor(e){if(this.signatures=[],this.feePayer=void 0,this.instructions=[],this.recentBlockhash=void 0,this.lastValidBlockHeight=void 0,this.nonceInfo=void 0,this.minNonceContextSlot=void 0,this._message=void 0,this._json=void 0,!!e)if(e.feePayer&&(this.feePayer=e.feePayer),e.signatures&&(this.signatures=e.signatures),Object.prototype.hasOwnProperty.call(e,"nonceInfo")){const{minContextSlot:t,nonceInfo:r}=e;this.minNonceContextSlot=t,this.nonceInfo=r}else if(Object.prototype.hasOwnProperty.call(e,"lastValidBlockHeight")){const{blockhash:t,lastValidBlockHeight:r}=e;this.recentBlockhash=t,this.lastValidBlockHeight=r}else{const{recentBlockhash:t,nonceInfo:r}=e;r&&(this.nonceInfo=r),this.recentBlockhash=t}}toJSON(){return{recentBlockhash:this.recentBlockhash||null,feePayer:this.feePayer?this.feePayer.toJSON():null,nonceInfo:this.nonceInfo?{nonce:this.nonceInfo.nonce,nonceInstruction:this.nonceInfo.nonceInstruction.toJSON()}:null,instructions:this.instructions.map(e=>e.toJSON()),signers:this.signatures.map(({publicKey:e})=>e.toJSON())}}add(...e){if(e.length===0)throw new Error("No instructions");return e.forEach(t=>{"instructions"in t?this.instructions=this.instructions.concat(t.instructions):"data"in t&&"programId"in t&&"keys"in t?this.instructions.push(t):this.instructions.push(new Ts(t))}),this}compileMessage(){if(this._message&&JSON.stringify(this.toJSON())===JSON.stringify(this._json))return this._message;let e,t;if(this.nonceInfo?(e=this.nonceInfo.nonce,this.instructions[0]!=this.nonceInfo.nonceInstruction?t=[this.nonceInfo.nonceInstruction,...this.instructions]:t=this.instructions):(e=this.recentBlockhash,t=this.instructions),!e)throw new Error("Transaction recentBlockhash required");t.length<1&&console.warn("No instructions provided");let r;if(this.feePayer)r=this.feePayer;else if(this.signatures.length>0&&this.signatures[0].publicKey)r=this.signatures[0].publicKey;else throw new Error("Transaction fee payer required");for(let p=0;p<t.length;p++)if(t[p].programId===void 0)throw new Error(`Transaction instruction index ${p} has undefined program id`);const s=[],o=[];t.forEach(p=>{p.keys.forEach(_=>{o.push({..._})});const b=p.programId.toString();s.includes(b)||s.push(b)}),s.forEach(p=>{o.push({pubkey:new H(p),isSigner:!1,isWritable:!1})});const i=[];o.forEach(p=>{const b=p.pubkey.toString(),_=i.findIndex(E=>E.pubkey.toString()===b);_>-1?(i[_].isWritable=i[_].isWritable||p.isWritable,i[_].isSigner=i[_].isSigner||p.isSigner):i.push(p)}),i.sort(function(p,b){return p.isSigner!==b.isSigner?p.isSigner?-1:1:p.isWritable!==b.isWritable?p.isWritable?-1:1:p.pubkey.toBase58().localeCompare(b.pubkey.toBase58())});const a=i.findIndex(p=>p.pubkey.equals(r));if(a>-1){const[p]=i.splice(a,1);p.isSigner=!0,p.isWritable=!0,i.unshift(p)}else i.unshift({pubkey:r,isSigner:!0,isWritable:!0});for(const p of this.signatures){const b=i.findIndex(_=>_.pubkey.equals(p.publicKey));if(b>-1)i[b].isSigner||(i[b].isSigner=!0,console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release."));else throw new Error(`unknown signer: ${p.publicKey.toString()}`)}let c=0,u=0,l=0;const w=[],y=[];i.forEach(({pubkey:p,isSigner:b,isWritable:_})=>{b?(w.push(p.toString()),c+=1,_||(u+=1)):(y.push(p.toString()),_||(l+=1))});const h=w.concat(y),m=t.map(p=>{const{data:b,programId:_}=p;return{programIdIndex:h.indexOf(_.toString()),accounts:p.keys.map(E=>h.indexOf(E.pubkey.toString())),data:ie.encode(b)}});return m.forEach(p=>{de(p.programIdIndex>=0),p.accounts.forEach(b=>de(b>=0))}),new ct({header:{numRequiredSignatures:c,numReadonlySignedAccounts:u,numReadonlyUnsignedAccounts:l},accountKeys:h,recentBlockhash:e,instructions:m})}_compile(){const e=this.compileMessage(),t=e.accountKeys.slice(0,e.header.numRequiredSignatures);return this.signatures.length===t.length&&this.signatures.every((s,o)=>t[o].equals(s.publicKey))||(this.signatures=t.map(r=>({signature:null,publicKey:r}))),e}serializeMessage(){return this._compile().serialize()}async getEstimatedFee(e){return(await e.getFeeForMessage(this.compileMessage())).value}setSigners(...e){if(e.length===0)throw new Error("No signers");const t=new Set;this.signatures=e.filter(r=>{const s=r.toString();return t.has(s)?!1:(t.add(s),!0)}).map(r=>({signature:null,publicKey:r}))}sign(...e){if(e.length===0)throw new Error("No signers");const t=new Set,r=[];for(const o of e){const i=o.publicKey.toString();t.has(i)||(t.add(i),r.push(o))}this.signatures=r.map(o=>({signature:null,publicKey:o.publicKey}));const s=this._compile();this._partialSign(s,...r)}partialSign(...e){if(e.length===0)throw new Error("No signers");const t=new Set,r=[];for(const o of e){const i=o.publicKey.toString();t.has(i)||(t.add(i),r.push(o))}const s=this._compile();this._partialSign(s,...r)}_partialSign(e,...t){const r=e.serialize();t.forEach(s=>{const o=Xo(r,s.secretKey);this._addSignature(s.publicKey,Nt(o))})}addSignature(e,t){this._compile(),this._addSignature(e,t)}_addSignature(e,t){de(t.length===64);const r=this.signatures.findIndex(s=>e.equals(s.publicKey));if(r<0)throw new Error(`unknown signer: ${e.toString()}`);this.signatures[r].signature=D.from(t)}verifySignatures(e){return this._verifySignatures(this.serializeMessage(),e===void 0?!0:e)}_verifySignatures(e,t){for(const{signature:r,publicKey:s}of this.signatures)if(r===null){if(t)return!1}else if(!$c(r,e,s.toBytes()))return!1;return!0}serialize(e){const{requireAllSignatures:t,verifySignatures:r}=Object.assign({requireAllSignatures:!0,verifySignatures:!0},e),s=this.serializeMessage();if(r&&!this._verifySignatures(s,t))throw new Error("Signature verification failed");return this._serialize(s)}_serialize(e){const{signatures:t}=this,r=[];Fe(r,t.length);const s=r.length+t.length*64+e.length,o=D.alloc(s);return de(t.length<256),D.from(r).copy(o,0),t.forEach(({signature:i},a)=>{i!==null&&(de(i.length===64,"signature has invalid length"),D.from(i).copy(o,r.length+a*64))}),e.copy(o,r.length+t.length*64),de(o.length<=Ot,`Transaction too large: ${o.length} > ${Ot}`),o}get keys(){return de(this.instructions.length===1),this.instructions[0].keys.map(e=>e.pubkey)}get programId(){return de(this.instructions.length===1),this.instructions[0].programId}get data(){return de(this.instructions.length===1),this.instructions[0].data}static from(e){let t=[...e];const r=Ue(t);let s=[];for(let o=0;o<r;o++){const i=t.slice(0,Zt);t=t.slice(Zt),s.push(ie.encode(D.from(i)))}return ht.populate(ct.from(t),s)}static populate(e,t=[]){const r=new ht;return r.recentBlockhash=e.recentBlockhash,e.header.numRequiredSignatures>0&&(r.feePayer=e.accountKeys[0]),t.forEach((s,o)=>{const i={signature:s==ie.encode(eu)?null:ie.decode(s),publicKey:e.accountKeys[o]};r.signatures.push(i)}),e.instructions.forEach(s=>{const o=s.accounts.map(i=>{const a=e.accountKeys[i];return{pubkey:a,isSigner:r.signatures.some(c=>c.publicKey.toString()===a.toString())||e.isAccountSigner(i),isWritable:e.isAccountWritable(i)}});r.instructions.push(new Ts({keys:o,programId:e.accountKeys[s.programIdIndex],data:ie.decode(s.data)}))}),r._message=e,r._json=r.toJSON(),r}}class Tt{get version(){return this.message.version}constructor(e,t){if(this.signatures=void 0,this.message=void 0,t!==void 0)de(t.length===e.header.numRequiredSignatures,"Expected signatures length to be equal to the number of required signatures"),this.signatures=t;else{const r=[];for(let s=0;s<e.header.numRequiredSignatures;s++)r.push(new Uint8Array(Zt));this.signatures=r}this.message=e}serialize(){const e=this.message.serialize(),t=Array();Fe(t,this.signatures.length);const r=K([le(t.length,"encodedSignaturesLength"),Ie(Jc(),this.signatures.length,"signatures"),le(e.length,"serializedMessage")]),s=new Uint8Array(2048),o=r.encode({encodedSignaturesLength:new Uint8Array(t),signatures:this.signatures,serializedMessage:e},s);return s.slice(0,o)}static deserialize(e){let t=[...e];const r=[],s=Ue(t);for(let i=0;i<s;i++)r.push(new Uint8Array(t.splice(0,Zt)));const o=ti.deserialize(new Uint8Array(t));return new Tt(o,r)}sign(e){const t=this.message.serialize(),r=this.message.staticAccountKeys.slice(0,this.message.header.numRequiredSignatures);for(const s of e){const o=r.findIndex(i=>i.equals(s.publicKey));de(o>=0,`Cannot sign with non signer key ${s.publicKey.toBase58()}`),this.signatures[o]=Xo(t,s.secretKey)}}addSignature(e,t){de(t.byteLength===64,"Signature must be 64 bytes long");const s=this.message.staticAccountKeys.slice(0,this.message.header.numRequiredSignatures).findIndex(o=>o.equals(e));de(s>=0,`Can not add signature; \`${e.toBase58()}\` is not required to sign this transaction`),this.signatures[s]=t}}new H("SysvarC1ock11111111111111111111111111111111");new H("SysvarEpochSchedu1e111111111111111111111111");new H("Sysvar1nstructions1111111111111111111111111");new H("SysvarRecentB1ockHashes11111111111111111111");new H("SysvarRent111111111111111111111111111111111");new H("SysvarRewards111111111111111111111111111111");new H("SysvarS1otHashes111111111111111111111111111");new H("SysvarS1otHistory11111111111111111111111111");new H("SysvarStakeHistory1111111111111111111111111");function Rt(n){return new Promise(e=>setTimeout(e,n))}const tu=be("lamportsPerSignature"),ri=K([j("version"),j("state"),ee("authorizedPubkey"),ee("nonce"),K([tu],"feeCalculator")]);ri.span;class Fn{constructor(e){this.authorizedPubkey=void 0,this.nonce=void 0,this.feeCalculator=void 0,this.authorizedPubkey=e.authorizedPubkey,this.nonce=e.nonce,this.feeCalculator=e.feeCalculator}static fromAccountData(e){const t=ri.decode(Nt(e),0);return new Fn({authorizedPubkey:new H(t.authorizedPubkey),nonce:new H(t.nonce).toString(),feeCalculator:t.feeCalculator})}}const ru=n=>{const e=n.decode.bind(n),t=n.encode.bind(n);return{decode:e,encode:t}},nu=n=>e=>{const t=le(n,e),{encode:r,decode:s}=ru(t),o=t;return o.decode=(i,a)=>{const c=s(i,a);return Ya(D.from(c))},o.encode=(i,a,c)=>{const u=tc(i,n);return r(u,a,c)},o},Mt=nu(8);Object.freeze({Create:{index:0,layout:K([j("instruction"),Me("lamports"),Me("space"),ee("programId")])},Assign:{index:1,layout:K([j("instruction"),ee("programId")])},Transfer:{index:2,layout:K([j("instruction"),Mt("lamports")])},CreateWithSeed:{index:3,layout:K([j("instruction"),ee("base"),Bt("seed"),Me("lamports"),Me("space"),ee("programId")])},AdvanceNonceAccount:{index:4,layout:K([j("instruction")])},WithdrawNonceAccount:{index:5,layout:K([j("instruction"),Me("lamports")])},InitializeNonceAccount:{index:6,layout:K([j("instruction"),ee("authorized")])},AuthorizeNonceAccount:{index:7,layout:K([j("instruction"),ee("authorized")])},Allocate:{index:8,layout:K([j("instruction"),Me("space")])},AllocateWithSeed:{index:9,layout:K([j("instruction"),ee("base"),Bt("seed"),Me("space"),ee("programId")])},AssignWithSeed:{index:10,layout:K([j("instruction"),ee("base"),Bt("seed"),ee("programId")])},TransferWithSeed:{index:11,layout:K([j("instruction"),Mt("lamports"),Bt("seed"),ee("programId")])},UpgradeNonceAccount:{index:12,layout:K([j("instruction")])}});new H("11111111111111111111111111111111");new H("BPFLoader2111111111111111111111111111111111");var su=Object.prototype.toString,ou=Object.keys||function(n){var e=[];for(var t in n)e.push(t);return e};function $t(n,e){var t,r,s,o,i,a,c;if(n===!0)return"true";if(n===!1)return"false";switch(typeof n){case"object":if(n===null)return null;if(n.toJSON&&typeof n.toJSON=="function")return $t(n.toJSON(),e);if(c=su.call(n),c==="[object Array]"){for(s="[",r=n.length-1,t=0;t<r;t++)s+=$t(n[t],!0)+",";return r>-1&&(s+=$t(n[t],!0)),s+"]"}else if(c==="[object Object]"){for(o=ou(n).sort(),r=o.length,s="",t=0;t<r;)i=o[t],a=$t(n[i],!1),a!==void 0&&(s&&(s+=","),s+=JSON.stringify(i)+":"+a),t++;return"{"+s+"}"}else return JSON.stringify(n);case"function":case"undefined":return e?null:void 0;case"string":return JSON.stringify(n);default:return isFinite(n)?n:null}}var iu=function(n){var e=$t(n,!1);if(e!==void 0)return""+e},Ls=iu;const jt=32;function cn(n){let e=0;for(;n>1;)n/=2,e++;return e}function au(n){return n===0?1:(n--,n|=n>>1,n|=n>>2,n|=n>>4,n|=n>>8,n|=n>>16,n|=n>>32,n+1)}class cu{constructor(e,t,r,s,o){this.slotsPerEpoch=void 0,this.leaderScheduleSlotOffset=void 0,this.warmup=void 0,this.firstNormalEpoch=void 0,this.firstNormalSlot=void 0,this.slotsPerEpoch=e,this.leaderScheduleSlotOffset=t,this.warmup=r,this.firstNormalEpoch=s,this.firstNormalSlot=o}getEpoch(e){return this.getEpochAndSlotIndex(e)[0]}getEpochAndSlotIndex(e){if(e<this.firstNormalSlot){const t=cn(au(e+jt+1))-cn(jt)-1,r=this.getSlotsInEpoch(t),s=e-(r-jt);return[t,s]}else{const t=e-this.firstNormalSlot,r=Math.floor(t/this.slotsPerEpoch),s=this.firstNormalEpoch+r,o=t%this.slotsPerEpoch;return[s,o]}}getFirstSlotInEpoch(e){return e<=this.firstNormalEpoch?(Math.pow(2,e)-1)*jt:(e-this.firstNormalEpoch)*this.slotsPerEpoch+this.firstNormalSlot}getLastSlotInEpoch(e){return this.getFirstSlotInEpoch(e)+this.getSlotsInEpoch(e)-1}getSlotsInEpoch(e){return e<this.firstNormalEpoch?Math.pow(2,e+cn(jt)):this.slotsPerEpoch}}class Ns extends Error{constructor(e,t){super(e),this.logs=void 0,this.logs=t}}class z extends Error{constructor({code:e,message:t,data:r},s){super(s!=null?`${s}: ${t}`:t),this.code=void 0,this.data=void 0,this.code=e,this.data=r,this.name="SolanaJSONRPCError"}}var uu=globalThis.fetch;class lu extends jc{constructor(e,t,r){const s=o=>{const i=Hc(o,{autoconnect:!0,max_reconnects:5,reconnect:!0,reconnect_interval:1e3,...t});return"socket"in i?this.underlyingSocket=i.socket:this.underlyingSocket=i,i};super(s,e,t,r),this.underlyingSocket=void 0}call(...e){const t=this.underlyingSocket?.readyState;return t===1?super.call(...e):Promise.reject(new Error("Tried to call a JSON-RPC method `"+e[0]+"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was "+t+")"))}notify(...e){const t=this.underlyingSocket?.readyState;return t===1?super.notify(...e):Promise.reject(new Error("Tried to send a JSON-RPC notification `"+e[0]+"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was "+t+")"))}}const du=160,fu=64,hu=du/fu,pu=1e3/hu;function gu(n,e){let t;try{t=n.layout.decode(e)}catch(r){throw new Error("invalid instruction; "+r)}if(t.typeIndex!==n.index)throw new Error(`invalid account data; account type mismatch ${t.typeIndex} != ${n.index}`);return t}const Ms=56;class Us{constructor(e){this.key=void 0,this.state=void 0,this.key=e.key,this.state=e.state}isActive(){const e=BigInt("0xffffffffffffffff");return this.state.deactivationSlot===e}static deserialize(e){const t=gu(yu,e),r=e.length-Ms;de(r>=0,"lookup table is invalid"),de(r%32===0,"lookup table is invalid");const s=r/32,{addresses:o}=K([Ie(ee(),s,"addresses")]).decode(e.slice(Ms));return{deactivationSlot:t.deactivationSlot,lastExtendedSlot:t.lastExtendedSlot,lastExtendedSlotStartIndex:t.lastExtendedStartIndex,authority:t.authority.length!==0?new H(t.authority[0]):void 0,addresses:o.map(i=>new H(i))}}}const yu={index:1,layout:K([j("typeIndex"),Mt("deactivationSlot"),be("lastExtendedSlot"),ne("lastExtendedStartIndex"),ne(),Ie(ee(),_t(ne(),-1),"authority")])},mu=/^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i;function wu(n){const e=n.match(mu);if(e==null)throw TypeError(`Failed to validate endpoint URL \`${n}\``);const[t,r,s,o]=e,i=n.startsWith("https:")?"wss:":"ws:",a=s==null?null:parseInt(s.slice(1),10),c=a==null?"":`:${a+1}`;return`${i}//${r}${c}${o}`}const me=or(Nn(H),P(),n=>new H(n)),ni=Mn([P(),he("base64")]),qn=or(Nn(D),ni,n=>D.from(n[0],"base64")),bu=30*1e3;function vu(n){if(/^https?:/.test(n)===!1)throw new TypeError("Endpoint URL must start with `http:` or `https:`.");return n}function fe(n){let e,t;if(typeof n=="string")e=n;else if(n){const{commitment:r,...s}=n;e=r,t=s}return{commitment:e,config:t}}function si(n){return Oe([k({jsonrpc:he("2.0"),id:P(),result:n}),k({jsonrpc:he("2.0"),id:P(),error:k({code:sr(),message:P(),data:$(uc())})})])}const Su=si(sr());function J(n){return or(si(n),Su,e=>"error"in e?e:{...e,result:O(e.result,n)})}function ye(n){return J(k({context:k({slot:f()}),value:n}))}function Nr(n){return k({context:k({slot:f()}),value:n})}function un(n,e){return n===0?new Xt({header:e.header,staticAccountKeys:e.accountKeys.map(t=>new H(t)),recentBlockhash:e.recentBlockhash,compiledInstructions:e.instructions.map(t=>({programIdIndex:t.programIdIndex,accountKeyIndexes:t.accounts,data:ie.decode(t.data)})),addressTableLookups:e.addressTableLookups}):new ct(e)}const _u=k({foundation:f(),foundationTerm:f(),initial:f(),taper:f(),terminal:f()}),Eu=J(L(N(k({epoch:f(),effectiveSlot:f(),amount:f(),postBalance:f(),commission:$(N(f()))})))),xu=L(k({slot:f(),prioritizationFee:f()})),ku=k({total:f(),validator:f(),foundation:f(),epoch:f()}),Au=k({epoch:f(),slotIndex:f(),slotsInEpoch:f(),absoluteSlot:f(),blockHeight:$(f()),transactionCount:$(f())}),Iu=k({slotsPerEpoch:f(),leaderScheduleSlotOffset:f(),warmup:at(),firstNormalEpoch:f(),firstNormalSlot:f()}),Ru=Mo(P(),L(f())),kt=N(Oe([k({}),P()])),Bu=k({err:kt}),Pu=he("receivedSignature"),Cu=k({"solana-core":P(),"feature-set":$(f())}),Fs=ye(k({err:N(Oe([k({}),P()])),logs:N(L(P())),accounts:$(N(L(N(k({executable:at(),owner:P(),lamports:f(),data:L(P()),rentEpoch:$(f())}))))),unitsConsumed:$(f()),returnData:$(N(k({programId:P(),data:Mn([P(),he("base64")])})))})),Ou=ye(k({byIdentity:Mo(P(),L(f())),range:k({firstSlot:f(),lastSlot:f()})}));function Tu(n,e,t,r,s,o){const i=t||uu;let a;o!=null&&console.warn("You have supplied an `httpAgent` when creating a `Connection` in a browser environment.It has been ignored; `httpAgent` is only used in Node environments.");let c;return r&&(c=async(l,w)=>{const y=await new Promise((h,m)=>{try{r(l,w,(p,b)=>h([p,b]))}catch(p){m(p)}});return await i(...y)}),new Fc(async(l,w)=>{const y={method:"POST",body:l,agent:a,headers:Object.assign({"Content-Type":"application/json"},e||{},Tl)};try{let h=5,m,p=500;for(;c?m=await c(n,y):m=await i(n,y),!(m.status!==429||s===!0||(h-=1,h===0));)console.log(`Server responded with ${m.status} ${m.statusText}.  Retrying after ${p}ms delay...`),await Rt(p),p*=2;const b=await m.text();m.ok?w(null,b):w(new Error(`${m.status} ${m.statusText}: ${b}`))}catch(h){h instanceof Error&&w(h)}},{})}function Lu(n){return(e,t)=>new Promise((r,s)=>{n.request(e,t,(o,i)=>{if(o){s(o);return}r(i)})})}function Nu(n){return e=>new Promise((t,r)=>{e.length===0&&t([]);const s=e.map(o=>n.request(o.methodName,o.args));n.request(s,(o,i)=>{if(o){r(o);return}t(i)})})}const Mu=J(_u),Uu=J(ku),Fu=J(xu),qu=J(Au),Du=J(Iu),Ku=J(Ru),zu=J(f()),ju=ye(k({total:f(),circulating:f(),nonCirculating:f(),nonCirculatingAccounts:L(me)})),gn=k({amount:P(),uiAmount:N(f()),decimals:f(),uiAmountString:$(P())}),Hu=ye(L(k({address:me,amount:P(),uiAmount:N(f()),decimals:f(),uiAmountString:$(P())}))),$u=ye(L(k({pubkey:me,account:k({executable:at(),owner:me,lamports:f(),data:qn,rentEpoch:f()})}))),yn=k({program:P(),parsed:sr(),space:f()}),Gu=ye(L(k({pubkey:me,account:k({executable:at(),owner:me,lamports:f(),data:yn,rentEpoch:f()})}))),Wu=ye(L(k({lamports:f(),address:me}))),Yt=k({executable:at(),owner:me,lamports:f(),data:qn,rentEpoch:f()}),Vu=k({pubkey:me,account:Yt}),Ju=or(Oe([Nn(D),yn]),Oe([ni,yn]),n=>Array.isArray(n)?O(n,qn):n),mn=k({executable:at(),owner:me,lamports:f(),data:Ju,rentEpoch:f()}),Zu=k({pubkey:me,account:mn}),Xu=k({state:Oe([he("active"),he("inactive"),he("activating"),he("deactivating")]),active:f(),inactive:f()}),Yu=J(L(k({signature:P(),slot:f(),err:kt,memo:N(P()),blockTime:$(N(f()))}))),Qu=J(L(k({signature:P(),slot:f(),err:kt,memo:N(P()),blockTime:$(N(f()))}))),el=k({subscription:f(),result:Nr(Yt)}),tl=k({pubkey:me,account:Yt}),rl=k({subscription:f(),result:Nr(tl)}),nl=k({parent:f(),slot:f(),root:f()}),sl=k({subscription:f(),result:nl}),ol=Oe([k({type:Oe([he("firstShredReceived"),he("completed"),he("optimisticConfirmation"),he("root")]),slot:f(),timestamp:f()}),k({type:he("createdBank"),parent:f(),slot:f(),timestamp:f()}),k({type:he("frozen"),slot:f(),timestamp:f(),stats:k({numTransactionEntries:f(),numSuccessfulTransactions:f(),numFailedTransactions:f(),maxTransactionsPerEntry:f()})}),k({type:he("dead"),slot:f(),timestamp:f(),err:P()})]),il=k({subscription:f(),result:ol}),al=k({subscription:f(),result:Nr(Oe([Bu,Pu]))}),cl=k({subscription:f(),result:f()}),ul=k({pubkey:P(),gossip:N(P()),tpu:N(P()),rpc:N(P()),version:N(P())}),qs=k({votePubkey:P(),nodePubkey:P(),activatedStake:f(),epochVoteAccount:at(),epochCredits:L(Mn([f(),f(),f()])),commission:f(),lastVote:f(),rootSlot:N(f())}),ll=J(k({current:L(qs),delinquent:L(qs)})),dl=Oe([he("processed"),he("confirmed"),he("finalized")]),fl=k({slot:f(),confirmations:N(f()),err:kt,confirmationStatus:$(dl)}),hl=ye(L(N(fl))),pl=J(f()),oi=k({accountKey:me,writableIndexes:L(f()),readonlyIndexes:L(f())}),Dn=k({signatures:L(P()),message:k({accountKeys:L(P()),header:k({numRequiredSignatures:f(),numReadonlySignedAccounts:f(),numReadonlyUnsignedAccounts:f()}),instructions:L(k({accounts:L(f()),data:P(),programIdIndex:f()})),recentBlockhash:P(),addressTableLookups:$(L(oi))})}),ii=k({pubkey:me,signer:at(),writable:at(),source:$(Oe([he("transaction"),he("lookupTable")]))}),ai=k({accountKeys:L(ii),signatures:L(P())}),ci=k({parsed:sr(),program:P(),programId:me}),ui=k({accounts:L(me),data:P(),programId:me}),gl=Oe([ui,ci]),yl=Oe([k({parsed:sr(),program:P(),programId:P()}),k({accounts:L(P()),data:P(),programId:P()})]),li=or(gl,yl,n=>"accounts"in n?O(n,ui):O(n,ci)),di=k({signatures:L(P()),message:k({accountKeys:L(ii),instructions:L(li),recentBlockhash:P(),addressTableLookups:$(N(L(oi)))})}),_r=k({accountIndex:f(),mint:P(),owner:$(P()),uiTokenAmount:gn}),fi=k({writable:L(me),readonly:L(me)}),Mr=k({err:kt,fee:f(),innerInstructions:$(N(L(k({index:f(),instructions:L(k({accounts:L(f()),data:P(),programIdIndex:f()}))})))),preBalances:L(f()),postBalances:L(f()),logMessages:$(N(L(P()))),preTokenBalances:$(N(L(_r))),postTokenBalances:$(N(L(_r))),loadedAddresses:$(fi),computeUnitsConsumed:$(f())}),Kn=k({err:kt,fee:f(),innerInstructions:$(N(L(k({index:f(),instructions:L(li)})))),preBalances:L(f()),postBalances:L(f()),logMessages:$(N(L(P()))),preTokenBalances:$(N(L(_r))),postTokenBalances:$(N(L(_r))),loadedAddresses:$(fi),computeUnitsConsumed:$(f())}),qt=Oe([he(0),he("legacy")]),At=k({pubkey:P(),lamports:f(),postBalance:N(f()),rewardType:N(P()),commission:$(N(f()))}),ml=J(N(k({blockhash:P(),previousBlockhash:P(),parentSlot:f(),transactions:L(k({transaction:Dn,meta:N(Mr),version:$(qt)})),rewards:$(L(At)),blockTime:N(f()),blockHeight:N(f())}))),wl=J(N(k({blockhash:P(),previousBlockhash:P(),parentSlot:f(),rewards:$(L(At)),blockTime:N(f()),blockHeight:N(f())}))),bl=J(N(k({blockhash:P(),previousBlockhash:P(),parentSlot:f(),transactions:L(k({transaction:ai,meta:N(Mr),version:$(qt)})),rewards:$(L(At)),blockTime:N(f()),blockHeight:N(f())}))),vl=J(N(k({blockhash:P(),previousBlockhash:P(),parentSlot:f(),transactions:L(k({transaction:di,meta:N(Kn),version:$(qt)})),rewards:$(L(At)),blockTime:N(f()),blockHeight:N(f())}))),Sl=J(N(k({blockhash:P(),previousBlockhash:P(),parentSlot:f(),transactions:L(k({transaction:ai,meta:N(Kn),version:$(qt)})),rewards:$(L(At)),blockTime:N(f()),blockHeight:N(f())}))),_l=J(N(k({blockhash:P(),previousBlockhash:P(),parentSlot:f(),rewards:$(L(At)),blockTime:N(f()),blockHeight:N(f())}))),El=J(N(k({blockhash:P(),previousBlockhash:P(),parentSlot:f(),transactions:L(k({transaction:Dn,meta:N(Mr)})),rewards:$(L(At)),blockTime:N(f())}))),Ds=J(N(k({blockhash:P(),previousBlockhash:P(),parentSlot:f(),signatures:L(P()),blockTime:N(f())}))),ln=J(N(k({slot:f(),meta:Mr,blockTime:$(N(f())),transaction:Dn,version:$(qt)}))),dr=J(N(k({slot:f(),transaction:di,meta:N(Kn),blockTime:$(N(f())),version:$(qt)}))),xl=ye(k({blockhash:P(),feeCalculator:k({lamportsPerSignature:f()})})),kl=ye(k({blockhash:P(),lastValidBlockHeight:f()})),Al=k({slot:f(),numTransactions:f(),numSlots:f(),samplePeriodSecs:f()}),Il=J(L(Al)),Rl=ye(N(k({feeCalculator:k({lamportsPerSignature:f()})}))),Bl=J(P()),Pl=J(P()),Cl=k({err:kt,logs:L(P()),signature:P()}),Ol=k({result:Nr(Cl),subscription:f()}),Tl={"solana-client":"js/0.0.0-development"};class hi{constructor(e,t){this._commitment=void 0,this._confirmTransactionInitialTimeout=void 0,this._rpcEndpoint=void 0,this._rpcWsEndpoint=void 0,this._rpcClient=void 0,this._rpcRequest=void 0,this._rpcBatchRequest=void 0,this._rpcWebSocket=void 0,this._rpcWebSocketConnected=!1,this._rpcWebSocketHeartbeat=null,this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketGeneration=0,this._disableBlockhashCaching=!1,this._pollingBlockhash=!1,this._blockhashInfo={latestBlockhash:null,lastFetch:0,transactionSignatures:[],simulatedSignatures:[]},this._nextClientSubscriptionId=0,this._subscriptionDisposeFunctionsByClientSubscriptionId={},this._subscriptionHashByClientSubscriptionId={},this._subscriptionStateChangeCallbacksByHash={},this._subscriptionCallbacksByServerSubscriptionId={},this._subscriptionsByHash={},this._subscriptionsAutoDisposedByRpc=new Set,this.getBlockHeight=(()=>{const u={};return async l=>{const{commitment:w,config:y}=fe(l),h=this._buildArgs([],w,void 0,y),m=Ls(h);return u[m]=u[m]??(async()=>{try{const p=await this._rpcRequest("getBlockHeight",h),b=O(p,J(f()));if("error"in b)throw new z(b.error,"failed to get block height information");return b.result}finally{delete u[m]}})(),await u[m]}})();let r,s,o,i,a,c;t&&typeof t=="string"?this._commitment=t:t&&(this._commitment=t.commitment,this._confirmTransactionInitialTimeout=t.confirmTransactionInitialTimeout,r=t.wsEndpoint,s=t.httpHeaders,o=t.fetch,i=t.fetchMiddleware,a=t.disableRetryOnRateLimit,c=t.httpAgent),this._rpcEndpoint=vu(e),this._rpcWsEndpoint=r||wu(e),this._rpcClient=Tu(e,s,o,i,a,c),this._rpcRequest=Lu(this._rpcClient),this._rpcBatchRequest=Nu(this._rpcClient),this._rpcWebSocket=new lu(this._rpcWsEndpoint,{autoconnect:!1,max_reconnects:1/0}),this._rpcWebSocket.on("open",this._wsOnOpen.bind(this)),this._rpcWebSocket.on("error",this._wsOnError.bind(this)),this._rpcWebSocket.on("close",this._wsOnClose.bind(this)),this._rpcWebSocket.on("accountNotification",this._wsOnAccountNotification.bind(this)),this._rpcWebSocket.on("programNotification",this._wsOnProgramAccountNotification.bind(this)),this._rpcWebSocket.on("slotNotification",this._wsOnSlotNotification.bind(this)),this._rpcWebSocket.on("slotsUpdatesNotification",this._wsOnSlotUpdatesNotification.bind(this)),this._rpcWebSocket.on("signatureNotification",this._wsOnSignatureNotification.bind(this)),this._rpcWebSocket.on("rootNotification",this._wsOnRootNotification.bind(this)),this._rpcWebSocket.on("logsNotification",this._wsOnLogsNotification.bind(this))}get commitment(){return this._commitment}get rpcEndpoint(){return this._rpcEndpoint}async getBalanceAndContext(e,t){const{commitment:r,config:s}=fe(t),o=this._buildArgs([e.toBase58()],r,void 0,s),i=await this._rpcRequest("getBalance",o),a=O(i,ye(f()));if("error"in a)throw new z(a.error,`failed to get balance for ${e.toBase58()}`);return a.result}async getBalance(e,t){return await this.getBalanceAndContext(e,t).then(r=>r.value).catch(r=>{throw new Error("failed to get balance of account "+e.toBase58()+": "+r)})}async getBlockTime(e){const t=await this._rpcRequest("getBlockTime",[e]),r=O(t,J(N(f())));if("error"in r)throw new z(r.error,`failed to get block time for slot ${e}`);return r.result}async getMinimumLedgerSlot(){const e=await this._rpcRequest("minimumLedgerSlot",[]),t=O(e,J(f()));if("error"in t)throw new z(t.error,"failed to get minimum ledger slot");return t.result}async getFirstAvailableBlock(){const e=await this._rpcRequest("getFirstAvailableBlock",[]),t=O(e,zu);if("error"in t)throw new z(t.error,"failed to get first available block");return t.result}async getSupply(e){let t={};typeof e=="string"?t={commitment:e}:e?t={...e,commitment:e&&e.commitment||this.commitment}:t={commitment:this.commitment};const r=await this._rpcRequest("getSupply",[t]),s=O(r,ju);if("error"in s)throw new z(s.error,"failed to get supply");return s.result}async getTokenSupply(e,t){const r=this._buildArgs([e.toBase58()],t),s=await this._rpcRequest("getTokenSupply",r),o=O(s,ye(gn));if("error"in o)throw new z(o.error,"failed to get token supply");return o.result}async getTokenAccountBalance(e,t){const r=this._buildArgs([e.toBase58()],t),s=await this._rpcRequest("getTokenAccountBalance",r),o=O(s,ye(gn));if("error"in o)throw new z(o.error,"failed to get token account balance");return o.result}async getTokenAccountsByOwner(e,t,r){const{commitment:s,config:o}=fe(r);let i=[e.toBase58()];"mint"in t?i.push({mint:t.mint.toBase58()}):i.push({programId:t.programId.toBase58()});const a=this._buildArgs(i,s,"base64",o),c=await this._rpcRequest("getTokenAccountsByOwner",a),u=O(c,$u);if("error"in u)throw new z(u.error,`failed to get token accounts owned by account ${e.toBase58()}`);return u.result}async getParsedTokenAccountsByOwner(e,t,r){let s=[e.toBase58()];"mint"in t?s.push({mint:t.mint.toBase58()}):s.push({programId:t.programId.toBase58()});const o=this._buildArgs(s,r,"jsonParsed"),i=await this._rpcRequest("getTokenAccountsByOwner",o),a=O(i,Gu);if("error"in a)throw new z(a.error,`failed to get token accounts owned by account ${e.toBase58()}`);return a.result}async getLargestAccounts(e){const t={...e,commitment:e&&e.commitment||this.commitment},r=t.filter||t.commitment?[t]:[],s=await this._rpcRequest("getLargestAccounts",r),o=O(s,Wu);if("error"in o)throw new z(o.error,"failed to get largest accounts");return o.result}async getTokenLargestAccounts(e,t){const r=this._buildArgs([e.toBase58()],t),s=await this._rpcRequest("getTokenLargestAccounts",r),o=O(s,Hu);if("error"in o)throw new z(o.error,"failed to get token largest accounts");return o.result}async getAccountInfoAndContext(e,t){const{commitment:r,config:s}=fe(t),o=this._buildArgs([e.toBase58()],r,"base64",s),i=await this._rpcRequest("getAccountInfo",o),a=O(i,ye(N(Yt)));if("error"in a)throw new z(a.error,`failed to get info about account ${e.toBase58()}`);return a.result}async getParsedAccountInfo(e,t){const{commitment:r,config:s}=fe(t),o=this._buildArgs([e.toBase58()],r,"jsonParsed",s),i=await this._rpcRequest("getAccountInfo",o),a=O(i,ye(N(mn)));if("error"in a)throw new z(a.error,`failed to get info about account ${e.toBase58()}`);return a.result}async getAccountInfo(e,t){try{return(await this.getAccountInfoAndContext(e,t)).value}catch(r){throw new Error("failed to get info about account "+e.toBase58()+": "+r)}}async getMultipleParsedAccounts(e,t){const{commitment:r,config:s}=fe(t),o=e.map(u=>u.toBase58()),i=this._buildArgs([o],r,"jsonParsed",s),a=await this._rpcRequest("getMultipleAccounts",i),c=O(a,ye(L(N(mn))));if("error"in c)throw new z(c.error,`failed to get info for accounts ${o}`);return c.result}async getMultipleAccountsInfoAndContext(e,t){const{commitment:r,config:s}=fe(t),o=e.map(u=>u.toBase58()),i=this._buildArgs([o],r,"base64",s),a=await this._rpcRequest("getMultipleAccounts",i),c=O(a,ye(L(N(Yt))));if("error"in c)throw new z(c.error,`failed to get info for accounts ${o}`);return c.result}async getMultipleAccountsInfo(e,t){return(await this.getMultipleAccountsInfoAndContext(e,t)).value}async getStakeActivation(e,t,r){const{commitment:s,config:o}=fe(t),i=this._buildArgs([e.toBase58()],s,void 0,{...o,epoch:r??o?.epoch}),a=await this._rpcRequest("getStakeActivation",i),c=O(a,J(Xu));if("error"in c)throw new z(c.error,`failed to get Stake Activation ${e.toBase58()}`);return c.result}async getProgramAccounts(e,t){const{commitment:r,config:s}=fe(t),{encoding:o,...i}=s||{},a=this._buildArgs([e.toBase58()],r,o||"base64",i),c=await this._rpcRequest("getProgramAccounts",a),u=O(c,J(L(Vu)));if("error"in u)throw new z(u.error,`failed to get accounts owned by program ${e.toBase58()}`);return u.result}async getParsedProgramAccounts(e,t){const{commitment:r,config:s}=fe(t),o=this._buildArgs([e.toBase58()],r,"jsonParsed",s),i=await this._rpcRequest("getProgramAccounts",o),a=O(i,J(L(Zu)));if("error"in a)throw new z(a.error,`failed to get accounts owned by program ${e.toBase58()}`);return a.result}async confirmTransaction(e,t){let r;if(typeof e=="string")r=e;else{const o=e;if(o.abortSignal?.aborted)return Promise.reject(o.abortSignal.reason);r=o.signature}let s;try{s=ie.decode(r)}catch{throw new Error("signature must be base58 encoded: "+r)}return de(s.length===64,"signature has invalid length"),typeof e=="string"?await this.confirmTransactionUsingLegacyTimeoutStrategy({commitment:t||this.commitment,signature:r}):"lastValidBlockHeight"in e?await this.confirmTransactionUsingBlockHeightExceedanceStrategy({commitment:t||this.commitment,strategy:e}):await this.confirmTransactionUsingDurableNonceStrategy({commitment:t||this.commitment,strategy:e})}getCancellationPromise(e){return new Promise((t,r)=>{e!=null&&(e.aborted?r(e.reason):e.addEventListener("abort",()=>{r(e.reason)}))})}getTransactionConfirmationPromise({commitment:e,signature:t}){let r,s,o=!1;const i=new Promise((c,u)=>{try{r=this.onSignature(t,(w,y)=>{r=void 0;const h={context:y,value:w};c({__type:Ye.PROCESSED,response:h})},e);const l=new Promise(w=>{r==null?w():s=this._onSubscriptionStateChange(r,y=>{y==="subscribed"&&w()})});(async()=>{if(await l,o)return;const w=await this.getSignatureStatus(t);if(o||w==null)return;const{context:y,value:h}=w;if(h!=null)if(h?.err)u(h.err);else{switch(e){case"confirmed":case"single":case"singleGossip":{if(h.confirmationStatus==="processed")return;break}case"finalized":case"max":case"root":{if(h.confirmationStatus==="processed"||h.confirmationStatus==="confirmed")return;break}case"processed":case"recent":}o=!0,c({__type:Ye.PROCESSED,response:{context:y,value:h}})}})()}catch(l){u(l)}});return{abortConfirmation:()=>{s&&(s(),s=void 0),r!=null&&(this.removeSignatureListener(r),r=void 0)},confirmationPromise:i}}async confirmTransactionUsingBlockHeightExceedanceStrategy({commitment:e,strategy:{abortSignal:t,lastValidBlockHeight:r,signature:s}}){let o=!1;const i=new Promise(w=>{const y=async()=>{try{return await this.getBlockHeight(e)}catch{return-1}};(async()=>{let h=await y();if(!o){for(;h<=r;)if(await Rt(1e3),o||(h=await y(),o))return;w({__type:Ye.BLOCKHEIGHT_EXCEEDED})}})()}),{abortConfirmation:a,confirmationPromise:c}=this.getTransactionConfirmationPromise({commitment:e,signature:s}),u=this.getCancellationPromise(t);let l;try{const w=await Promise.race([u,c,i]);if(w.__type===Ye.PROCESSED)l=w.response;else throw new Qo(s)}finally{o=!0,a()}return l}async confirmTransactionUsingDurableNonceStrategy({commitment:e,strategy:{abortSignal:t,minContextSlot:r,nonceAccountPubkey:s,nonceValue:o,signature:i}}){let a=!1;const c=new Promise(h=>{let m=o,p=null;const b=async()=>{try{const{context:_,value:E}=await this.getNonceAndContext(s,{commitment:e,minContextSlot:r});return p=_.slot,E?.nonce}catch{return m}};(async()=>{if(m=await b(),!a)for(;;){if(o!==m){h({__type:Ye.NONCE_INVALID,slotInWhichNonceDidAdvance:p});return}if(await Rt(2e3),a||(m=await b(),a))return}})()}),{abortConfirmation:u,confirmationPromise:l}=this.getTransactionConfirmationPromise({commitment:e,signature:i}),w=this.getCancellationPromise(t);let y;try{const h=await Promise.race([w,l,c]);if(h.__type===Ye.PROCESSED)y=h.response;else{let m;for(;;){const p=await this.getSignatureStatus(i);if(p==null)break;if(p.context.slot<(h.slotInWhichNonceDidAdvance??r)){await Rt(400);continue}m=p;break}if(m?.value){const p=e||"finalized",{confirmationStatus:b}=m.value;switch(p){case"processed":case"recent":if(b!=="processed"&&b!=="confirmed"&&b!=="finalized")throw new Ht(i);break;case"confirmed":case"single":case"singleGossip":if(b!=="confirmed"&&b!=="finalized")throw new Ht(i);break;case"finalized":case"max":case"root":if(b!=="finalized")throw new Ht(i);break;default:(_=>{})(p)}y={context:m.context,value:{err:m.value.err}}}else throw new Ht(i)}}finally{a=!0,u()}return y}async confirmTransactionUsingLegacyTimeoutStrategy({commitment:e,signature:t}){let r;const s=new Promise(c=>{let u=this._confirmTransactionInitialTimeout||6e4;switch(e){case"processed":case"recent":case"single":case"confirmed":case"singleGossip":{u=this._confirmTransactionInitialTimeout||3e4;break}}r=setTimeout(()=>c({__type:Ye.TIMED_OUT,timeoutMs:u}),u)}),{abortConfirmation:o,confirmationPromise:i}=this.getTransactionConfirmationPromise({commitment:e,signature:t});let a;try{const c=await Promise.race([i,s]);if(c.__type===Ye.PROCESSED)a=c.response;else throw new ei(t,c.timeoutMs/1e3)}finally{clearTimeout(r),o()}return a}async getClusterNodes(){const e=await this._rpcRequest("getClusterNodes",[]),t=O(e,J(L(ul)));if("error"in t)throw new z(t.error,"failed to get cluster nodes");return t.result}async getVoteAccounts(e){const t=this._buildArgs([],e),r=await this._rpcRequest("getVoteAccounts",t),s=O(r,ll);if("error"in s)throw new z(s.error,"failed to get vote accounts");return s.result}async getSlot(e){const{commitment:t,config:r}=fe(e),s=this._buildArgs([],t,void 0,r),o=await this._rpcRequest("getSlot",s),i=O(o,J(f()));if("error"in i)throw new z(i.error,"failed to get slot");return i.result}async getSlotLeader(e){const{commitment:t,config:r}=fe(e),s=this._buildArgs([],t,void 0,r),o=await this._rpcRequest("getSlotLeader",s),i=O(o,J(P()));if("error"in i)throw new z(i.error,"failed to get slot leader");return i.result}async getSlotLeaders(e,t){const r=[e,t],s=await this._rpcRequest("getSlotLeaders",r),o=O(s,J(L(me)));if("error"in o)throw new z(o.error,"failed to get slot leaders");return o.result}async getSignatureStatus(e,t){const{context:r,value:s}=await this.getSignatureStatuses([e],t);de(s.length===1);const o=s[0];return{context:r,value:o}}async getSignatureStatuses(e,t){const r=[e];t&&r.push(t);const s=await this._rpcRequest("getSignatureStatuses",r),o=O(s,hl);if("error"in o)throw new z(o.error,"failed to get signature status");return o.result}async getTransactionCount(e){const{commitment:t,config:r}=fe(e),s=this._buildArgs([],t,void 0,r),o=await this._rpcRequest("getTransactionCount",s),i=O(o,J(f()));if("error"in i)throw new z(i.error,"failed to get transaction count");return i.result}async getTotalSupply(e){return(await this.getSupply({commitment:e,excludeNonCirculatingAccountsList:!0})).value.total}async getInflationGovernor(e){const t=this._buildArgs([],e),r=await this._rpcRequest("getInflationGovernor",t),s=O(r,Mu);if("error"in s)throw new z(s.error,"failed to get inflation");return s.result}async getInflationReward(e,t,r){const{commitment:s,config:o}=fe(r),i=this._buildArgs([e.map(u=>u.toBase58())],s,void 0,{...o,epoch:t??o?.epoch}),a=await this._rpcRequest("getInflationReward",i),c=O(a,Eu);if("error"in c)throw new z(c.error,"failed to get inflation reward");return c.result}async getInflationRate(){const e=await this._rpcRequest("getInflationRate",[]),t=O(e,Uu);if("error"in t)throw new z(t.error,"failed to get inflation rate");return t.result}async getEpochInfo(e){const{commitment:t,config:r}=fe(e),s=this._buildArgs([],t,void 0,r),o=await this._rpcRequest("getEpochInfo",s),i=O(o,qu);if("error"in i)throw new z(i.error,"failed to get epoch info");return i.result}async getEpochSchedule(){const e=await this._rpcRequest("getEpochSchedule",[]),t=O(e,Du);if("error"in t)throw new z(t.error,"failed to get epoch schedule");const r=t.result;return new cu(r.slotsPerEpoch,r.leaderScheduleSlotOffset,r.warmup,r.firstNormalEpoch,r.firstNormalSlot)}async getLeaderSchedule(){const e=await this._rpcRequest("getLeaderSchedule",[]),t=O(e,Ku);if("error"in t)throw new z(t.error,"failed to get leader schedule");return t.result}async getMinimumBalanceForRentExemption(e,t){const r=this._buildArgs([e],t),s=await this._rpcRequest("getMinimumBalanceForRentExemption",r),o=O(s,pl);return"error"in o?(console.warn("Unable to fetch minimum balance for rent exemption"),0):o.result}async getRecentBlockhashAndContext(e){const t=this._buildArgs([],e),r=await this._rpcRequest("getRecentBlockhash",t),s=O(r,xl);if("error"in s)throw new z(s.error,"failed to get recent blockhash");return s.result}async getRecentPerformanceSamples(e){const t=await this._rpcRequest("getRecentPerformanceSamples",e?[e]:[]),r=O(t,Il);if("error"in r)throw new z(r.error,"failed to get recent performance samples");return r.result}async getFeeCalculatorForBlockhash(e,t){const r=this._buildArgs([e],t),s=await this._rpcRequest("getFeeCalculatorForBlockhash",r),o=O(s,Rl);if("error"in o)throw new z(o.error,"failed to get fee calculator");const{context:i,value:a}=o.result;return{context:i,value:a!==null?a.feeCalculator:null}}async getFeeForMessage(e,t){const r=Nt(e.serialize()).toString("base64"),s=this._buildArgs([r],t),o=await this._rpcRequest("getFeeForMessage",s),i=O(o,ye(N(f())));if("error"in i)throw new z(i.error,"failed to get fee for message");if(i.result===null)throw new Error("invalid blockhash");return i.result}async getRecentPrioritizationFees(e){const t=e?.lockedWritableAccounts?.map(i=>i.toBase58()),r=this._buildArgs(t?.length?[t]:[]),s=await this._rpcRequest("getRecentPrioritizationFees",r),o=O(s,Fu);if("error"in o)throw new z(o.error,"failed to get recent prioritization fees");return o.result}async getRecentBlockhash(e){try{return(await this.getRecentBlockhashAndContext(e)).value}catch(t){throw new Error("failed to get recent blockhash: "+t)}}async getLatestBlockhash(e){try{return(await this.getLatestBlockhashAndContext(e)).value}catch(t){throw new Error("failed to get recent blockhash: "+t)}}async getLatestBlockhashAndContext(e){const{commitment:t,config:r}=fe(e),s=this._buildArgs([],t,void 0,r),o=await this._rpcRequest("getLatestBlockhash",s),i=O(o,kl);if("error"in i)throw new z(i.error,"failed to get latest blockhash");return i.result}async getVersion(){const e=await this._rpcRequest("getVersion",[]),t=O(e,J(Cu));if("error"in t)throw new z(t.error,"failed to get version");return t.result}async getGenesisHash(){const e=await this._rpcRequest("getGenesisHash",[]),t=O(e,J(P()));if("error"in t)throw new z(t.error,"failed to get genesis hash");return t.result}async getBlock(e,t){const{commitment:r,config:s}=fe(t),o=this._buildArgsAtLeastConfirmed([e],r,void 0,s),i=await this._rpcRequest("getBlock",o);try{switch(s?.transactionDetails){case"accounts":{const a=O(i,bl);if("error"in a)throw a.error;return a.result}case"none":{const a=O(i,wl);if("error"in a)throw a.error;return a.result}default:{const a=O(i,ml);if("error"in a)throw a.error;const{result:c}=a;return c?{...c,transactions:c.transactions.map(({transaction:u,meta:l,version:w})=>({meta:l,transaction:{...u,message:un(w,u.message)},version:w}))}:null}}}catch(a){throw new z(a,"failed to get confirmed block")}}async getParsedBlock(e,t){const{commitment:r,config:s}=fe(t),o=this._buildArgsAtLeastConfirmed([e],r,"jsonParsed",s),i=await this._rpcRequest("getBlock",o);try{switch(s?.transactionDetails){case"accounts":{const a=O(i,Sl);if("error"in a)throw a.error;return a.result}case"none":{const a=O(i,_l);if("error"in a)throw a.error;return a.result}default:{const a=O(i,vl);if("error"in a)throw a.error;return a.result}}}catch(a){throw new z(a,"failed to get block")}}async getBlockProduction(e){let t,r;if(typeof e=="string")r=e;else if(e){const{commitment:a,...c}=e;r=a,t=c}const s=this._buildArgs([],r,"base64",t),o=await this._rpcRequest("getBlockProduction",s),i=O(o,Ou);if("error"in i)throw new z(i.error,"failed to get block production information");return i.result}async getTransaction(e,t){const{commitment:r,config:s}=fe(t),o=this._buildArgsAtLeastConfirmed([e],r,void 0,s),i=await this._rpcRequest("getTransaction",o),a=O(i,ln);if("error"in a)throw new z(a.error,"failed to get transaction");const c=a.result;return c&&{...c,transaction:{...c.transaction,message:un(c.version,c.transaction.message)}}}async getParsedTransaction(e,t){const{commitment:r,config:s}=fe(t),o=this._buildArgsAtLeastConfirmed([e],r,"jsonParsed",s),i=await this._rpcRequest("getTransaction",o),a=O(i,dr);if("error"in a)throw new z(a.error,"failed to get transaction");return a.result}async getParsedTransactions(e,t){const{commitment:r,config:s}=fe(t),o=e.map(c=>({methodName:"getTransaction",args:this._buildArgsAtLeastConfirmed([c],r,"jsonParsed",s)}));return(await this._rpcBatchRequest(o)).map(c=>{const u=O(c,dr);if("error"in u)throw new z(u.error,"failed to get transactions");return u.result})}async getTransactions(e,t){const{commitment:r,config:s}=fe(t),o=e.map(c=>({methodName:"getTransaction",args:this._buildArgsAtLeastConfirmed([c],r,void 0,s)}));return(await this._rpcBatchRequest(o)).map(c=>{const u=O(c,ln);if("error"in u)throw new z(u.error,"failed to get transactions");const l=u.result;return l&&{...l,transaction:{...l.transaction,message:un(l.version,l.transaction.message)}}})}async getConfirmedBlock(e,t){const r=this._buildArgsAtLeastConfirmed([e],t),s=await this._rpcRequest("getConfirmedBlock",r),o=O(s,El);if("error"in o)throw new z(o.error,"failed to get confirmed block");const i=o.result;if(!i)throw new Error("Confirmed block "+e+" not found");const a={...i,transactions:i.transactions.map(({transaction:c,meta:u})=>{const l=new ct(c.message);return{meta:u,transaction:{...c,message:l}}})};return{...a,transactions:a.transactions.map(({transaction:c,meta:u})=>({meta:u,transaction:ht.populate(c.message,c.signatures)}))}}async getBlocks(e,t,r){const s=this._buildArgsAtLeastConfirmed(t!==void 0?[e,t]:[e],r),o=await this._rpcRequest("getBlocks",s),i=O(o,J(L(f())));if("error"in i)throw new z(i.error,"failed to get blocks");return i.result}async getBlockSignatures(e,t){const r=this._buildArgsAtLeastConfirmed([e],t,void 0,{transactionDetails:"signatures",rewards:!1}),s=await this._rpcRequest("getBlock",r),o=O(s,Ds);if("error"in o)throw new z(o.error,"failed to get block");const i=o.result;if(!i)throw new Error("Block "+e+" not found");return i}async getConfirmedBlockSignatures(e,t){const r=this._buildArgsAtLeastConfirmed([e],t,void 0,{transactionDetails:"signatures",rewards:!1}),s=await this._rpcRequest("getConfirmedBlock",r),o=O(s,Ds);if("error"in o)throw new z(o.error,"failed to get confirmed block");const i=o.result;if(!i)throw new Error("Confirmed block "+e+" not found");return i}async getConfirmedTransaction(e,t){const r=this._buildArgsAtLeastConfirmed([e],t),s=await this._rpcRequest("getConfirmedTransaction",r),o=O(s,ln);if("error"in o)throw new z(o.error,"failed to get transaction");const i=o.result;if(!i)return i;const a=new ct(i.transaction.message),c=i.transaction.signatures;return{...i,transaction:ht.populate(a,c)}}async getParsedConfirmedTransaction(e,t){const r=this._buildArgsAtLeastConfirmed([e],t,"jsonParsed"),s=await this._rpcRequest("getConfirmedTransaction",r),o=O(s,dr);if("error"in o)throw new z(o.error,"failed to get confirmed transaction");return o.result}async getParsedConfirmedTransactions(e,t){const r=e.map(i=>({methodName:"getConfirmedTransaction",args:this._buildArgsAtLeastConfirmed([i],t,"jsonParsed")}));return(await this._rpcBatchRequest(r)).map(i=>{const a=O(i,dr);if("error"in a)throw new z(a.error,"failed to get confirmed transactions");return a.result})}async getConfirmedSignaturesForAddress(e,t,r){let s={},o=await this.getFirstAvailableBlock();for(;!("until"in s)&&(t--,!(t<=0||t<o));)try{const c=await this.getConfirmedBlockSignatures(t,"finalized");c.signatures.length>0&&(s.until=c.signatures[c.signatures.length-1].toString())}catch(c){if(c instanceof Error&&c.message.includes("skipped"))continue;throw c}let i=await this.getSlot("finalized");for(;!("before"in s)&&(r++,!(r>i));)try{const c=await this.getConfirmedBlockSignatures(r);c.signatures.length>0&&(s.before=c.signatures[c.signatures.length-1].toString())}catch(c){if(c instanceof Error&&c.message.includes("skipped"))continue;throw c}return(await this.getConfirmedSignaturesForAddress2(e,s)).map(c=>c.signature)}async getConfirmedSignaturesForAddress2(e,t,r){const s=this._buildArgsAtLeastConfirmed([e.toBase58()],r,void 0,t),o=await this._rpcRequest("getConfirmedSignaturesForAddress2",s),i=O(o,Yu);if("error"in i)throw new z(i.error,"failed to get confirmed signatures for address");return i.result}async getSignaturesForAddress(e,t,r){const s=this._buildArgsAtLeastConfirmed([e.toBase58()],r,void 0,t),o=await this._rpcRequest("getSignaturesForAddress",s),i=O(o,Qu);if("error"in i)throw new z(i.error,"failed to get signatures for address");return i.result}async getAddressLookupTable(e,t){const{context:r,value:s}=await this.getAccountInfoAndContext(e,t);let o=null;return s!==null&&(o=new Us({key:e,state:Us.deserialize(s.data)})),{context:r,value:o}}async getNonceAndContext(e,t){const{context:r,value:s}=await this.getAccountInfoAndContext(e,t);let o=null;return s!==null&&(o=Fn.fromAccountData(s.data)),{context:r,value:o}}async getNonce(e,t){return await this.getNonceAndContext(e,t).then(r=>r.value).catch(r=>{throw new Error("failed to get nonce for account "+e.toBase58()+": "+r)})}async requestAirdrop(e,t){const r=await this._rpcRequest("requestAirdrop",[e.toBase58(),t]),s=O(r,Bl);if("error"in s)throw new z(s.error,`airdrop to ${e.toBase58()} failed`);return s.result}async _blockhashWithExpiryBlockHeight(e){if(!e){for(;this._pollingBlockhash;)await Rt(100);const r=Date.now()-this._blockhashInfo.lastFetch>=bu;if(this._blockhashInfo.latestBlockhash!==null&&!r)return this._blockhashInfo.latestBlockhash}return await this._pollNewBlockhash()}async _pollNewBlockhash(){this._pollingBlockhash=!0;try{const e=Date.now(),t=this._blockhashInfo.latestBlockhash,r=t?t.blockhash:null;for(let s=0;s<50;s++){const o=await this.getLatestBlockhash("finalized");if(r!==o.blockhash)return this._blockhashInfo={latestBlockhash:o,lastFetch:Date.now(),transactionSignatures:[],simulatedSignatures:[]},o;await Rt(pu/2)}throw new Error(`Unable to obtain a new blockhash after ${Date.now()-e}ms`)}finally{this._pollingBlockhash=!1}}async getStakeMinimumDelegation(e){const{commitment:t,config:r}=fe(e),s=this._buildArgs([],t,"base64",r),o=await this._rpcRequest("getStakeMinimumDelegation",s),i=O(o,ye(f()));if("error"in i)throw new z(i.error,"failed to get stake minimum delegation");return i.result}async simulateTransaction(e,t,r){if("message"in e){const p=e.serialize(),b=D.from(p).toString("base64");if(Array.isArray(t)||r!==void 0)throw new Error("Invalid arguments");const _=t||{};_.encoding="base64","commitment"in _||(_.commitment=this.commitment);const E=[b,_],d=await this._rpcRequest("simulateTransaction",E),R=O(d,Fs);if("error"in R)throw new Error("failed to simulate transaction: "+R.error.message);return R.result}let s;if(e instanceof ht){let m=e;s=new ht,s.feePayer=m.feePayer,s.instructions=e.instructions,s.nonceInfo=m.nonceInfo,s.signatures=m.signatures}else s=ht.populate(e),s._message=s._json=void 0;if(t!==void 0&&!Array.isArray(t))throw new Error("Invalid arguments");const o=t;if(s.nonceInfo&&o)s.sign(...o);else{let m=this._disableBlockhashCaching;for(;;){const p=await this._blockhashWithExpiryBlockHeight(m);if(s.lastValidBlockHeight=p.lastValidBlockHeight,s.recentBlockhash=p.blockhash,!o)break;if(s.sign(...o),!s.signature)throw new Error("!signature");const b=s.signature.toString("base64");if(!this._blockhashInfo.simulatedSignatures.includes(b)&&!this._blockhashInfo.transactionSignatures.includes(b)){this._blockhashInfo.simulatedSignatures.push(b);break}else m=!0}}const i=s._compile(),a=i.serialize(),u=s._serialize(a).toString("base64"),l={encoding:"base64",commitment:this.commitment};if(r){const m=(Array.isArray(r)?r:i.nonProgramIds()).map(p=>p.toBase58());l.accounts={encoding:"base64",addresses:m}}o&&(l.sigVerify=!0);const w=[u,l],y=await this._rpcRequest("simulateTransaction",w),h=O(y,Fs);if("error"in h){let m;if("data"in h.error&&(m=h.error.data.logs,m&&Array.isArray(m))){const p=`
    `,b=p+m.join(p);console.error(h.error.message,b)}throw new Ns("failed to simulate transaction: "+h.error.message,m)}return h.result}async sendTransaction(e,t,r){if("version"in e){if(t&&Array.isArray(t))throw new Error("Invalid arguments");const i=e.serialize();return await this.sendRawTransaction(i,t)}if(t===void 0||!Array.isArray(t))throw new Error("Invalid arguments");const s=t;if(e.nonceInfo)e.sign(...s);else{let i=this._disableBlockhashCaching;for(;;){const a=await this._blockhashWithExpiryBlockHeight(i);if(e.lastValidBlockHeight=a.lastValidBlockHeight,e.recentBlockhash=a.blockhash,e.sign(...s),!e.signature)throw new Error("!signature");const c=e.signature.toString("base64");if(this._blockhashInfo.transactionSignatures.includes(c))i=!0;else{this._blockhashInfo.transactionSignatures.push(c);break}}}const o=e.serialize();return await this.sendRawTransaction(o,r)}async sendRawTransaction(e,t){const r=Nt(e).toString("base64");return await this.sendEncodedTransaction(r,t)}async sendEncodedTransaction(e,t){const r={encoding:"base64"},s=t&&t.skipPreflight,o=t&&t.preflightCommitment||this.commitment;t&&t.maxRetries!=null&&(r.maxRetries=t.maxRetries),t&&t.minContextSlot!=null&&(r.minContextSlot=t.minContextSlot),s&&(r.skipPreflight=s),o&&(r.preflightCommitment=o);const i=[e,r],a=await this._rpcRequest("sendTransaction",i),c=O(a,Pl);if("error"in c){let u;throw"data"in c.error&&(u=c.error.data.logs),new Ns("failed to send transaction: "+c.error.message,u)}return c.result}_wsOnOpen(){this._rpcWebSocketConnected=!0,this._rpcWebSocketHeartbeat=setInterval(()=>{(async()=>{try{await this._rpcWebSocket.notify("ping")}catch{}})()},5e3),this._updateSubscriptions()}_wsOnError(e){this._rpcWebSocketConnected=!1,console.error("ws error:",e.message)}_wsOnClose(e){if(this._rpcWebSocketConnected=!1,this._rpcWebSocketGeneration=(this._rpcWebSocketGeneration+1)%Number.MAX_SAFE_INTEGER,this._rpcWebSocketIdleTimeout&&(clearTimeout(this._rpcWebSocketIdleTimeout),this._rpcWebSocketIdleTimeout=null),this._rpcWebSocketHeartbeat&&(clearInterval(this._rpcWebSocketHeartbeat),this._rpcWebSocketHeartbeat=null),e===1e3){this._updateSubscriptions();return}this._subscriptionCallbacksByServerSubscriptionId={},Object.entries(this._subscriptionsByHash).forEach(([t,r])=>{this._setSubscription(t,{...r,state:"pending"})})}_setSubscription(e,t){const r=this._subscriptionsByHash[e]?.state;if(this._subscriptionsByHash[e]=t,r!==t.state){const s=this._subscriptionStateChangeCallbacksByHash[e];s&&s.forEach(o=>{try{o(t.state)}catch{}})}}_onSubscriptionStateChange(e,t){var o;const r=this._subscriptionHashByClientSubscriptionId[e];if(r==null)return()=>{};const s=(o=this._subscriptionStateChangeCallbacksByHash)[r]||(o[r]=new Set);return s.add(t),()=>{s.delete(t),s.size===0&&delete this._subscriptionStateChangeCallbacksByHash[r]}}async _updateSubscriptions(){if(Object.keys(this._subscriptionsByHash).length===0){this._rpcWebSocketConnected&&(this._rpcWebSocketConnected=!1,this._rpcWebSocketIdleTimeout=setTimeout(()=>{this._rpcWebSocketIdleTimeout=null;try{this._rpcWebSocket.close()}catch(r){r instanceof Error&&console.log(`Error when closing socket connection: ${r.message}`)}},500));return}if(this._rpcWebSocketIdleTimeout!==null&&(clearTimeout(this._rpcWebSocketIdleTimeout),this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketConnected=!0),!this._rpcWebSocketConnected){this._rpcWebSocket.connect();return}const e=this._rpcWebSocketGeneration,t=()=>e===this._rpcWebSocketGeneration;await Promise.all(Object.keys(this._subscriptionsByHash).map(async r=>{const s=this._subscriptionsByHash[r];if(s!==void 0)switch(s.state){case"pending":case"unsubscribed":if(s.callbacks.size===0){delete this._subscriptionsByHash[r],s.state==="unsubscribed"&&delete this._subscriptionCallbacksByServerSubscriptionId[s.serverSubscriptionId],await this._updateSubscriptions();return}await(async()=>{const{args:o,method:i}=s;try{this._setSubscription(r,{...s,state:"subscribing"});const a=await this._rpcWebSocket.call(i,o);this._setSubscription(r,{...s,serverSubscriptionId:a,state:"subscribed"}),this._subscriptionCallbacksByServerSubscriptionId[a]=s.callbacks,await this._updateSubscriptions()}catch(a){if(a instanceof Error&&console.error(`${i} error for argument`,o,a.message),!t())return;this._setSubscription(r,{...s,state:"pending"}),await this._updateSubscriptions()}})();break;case"subscribed":s.callbacks.size===0&&await(async()=>{const{serverSubscriptionId:o,unsubscribeMethod:i}=s;if(this._subscriptionsAutoDisposedByRpc.has(o))this._subscriptionsAutoDisposedByRpc.delete(o);else{this._setSubscription(r,{...s,state:"unsubscribing"}),this._setSubscription(r,{...s,state:"unsubscribing"});try{await this._rpcWebSocket.call(i,[o])}catch(a){if(a instanceof Error&&console.error(`${i} error:`,a.message),!t())return;this._setSubscription(r,{...s,state:"subscribed"}),await this._updateSubscriptions();return}}this._setSubscription(r,{...s,state:"unsubscribed"}),await this._updateSubscriptions()})();break}}))}_handleServerNotification(e,t){const r=this._subscriptionCallbacksByServerSubscriptionId[e];r!==void 0&&r.forEach(s=>{try{s(...t)}catch(o){console.error(o)}})}_wsOnAccountNotification(e){const{result:t,subscription:r}=O(e,el);this._handleServerNotification(r,[t.value,t.context])}_makeSubscription(e,t){const r=this._nextClientSubscriptionId++,s=Ls([e.method,t]),o=this._subscriptionsByHash[s];return o===void 0?this._subscriptionsByHash[s]={...e,args:t,callbacks:new Set([e.callback]),state:"pending"}:o.callbacks.add(e.callback),this._subscriptionHashByClientSubscriptionId[r]=s,this._subscriptionDisposeFunctionsByClientSubscriptionId[r]=async()=>{delete this._subscriptionDisposeFunctionsByClientSubscriptionId[r],delete this._subscriptionHashByClientSubscriptionId[r];const i=this._subscriptionsByHash[s];de(i!==void 0,`Could not find a \`Subscription\` when tearing down client subscription #${r}`),i.callbacks.delete(e.callback),await this._updateSubscriptions()},this._updateSubscriptions(),r}onAccountChange(e,t,r){const s=this._buildArgs([e.toBase58()],r||this._commitment||"finalized","base64");return this._makeSubscription({callback:t,method:"accountSubscribe",unsubscribeMethod:"accountUnsubscribe"},s)}async removeAccountChangeListener(e){await this._unsubscribeClientSubscription(e,"account change")}_wsOnProgramAccountNotification(e){const{result:t,subscription:r}=O(e,rl);this._handleServerNotification(r,[{accountId:t.value.pubkey,accountInfo:t.value.account},t.context])}onProgramAccountChange(e,t,r,s){const o=this._buildArgs([e.toBase58()],r||this._commitment||"finalized","base64",s?{filters:s}:void 0);return this._makeSubscription({callback:t,method:"programSubscribe",unsubscribeMethod:"programUnsubscribe"},o)}async removeProgramAccountChangeListener(e){await this._unsubscribeClientSubscription(e,"program account change")}onLogs(e,t,r){const s=this._buildArgs([typeof e=="object"?{mentions:[e.toString()]}:e],r||this._commitment||"finalized");return this._makeSubscription({callback:t,method:"logsSubscribe",unsubscribeMethod:"logsUnsubscribe"},s)}async removeOnLogsListener(e){await this._unsubscribeClientSubscription(e,"logs")}_wsOnLogsNotification(e){const{result:t,subscription:r}=O(e,Ol);this._handleServerNotification(r,[t.value,t.context])}_wsOnSlotNotification(e){const{result:t,subscription:r}=O(e,sl);this._handleServerNotification(r,[t])}onSlotChange(e){return this._makeSubscription({callback:e,method:"slotSubscribe",unsubscribeMethod:"slotUnsubscribe"},[])}async removeSlotChangeListener(e){await this._unsubscribeClientSubscription(e,"slot change")}_wsOnSlotUpdatesNotification(e){const{result:t,subscription:r}=O(e,il);this._handleServerNotification(r,[t])}onSlotUpdate(e){return this._makeSubscription({callback:e,method:"slotsUpdatesSubscribe",unsubscribeMethod:"slotsUpdatesUnsubscribe"},[])}async removeSlotUpdateListener(e){await this._unsubscribeClientSubscription(e,"slot update")}async _unsubscribeClientSubscription(e,t){const r=this._subscriptionDisposeFunctionsByClientSubscriptionId[e];r?await r():console.warn(`Ignored unsubscribe request because an active subscription with id \`${e}\` for '${t}' events could not be found.`)}_buildArgs(e,t,r,s){const o=t||this._commitment;if(o||r||s){let i={};r&&(i.encoding=r),o&&(i.commitment=o),s&&(i=Object.assign(i,s)),e.push(i)}return e}_buildArgsAtLeastConfirmed(e,t,r,s){const o=t||this._commitment;if(o&&!["confirmed","finalized"].includes(o))throw new Error("Using Connection with default commitment: `"+this._commitment+"`, but method requires at least `confirmed`");return this._buildArgs(e,t,r,s)}_wsOnSignatureNotification(e){const{result:t,subscription:r}=O(e,al);t.value!=="receivedSignature"&&this._subscriptionsAutoDisposedByRpc.add(r),this._handleServerNotification(r,t.value==="receivedSignature"?[{type:"received"},t.context]:[{type:"status",result:t.value},t.context])}onSignature(e,t,r){const s=this._buildArgs([e],r||this._commitment||"finalized"),o=this._makeSubscription({callback:(i,a)=>{if(i.type==="status"){t(i.result,a);try{this.removeSignatureListener(o)}catch{}}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},s);return o}onSignatureWithOptions(e,t,r){const{commitment:s,...o}={...r,commitment:r&&r.commitment||this._commitment||"finalized"},i=this._buildArgs([e],s,void 0,o),a=this._makeSubscription({callback:(c,u)=>{t(c,u);try{this.removeSignatureListener(a)}catch{}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},i);return a}async removeSignatureListener(e){await this._unsubscribeClientSubscription(e,"signature result")}_wsOnRootNotification(e){const{result:t,subscription:r}=O(e,cl);this._handleServerNotification(r,[t])}onRootChange(e){return this._makeSubscription({callback:e,method:"rootSubscribe",unsubscribeMethod:"rootUnsubscribe"},[])}async removeRootChangeListener(e){await this._unsubscribeClientSubscription(e,"root change")}}class Gt{constructor(e){this._keypair=void 0,this._keypair=e??Ps()}static generate(){return new Gt(Ps())}static fromSecretKey(e,t){if(e.byteLength!==64)throw new Error("bad secret key size");const r=e.slice(32,64);if(!t||!t.skipValidation){const s=e.slice(0,32),o=pn(s);for(let i=0;i<32;i++)if(r[i]!==o[i])throw new Error("provided secretKey is invalid")}return new Gt({publicKey:r,secretKey:e})}static fromSeed(e){const t=pn(e),r=new Uint8Array(64);return r.set(e),r.set(t,32),new Gt({publicKey:t,secretKey:r})}get publicKey(){return new H(this._keypair.publicKey)}get secretKey(){return new Uint8Array(this._keypair.secretKey)}}Object.freeze({CreateLookupTable:{index:0,layout:K([j("instruction"),Mt("recentSlot"),ne("bumpSeed")])},FreezeLookupTable:{index:1,layout:K([j("instruction")])},ExtendLookupTable:{index:2,layout:K([j("instruction"),Mt(),Ie(ee(),_t(j(),-8),"addresses")])},DeactivateLookupTable:{index:3,layout:K([j("instruction")])},CloseLookupTable:{index:4,layout:K([j("instruction")])}});new H("AddressLookupTab1e1111111111111111111111111");Object.freeze({RequestUnits:{index:0,layout:K([ne("instruction"),j("units"),j("additionalFee")])},RequestHeapFrame:{index:1,layout:K([ne("instruction"),j("bytes")])},SetComputeUnitLimit:{index:2,layout:K([ne("instruction"),j("units")])},SetComputeUnitPrice:{index:3,layout:K([ne("instruction"),Mt("microLamports")])}});new H("ComputeBudget111111111111111111111111111111");K([ne("numSignatures"),ne("padding"),je("signatureOffset"),je("signatureInstructionIndex"),je("publicKeyOffset"),je("publicKeyInstructionIndex"),je("messageDataOffset"),je("messageDataSize"),je("messageInstructionIndex")]);new H("Ed25519SigVerify111111111111111111111111111");to.utils.isValidPrivateKey;to.getPublicKey;K([ne("numSignatures"),je("signatureOffset"),ne("signatureInstructionIndex"),je("ethAddressOffset"),ne("ethAddressInstructionIndex"),je("messageDataOffset"),je("messageDataSize"),ne("messageInstructionIndex"),le(20,"ethAddress"),le(64,"signature"),ne("recoveryId")]);new H("KeccakSecp256k11111111111111111111111111111");new H("StakeConfig11111111111111111111111111111111");class Ks{constructor(e,t,r){this.unixTimestamp=void 0,this.epoch=void 0,this.custodian=void 0,this.unixTimestamp=e,this.epoch=t,this.custodian=r}}Ks.default=new Ks(0,0,H.default);Object.freeze({Initialize:{index:0,layout:K([j("instruction"),Zc(),Xc()])},Authorize:{index:1,layout:K([j("instruction"),ee("newAuthorized"),j("stakeAuthorizationType")])},Delegate:{index:2,layout:K([j("instruction")])},Split:{index:3,layout:K([j("instruction"),Me("lamports")])},Withdraw:{index:4,layout:K([j("instruction"),Me("lamports")])},Deactivate:{index:5,layout:K([j("instruction")])},Merge:{index:7,layout:K([j("instruction")])},AuthorizeWithSeed:{index:8,layout:K([j("instruction"),ee("newAuthorized"),j("stakeAuthorizationType"),Bt("authoritySeed"),ee("authorityOwner")])}});new H("Stake11111111111111111111111111111111111111");Object.freeze({InitializeAccount:{index:0,layout:K([j("instruction"),Yc()])},Authorize:{index:1,layout:K([j("instruction"),ee("newAuthorized"),j("voteAuthorizationType")])},Withdraw:{index:3,layout:K([j("instruction"),Me("lamports")])},AuthorizeWithSeed:{index:10,layout:K([j("instruction"),Qc()])}});new H("Vote111111111111111111111111111111111111111");new H("Va1idator1nfo111111111111111111111111111111");k({name:P(),website:$(P()),details:$(P()),keybaseUsername:$(P())});new H("Vote111111111111111111111111111111111111111");K([ee("nodePubkey"),ee("authorizedWithdrawer"),ne("commission"),be(),Ie(K([be("slot"),j("confirmationCount")]),_t(j(),-8),"votes"),ne("rootSlotValid"),be("rootSlot"),be(),Ie(K([be("epoch"),ee("authorizedVoter")]),_t(j(),-8),"authorizedVoters"),K([Ie(K([ee("authorizedPubkey"),be("epochOfLastAuthorizedSwitch"),be("targetEpoch")]),32,"buf"),be("idx"),ne("isEmpty")],"priorVoters"),be(),Ie(K([be("epoch"),be("credits"),be("prevCredits")]),_t(j(),-8),"epochCredits"),K([be("slot"),be("timestamp")],"lastTimestamp")]);function Ll(n){return(e,t,r,s)=>e.method==="solana_chainId"?(t.result=n,s()):r()}function Nl(n){return(e,t,r,s)=>e.method==="solana_provider_config"?(t.result=n,s()):r()}function pi(n){const{chainId:e}=n;return tr([Ll(e),Nl(n)])}function Ml(n){const{rpcTarget:e}=n,t=Hi({rpcTarget:e});return{networkMiddleware:tr([pi(n),t]),fetchMiddleware:t}}function Ul(n){let{getAccounts:e}=n;return er(async(t,r,s)=>{const{method:o}=t;if(o!=="getAccounts")return s();if(!e)throw new Error("WalletMiddleware - opts.getAccounts not provided");const i=await e(t);r.result=i})}function Fl(n){let{requestAccounts:e}=n;return er(async(t,r,s)=>{const{method:o}=t;if(o!=="requestAccounts")return s();if(!e)throw new Error("WalletMiddleware - opts.requestAccounts not provided");const i=await e(t);r.result=i})}function Qe(n,e){return er(async(t,r,s)=>{const{method:o}=t;if(o!==n)return s();if(!e)throw new Error(`WalletMiddleware - ${n} not provided`);const i=await e(t);r.result=i})}function zn(n){const{getAccounts:e,requestAccounts:t,signTransaction:r,signAndSendTransaction:s,signAllTransactions:o,signMessage:i,getPrivateKey:a,getSecretKey:c}=n;return tr([Fl({requestAccounts:t}),Ul({getAccounts:e}),Qe("signTransaction",r),Qe("signAndSendTransaction",s),Qe("signAllTransactions",o),Qe("signMessage",i),Qe("solanaPrivateKey",a),Qe("private_key",a),Qe("solanaSecretKey",c)])}function ql(n){let{addNewChainConfig:e,switchSolanaChain:t}=n;return tr([Qe("addSolanaChain",e),Qe("switchSolanaChain",t)])}function Dl(n){let{updatePrivatekey:e}=n;return tr([Qe("updateAccount",e)])}function zs(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);e&&(r=r.filter(function(s){return Object.getOwnPropertyDescriptor(n,s).enumerable})),t.push.apply(t,r)}return t}function js(n){for(var e=1;e<arguments.length;e++){var t=arguments[e]!=null?arguments[e]:{};e%2?zs(Object(t),!0).forEach(function(r){Ce(n,r,t[r])}):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):zs(Object(t)).forEach(function(r){Object.defineProperty(n,r,Object.getOwnPropertyDescriptor(t,r))})}return n}class jn extends vn{constructor(e){let{config:t,state:r}=e;super({config:{chainConfig:js(js({},t.chainConfig),{},{chainNamespace:pr.SOLANA})},state:r})}async switchChain(e){throw ji.unsupportedOperation("Chain switching is not supported by this adapter")}async setupProvider(e){const t=new Le,r=this.getProviderHandlers(e),s=zn(r);t.push(s);const o=pi(this.config.chainConfig);t.push(o);const i=this.getInjectedProviderProxy(e);i&&t.push(i);const a=Er(t);this.updateProviderEngineProxy(a),await this.lookupNetwork()}async lookupNetwork(){const{chainConfig:e}=this.config;return this.update({chainId:e.chainId}),e.chainId||""}getInjectedProviderProxy(e){}}const gi=n=>({requestAccounts:async()=>n.publicKey?[ie.encode(n.publicKey.toBytes())]:[],getAccounts:async()=>n.publicKey?[ie.encode(n.publicKey.toBytes())]:[],getPrivateKey:async()=>{throw Z.ethErrors.rpc.methodNotSupported()},getSecretKey:async()=>{throw Z.ethErrors.rpc.methodNotSupported()},signTransaction:async t=>await n.signTransaction(t.params.message),signMessage:async t=>(await n.signMessage(t.params.message,t.params.display)).signature,signAllTransactions:async t=>{var r,s;if(!((r=t.params)!==null&&r!==void 0&&r.message)||!((s=t.params)!==null&&s!==void 0&&s.message.length))throw Z.ethErrors.rpc.invalidParams("message");return await n.signAllTransactions(t.params.message)},signAndSendTransaction:async t=>({signature:(await n.signAndSendTransaction(t.params.message)).signature})});function Hs(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);e&&(r=r.filter(function(s){return Object.getOwnPropertyDescriptor(n,s).enumerable})),t.push.apply(t,r)}return t}function Kl(n){for(var e=1;e<arguments.length;e++){var t=arguments[e]!=null?arguments[e]:{};e%2?Hs(Object(t),!0).forEach(function(r){Ce(n,r,t[r])}):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):Hs(Object(t)).forEach(function(r){Object.defineProperty(n,r,Object.getOwnPropertyDescriptor(t,r))})}return n}function yi(n){return er(async(e,t,r)=>{const s=await n.request(Kl({},e));t.result=s})}class Zl extends jn{getProviderHandlers(e){return gi(e)}getInjectedProviderProxy(e){return yi(e)}}const dn=n=>n.version!==void 0||n instanceof Tt,zl=(n,e)=>({requestAccounts:async()=>{const{data:r}=await n.connect();return[r.publicKey]},getAccounts:async()=>{const{data:r}=await n.connect();return[r.publicKey]},getPrivateKey:async()=>{throw Z.ethErrors.rpc.methodNotSupported()},getSecretKey:async()=>{throw Z.ethErrors.rpc.methodNotSupported()},signTransaction:async r=>{const s=r.params.message;if(!s)throw Z.ethErrors.rpc.invalidRequest({message:"Invalid transaction message"});const o=dn(s)?s.message.serialize():s.serializeMessage(),{data:i}=await n.signTransaction(ie.encode(o));if(!i.publicKey||!i.signature)throw new Error("Invalid signature from slope wallet");const a=new H(i.publicKey),c=ie.decode(i.signature);return s.addSignature(a,D.from(c)),s},signMessage:async r=>{const s=await n.signMessage(r.params.message);return ie.decode(s.data.signature)},signAndSendTransaction:async r=>{const s=e();if(!s)throw Z.ethErrors.provider.custom({message:"Provider is not initialized",code:4902});const o=r.params.message;if(!o)throw Z.ethErrors.rpc.invalidRequest({message:"Invalid transaction message"});const i=dn(o)?o.message.serialize():o.serializeMessage(),{data:a}=await n.signTransaction(ie.encode(i));if(!a.publicKey||!a.signature)throw new Error("Invalid signature from slope wallet");const c=new H(a.publicKey),u=ie.decode(a.signature);o.addSignature(c,D.from(u));const l=await s.request({method:"solana_provider_config",params:[]});return{signature:await new hi(l.rpcTarget).sendRawTransaction(o.serialize())}},signAllTransactions:async r=>{var s,o,i;if(!((s=r.params)!==null&&s!==void 0&&s.message)||!((o=r.params)!==null&&o!==void 0&&o.message.length))throw Z.ethErrors.rpc.invalidParams("message");const a=r.params.message,{length:c}=a,u=[];for(let h=0;h<c;h++){const m=a[h],p=dn(m)?m.message.serialize():m.serializeMessage();u.push(ie.encode(p))}const{msg:l,data:w}=await n.signAllTransactions(u);if(!w.publicKey||((i=w.signatures)===null||i===void 0?void 0:i.length)!==c)throw new Error(l);const y=new H(w.publicKey);for(let h=0;h<c;h++){const m=ie.decode(w.signatures[h]);a[h].addSignature(y,D.from(m))}return a}});class Xl extends jn{getProviderHandlers(e){return zl(e,this.getProviderEngineProxy.bind(this))}}const jl=(n,e)=>{const t=gi(n);return t.signAndSendTransaction=async r=>{const s=e();if(!s)throw Z.ethErrors.provider.custom({message:"Provider is not initialized",code:4902});const o=await n.signTransaction(r.params.message),i=await s.request({method:"solana_provider_config",params:[]});return{signature:await new hi(i.rpcTarget).sendRawTransaction(o.serialize())}},t.signMessage=async r=>await n.signMessage(r.params.message,r.params.display),t};class Yl extends jn{getProviderHandlers(e){return jl(e,this.getProviderEngineProxy.bind(this))}}const Hl=n=>({requestAccounts:async()=>await n.request({method:"solana_requestAccounts",params:{}}),getAccounts:async()=>await n.request({method:"solana_requestAccounts",params:{}}),getPrivateKey:async()=>{throw Z.ethErrors.rpc.methodNotSupported()},getSecretKey:async()=>{throw Z.ethErrors.rpc.methodNotSupported()},signMessage:async t=>{var r;if(!((r=t.params)!==null&&r!==void 0&&r.message))throw Z.ethErrors.rpc.invalidParams("message");return await n.signMessage(t.params.message)},signTransaction:async t=>{var r;if(!((r=t.params)!==null&&r!==void 0&&r.message))throw Z.ethErrors.rpc.invalidParams("message");const s=t.params.message;return await n.signTransaction(s)},signAndSendTransaction:async t=>{var r;if(!((r=t.params)!==null&&r!==void 0&&r.message))throw Z.ethErrors.rpc.invalidParams("message");const s=t.params.message;return{signature:await n.sendTransaction(s)}},signAllTransactions:async t=>{var r,s;if(!((r=t.params)!==null&&r!==void 0&&r.message)||!((s=t.params)!==null&&s!==void 0&&s.message.length))throw Z.ethErrors.rpc.invalidParams("message");const o=t.params.message;return await n.signAllTransactions(o)}});function $s(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);e&&(r=r.filter(function(s){return Object.getOwnPropertyDescriptor(n,s).enumerable})),t.push.apply(t,r)}return t}function fr(n){for(var e=1;e<arguments.length;e++){var t=arguments[e]!=null?arguments[e]:{};e%2?$s(Object(t),!0).forEach(function(r){Ce(n,r,t[r])}):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):$s(Object(t)).forEach(function(r){Object.defineProperty(n,r,Object.getOwnPropertyDescriptor(t,r))})}return n}class Ql extends vn{constructor(e){let{config:t,state:r}=e;super({config:{chainConfig:fr(fr({},t.chainConfig),{},{chainNamespace:pr.SOLANA})},state:r})}async switchChain(e){await this.provider.request({method:"switchSolanaChain",params:[{chainId:e.chainId}]})}async addChain(e){super.addChain(e),await this.provider.request({method:"addNewChainConfig",params:[{chainId:e.chainId,chainName:e.displayName,rpcUrls:[e.rpcTarget],blockExplorerUrls:[e.blockExplorer],nativeCurrency:{name:e.tickerName,symbol:e.ticker,decimals:e.decimals||18}}]})}async setupProvider(e){this.handleInjectedProviderUpdate(e),await this.setupEngine(e)}async lookupNetwork(){if(!this.provider)throw Z.ethErrors.provider.custom({message:"Torus solana provider is not initialized",code:4902});const{chainId:e}=this.config.chainConfig,t=await this.provider.request({method:"solana_chainId"}),r=rs(t.toString())?t:`0x${parseInt(t,10).toString(16)}`;if(e!==r)throw Pt.rpcConnectionError(`Invalid network, net_version is: ${r}, expected: ${e}`);return this.update({chainId:r}),this.provider.emit("connect",{chainId:this.state.chainId}),this.provider.emit("chainChanged",this.state.chainId),this.state.chainId}async setupEngine(e){const t=Hl(e),r=zn(t),s=yi(e),o=new Le;o.push(r),o.push(s);const i=Er(o);this.updateProviderEngineProxy(i),await this.lookupNetwork()}async handleInjectedProviderUpdate(e){e.on("accountsChanged",async t=>{this.provider.emit("accountsChanged",t)}),e.on("chainChanged",async t=>{const r=rs(t)?t:`0x${parseInt(t,10).toString(16)}`;this.configure({chainConfig:fr(fr({},this.config.chainConfig),{},{chainId:r})}),await this.setupProvider(e)})}}async function $l(n){let{privKey:e,getProviderEngineProxy:t}=n;const r=()=>Gt.fromSecretKey(D.from(e,"hex"));if(typeof e!="string")throw Pt.invalidParams("privKey must be a string");const s=r();return{requestAccounts:async()=>[s.publicKey.toBase58()],getAccounts:async()=>[s.publicKey.toBase58()],getPrivateKey:async()=>e,getSecretKey:async()=>ie.encode(s.secretKey),signTransaction:async i=>{var a;if(!((a=i.params)!==null&&a!==void 0&&a.message))throw Z.ethErrors.rpc.invalidParams("message");const c=i.params.message;return c.version!==void 0||c instanceof Tt?c.sign([s]):c.partialSign(s),c},signMessage:async i=>{var a;if(!((a=i.params)!==null&&a!==void 0&&a.message))throw Z.ethErrors.rpc.invalidParams("message");return Gi.sign.detached(i.params.message,s.secretKey)},signAndSendTransaction:async i=>{var a;if(!((a=i.params)!==null&&a!==void 0&&a.message))throw Z.ethErrors.rpc.invalidParams("message");const c=t();if(!c)throw Z.ethErrors.provider.custom({message:"Provider is not initialized",code:4902});const u=i.params.message;return u.version!==void 0||u instanceof Tt?u.sign([s]):u.partialSign(s),{signature:await c.request({method:"sendTransaction",params:[D.from(u.serialize()).toString("base64"),{encoding:"base64",preflightCommitment:"confirmed"}]})}},signAllTransactions:async i=>{var a,c,u;if(!((a=i.params)!==null&&a!==void 0&&a.message)||!((c=i.params)!==null&&c!==void 0&&c.message.length))throw Z.ethErrors.rpc.invalidParams("message");const l=(u=i.params)===null||u===void 0?void 0:u.message;for(const w of l||[]){const y=w;y.version!==void 0||y instanceof Tt?y.sign([s]):y.partialSign(s)}return l}}}function Gs(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);e&&(r=r.filter(function(s){return Object.getOwnPropertyDescriptor(n,s).enumerable})),t.push.apply(t,r)}return t}function Ws(n){for(var e=1;e<arguments.length;e++){var t=arguments[e]!=null?arguments[e]:{};e%2?Gs(Object(t),!0).forEach(function(r){Ce(n,r,t[r])}):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):Gs(Object(t)).forEach(function(r){Object.defineProperty(n,r,Object.getOwnPropertyDescriptor(t,r))})}return n}class Vs extends vn{constructor(e){let{config:t,state:r}=e;super({config:{chainConfig:Ws(Ws({},t.chainConfig),{},{chainNamespace:pr.SOLANA})},state:r})}async enable(){if(!this.state.privateKey)throw Z.ethErrors.provider.custom({message:"Private key is not found in state, plz pass it in constructor state param",code:4902});return await this.setupProvider(this.state.privateKey),this._providerEngineProxy.request({method:"eth_accounts"})}getEd25519Key(e){return $i(e).sk.toString("hex")}async setupProvider(e){const t=await $l({privKey:e,getProviderEngineProxy:this.getProviderEngineProxy.bind(this)}),r=zn(t),s=new Le,{networkMiddleware:o}=Ml(this.config.chainConfig);s.push(this.getChainSwitchMiddleware()),s.push(this.getAccountMiddleware()),s.push(r),s.push(o);const i=Er(s);this.updateProviderEngineProxy(i),await this.lookupNetwork()}async updateAccount(e){if(!this._providerEngineProxy)throw Z.ethErrors.provider.custom({message:"Provider is not initialized",code:4902});await this._providerEngineProxy.request({method:"solanaPrivateKey"})!==e.privateKey&&(await this.setupProvider(e.privateKey),this._providerEngineProxy.emit("accountsChanged",{accounts:await this._providerEngineProxy.request({method:"requestAccounts"})}))}async switchChain(e){if(!this._providerEngineProxy)throw Z.ethErrors.provider.custom({message:"Provider is not initialized",code:4902});const t=this.getChainConfig(e.chainId);this.update({chainId:"loading"}),this.configure({chainConfig:t});const r=await this._providerEngineProxy.request({method:"solanaPrivateKey"});await this.setupProvider(r)}async lookupNetwork(){if(!this._providerEngineProxy)throw Z.ethErrors.provider.custom({message:"Provider is not initialized",code:4902});const e=await this._providerEngineProxy.request({method:"getHealth",params:[]}),{chainConfig:t}=this.config;if(e!=="ok")throw Pt.rpcConnectionError(`Failed to lookup network for following rpc target: ${t.rpcTarget}`);return this.update({chainId:t.chainId}),this.state.chainId!==t.chainId&&(this.provider.emit("chainChanged",this.state.chainId),this.provider.emit("connect",{chainId:this.state.chainId})),this.state.chainId}getChainSwitchMiddleware(){return ql({addNewChainConfig:async r=>{if(!r.params)throw Z.ethErrors.rpc.invalidParams("Missing request params");const{chainId:s,chainName:o,rpcUrls:i,blockExplorerUrls:a,nativeCurrency:c}=r.params;if(!s)throw Z.ethErrors.rpc.invalidParams("Missing chainId in chainParams");if(!i||i.length===0)throw Z.ethErrors.rpc.invalidParams("Missing rpcUrls in chainParams");if(!c)throw Z.ethErrors.rpc.invalidParams("Missing nativeCurrency in chainParams");this.addChain({chainNamespace:pr.SOLANA,chainId:s,ticker:c?.symbol||"SOL",tickerName:c?.name||"Solana",displayName:o,rpcTarget:i[0],blockExplorer:a?.[0]||"",decimals:c?.decimals||9})},switchSolanaChain:async r=>{if(!r.params)throw Z.ethErrors.rpc.invalidParams("Missing request params");if(!r.params.chainId)throw Z.ethErrors.rpc.invalidParams("Missing chainId");await this.switchChain(r.params)}})}getAccountMiddleware(){return Dl({updatePrivatekey:async t=>{if(!t.params)throw Z.ethErrors.rpc.invalidParams("Missing request params");if(!t.params.privateKey)throw Z.ethErrors.rpc.invalidParams("Missing privateKey");const{privateKey:r}=t.params;await this.updateAccount({privateKey:r})}})}}Ce(Vs,"getProviderInstance",async n=>{const e=new Vs({config:{chainConfig:n.chainConfig}});return await e.setupProvider(n.privKey),e});class ed{constructor(e){Ce(this,"provider",void 0),this.provider=e}async requestAccounts(){return await this.provider.request({method:"requestAccounts",params:{}})}async signAndSendTransaction(e){const{signature:t}=await this.provider.request({method:"signAndSendTransaction",params:{message:e}});return{signature:t}}async signTransaction(e){return await this.provider.request({method:"signTransaction",params:{message:e}})}async signAllTransactions(e){return await this.provider.request({method:"signAllTransactions",params:{message:e}})}async signMessage(e){return await this.provider.request({method:"signMessage",params:{message:e}})}async request(e){return await this.provider.request(e)}}export{Zl as PhantomInjectedProvider,Xl as SlopeInjectedProxyProvider,Vs as SolanaPrivateKeyProvider,ed as SolanaWallet,Yl as SolflareInjectedProvider,Ql as TorusInjectedProvider};
