import{j as Io,F as cn,ab as zt,aq as Ro,g as Je,B as K,a8 as Bo,ar as Lo,as as Co,at as To,au as ss,av as Er}from"./index-081e9748.js";import{u as V,w as un,S as Po,v as Oo,f as os,g as Ne,h as xt,n as Ot,i as is,j as Uo,k as Ar,m as Me,l as Fo,F as No,r as as,o as ze,q as qo,s as Do,t as it,x as zo,y as Mo,z as Ko,A as cs,D as Ir}from"./baseControllers.esm-4fdb1339.js";const[Ho,Go]=V.split(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(r=>BigInt(r))),st=new Uint32Array(80),ot=new Uint32Array(80);class ln extends Po{constructor(){super(128,64,16,!1),this.Ah=1779033703,this.Al=-205731576,this.Bh=-1150833019,this.Bl=-2067093701,this.Ch=1013904242,this.Cl=-23791573,this.Dh=-1521486534,this.Dl=1595750129,this.Eh=1359893119,this.El=-1377402159,this.Fh=-1694144372,this.Fl=725511199,this.Gh=528734635,this.Gl=-79577749,this.Hh=1541459225,this.Hl=327033209}get(){const{Ah:e,Al:t,Bh:n,Bl:s,Ch:o,Cl:i,Dh:a,Dl:c,Eh:l,El:u,Fh:w,Fl:v,Gh:g,Gl:y,Hh:p,Hl:m}=this;return[e,t,n,s,o,i,a,c,l,u,w,v,g,y,p,m]}set(e,t,n,s,o,i,a,c,l,u,w,v,g,y,p,m){this.Ah=e|0,this.Al=t|0,this.Bh=n|0,this.Bl=s|0,this.Ch=o|0,this.Cl=i|0,this.Dh=a|0,this.Dl=c|0,this.Eh=l|0,this.El=u|0,this.Fh=w|0,this.Fl=v|0,this.Gh=g|0,this.Gl=y|0,this.Hh=p|0,this.Hl=m|0}process(e,t){for(let d=0;d<16;d++,t+=4)st[d]=e.getUint32(t),ot[d]=e.getUint32(t+=4);for(let d=16;d<80;d++){const R=st[d-15]|0,b=ot[d-15]|0,F=V.rotrSH(R,b,1)^V.rotrSH(R,b,8)^V.shrSH(R,b,7),P=V.rotrSL(R,b,1)^V.rotrSL(R,b,8)^V.shrSL(R,b,7),q=st[d-2]|0,J=ot[d-2]|0,ie=V.rotrSH(q,J,19)^V.rotrBH(q,J,61)^V.shrSH(q,J,6),ae=V.rotrSL(q,J,19)^V.rotrBL(q,J,61)^V.shrSL(q,J,6),de=V.add4L(P,ae,ot[d-7],ot[d-16]),se=V.add4H(de,F,ie,st[d-7],st[d-16]);st[d]=se|0,ot[d]=de|0}let{Ah:n,Al:s,Bh:o,Bl:i,Ch:a,Cl:c,Dh:l,Dl:u,Eh:w,El:v,Fh:g,Fl:y,Gh:p,Gl:m,Hh:I,Hl:_}=this;for(let d=0;d<80;d++){const R=V.rotrSH(w,v,14)^V.rotrSH(w,v,18)^V.rotrBH(w,v,41),b=V.rotrSL(w,v,14)^V.rotrSL(w,v,18)^V.rotrBL(w,v,41),F=w&g^~w&p,P=v&y^~v&m,q=V.add5L(_,b,P,Go[d],ot[d]),J=V.add5H(q,I,R,F,Ho[d],st[d]),ie=q|0,ae=V.rotrSH(n,s,28)^V.rotrBH(n,s,34)^V.rotrBH(n,s,39),de=V.rotrSL(n,s,28)^V.rotrBL(n,s,34)^V.rotrBL(n,s,39),se=n&o^n&a^o&a,Ge=s&i^s&c^i&c;I=p|0,_=m|0,p=g|0,m=y|0,g=w|0,y=v|0,{h:w,l:v}=V.add(l|0,u|0,J|0,ie|0),l=a|0,u=c|0,a=o|0,c=i|0,o=n|0,i=s|0;const C=V.add3L(ie,de,Ge);n=V.add3H(C,J,ae,se),s=C|0}({h:n,l:s}=V.add(this.Ah|0,this.Al|0,n|0,s|0)),{h:o,l:i}=V.add(this.Bh|0,this.Bl|0,o|0,i|0),{h:a,l:c}=V.add(this.Ch|0,this.Cl|0,a|0,c|0),{h:l,l:u}=V.add(this.Dh|0,this.Dl|0,l|0,u|0),{h:w,l:v}=V.add(this.Eh|0,this.El|0,w|0,v|0),{h:g,l:y}=V.add(this.Fh|0,this.Fl|0,g|0,y|0),{h:p,l:m}=V.add(this.Gh|0,this.Gl|0,p|0,m|0),{h:I,l:_}=V.add(this.Hh|0,this.Hl|0,I|0,_|0),this.set(n,s,o,i,a,c,l,u,w,v,g,y,p,m,I,_)}roundClean(){st.fill(0),ot.fill(0)}destroy(){this.buffer.fill(0),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}class Wo extends ln{constructor(){super(),this.Ah=-1942145080,this.Al=424955298,this.Bh=1944164710,this.Bl=-1982016298,this.Ch=502970286,this.Cl=855612546,this.Dh=1738396948,this.Dl=1479516111,this.Eh=258812777,this.El=2077511080,this.Fh=2011393907,this.Fl=79989058,this.Gh=1067287976,this.Gl=1780299464,this.Hh=286451373,this.Hl=-1848208735,this.outputLen=28}}class $o extends ln{constructor(){super(),this.Ah=573645204,this.Al=-64227540,this.Bh=-1621794909,this.Bl=-934517566,this.Ch=596883563,this.Cl=1867755857,this.Dh=-1774684391,this.Dl=1497426621,this.Eh=-1775747358,this.El=-1467023389,this.Fh=-1101128155,this.Fl=1401305490,this.Gh=721525244,this.Gl=746961066,this.Hh=246885852,this.Hl=-2117784414,this.outputLen=32}}class jo extends ln{constructor(){super(),this.Ah=-876896931,this.Al=-1056596264,this.Bh=1654270250,this.Bl=914150663,this.Ch=-1856437926,this.Cl=812702999,this.Dh=355462360,this.Dl=-150054599,this.Eh=1731405415,this.El=-4191439,this.Fh=-1900787065,this.Fl=1750603025,this.Gh=-619958771,this.Gl=1694076839,this.Hh=1203062813,this.Hl=-1090891868,this.outputLen=48}}const Zn=un(()=>new ln);un(()=>new Wo);un(()=>new $o);un(()=>new jo);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const $e=BigInt(0),Fe=BigInt(1),jt=BigInt(2),Vo=BigInt(8),Zo={zip215:!0};function Jo(r){const e=Oo(r);return os(r,{hash:"function",a:"bigint",d:"bigint",randomBytes:"function"},{adjustScalarBytes:"function",domain:"function",uvRatio:"function",mapToCurve:"function"}),Object.freeze({...e})}function Jn(r){const e=Jo(r),{Fp:t,n,prehash:s,hash:o,randomBytes:i,nByteLength:a,h:c}=e,l=jt**BigInt(a*8),u=t.create,w=e.uvRatio||((x,S)=>{try{return{isValid:!0,value:t.sqrt(x*t.inv(S))}}catch{return{isValid:!1,value:$e}}}),v=e.adjustScalarBytes||(x=>x),g=e.domain||((x,S,A)=>{if(S.length||A)throw new Error("Contexts/pre-hash are not supported");return x}),y=x=>typeof x=="bigint"&&$e<x,p=(x,S)=>y(x)&&y(S)&&x<S,m=x=>x===$e||p(x,l);function I(x,S){if(p(x,S))return x;throw new Error(`Expected valid scalar < ${S}, got ${typeof x} ${x}`)}function _(x){return x===$e?x:I(x,n)}const d=new Map;function R(x){if(!(x instanceof b))throw new Error("ExtendedPoint expected")}class b{constructor(S,A,D,$){if(this.ex=S,this.ey=A,this.ez=D,this.et=$,!m(S))throw new Error("x required");if(!m(A))throw new Error("y required");if(!m(D))throw new Error("z required");if(!m($))throw new Error("t required")}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static fromAffine(S){if(S instanceof b)throw new Error("extended point not allowed");const{x:A,y:D}=S||{};if(!m(A)||!m(D))throw new Error("invalid affine point");return new b(A,D,Fe,u(A*D))}static normalizeZ(S){const A=t.invertBatch(S.map(D=>D.ez));return S.map((D,$)=>D.toAffine(A[$])).map(b.fromAffine)}_setWindowSize(S){this._WINDOW_SIZE=S,d.delete(this)}assertValidity(){const{a:S,d:A}=e;if(this.is0())throw new Error("bad point: ZERO");const{ex:D,ey:$,ez:j,et:Y}=this,ee=u(D*D),X=u($*$),oe=u(j*j),Se=u(oe*oe),Ie=u(ee*S),We=u(oe*u(Ie+X)),Le=u(Se+u(A*u(ee*X)));if(We!==Le)throw new Error("bad point: equation left != right (1)");const rt=u(D*$),ft=u(j*Y);if(rt!==ft)throw new Error("bad point: equation left != right (2)")}equals(S){R(S);const{ex:A,ey:D,ez:$}=this,{ex:j,ey:Y,ez:ee}=S,X=u(A*ee),oe=u(j*$),Se=u(D*ee),Ie=u(Y*$);return X===oe&&Se===Ie}is0(){return this.equals(b.ZERO)}negate(){return new b(u(-this.ex),this.ey,this.ez,u(-this.et))}double(){const{a:S}=e,{ex:A,ey:D,ez:$}=this,j=u(A*A),Y=u(D*D),ee=u(jt*u($*$)),X=u(S*j),oe=A+D,Se=u(u(oe*oe)-j-Y),Ie=X+Y,We=Ie-ee,Le=X-Y,rt=u(Se*We),ft=u(Ie*Le),Wt=u(Se*Le),$t=u(We*Ie);return new b(rt,ft,$t,Wt)}add(S){R(S);const{a:A,d:D}=e,{ex:$,ey:j,ez:Y,et:ee}=this,{ex:X,ey:oe,ez:Se,et:Ie}=S;if(A===BigInt(-1)){const br=u((j-$)*(oe+X)),wr=u((j+$)*(oe-X)),Sn=u(wr-br);if(Sn===$e)return this.double();const Sr=u(Y*jt*Ie),vr=u(ee*jt*Se),xr=vr+Sr,_r=wr+br,kr=vr-Sr,_o=u(xr*Sn),ko=u(_r*kr),Eo=u(xr*kr),Ao=u(Sn*_r);return new b(_o,ko,Ao,Eo)}const We=u($*X),Le=u(j*oe),rt=u(ee*D*Ie),ft=u(Y*Se),Wt=u(($+j)*(X+oe)-We-Le),$t=ft-rt,yr=ft+rt,mr=u(Le-A*We),wo=u(Wt*$t),So=u(yr*mr),vo=u(Wt*mr),xo=u($t*yr);return new b(wo,So,xo,vo)}subtract(S){return this.add(S.negate())}wNAF(S){return q.wNAFCached(this,d,S,b.normalizeZ)}multiply(S){const{p:A,f:D}=this.wNAF(I(S,n));return b.normalizeZ([A,D])[0]}multiplyUnsafe(S){let A=_(S);return A===$e?P:this.equals(P)||A===Fe?this:this.equals(F)?this.wNAF(A).p:q.unsafeLadder(this,A)}isSmallOrder(){return this.multiplyUnsafe(c).is0()}isTorsionFree(){return q.unsafeLadder(this,n).is0()}toAffine(S){const{ex:A,ey:D,ez:$}=this,j=this.is0();S==null&&(S=j?Vo:t.inv($));const Y=u(A*S),ee=u(D*S),X=u($*S);if(j)return{x:$e,y:Fe};if(X!==Fe)throw new Error("invZ was invalid");return{x:Y,y:ee}}clearCofactor(){const{h:S}=e;return S===Fe?this:this.multiplyUnsafe(S)}static fromHex(S,A=!1){const{d:D,a:$}=e,j=t.BYTES;S=Ne("pointHex",S,j);const Y=S.slice(),ee=S[j-1];Y[j-1]=ee&-129;const X=xt(Y);X===$e||(A?I(X,l):I(X,t.ORDER));const oe=u(X*X),Se=u(oe-Fe),Ie=u(D*oe-$);let{isValid:We,value:Le}=w(Se,Ie);if(!We)throw new Error("Point.fromHex: invalid y coordinate");const rt=(Le&Fe)===Fe;return(ee&128)!==0!==rt&&(Le=u(-Le)),b.fromAffine({x:Le,y:X})}static fromPrivateKey(S){return ae(S).point}toRawBytes(){const{x:S,y:A}=this.toAffine(),D=Ot(A,t.BYTES);return D[D.length-1]|=S&Fe?128:0,D}toHex(){return is(this.toRawBytes())}}b.BASE=new b(e.Gx,e.Gy,Fe,u(e.Gx*e.Gy)),b.ZERO=new b($e,Fe,Fe,$e);const{BASE:F,ZERO:P}=b,q=Uo(b,a*8);function J(x){return Me(x,n)}function ie(x){return J(xt(x))}function ae(x){const S=a;x=Ne("private key",x,S);const A=Ne("hashed private key",o(x),2*S),D=v(A.slice(0,S)),$=A.slice(S,2*S),j=ie(D),Y=F.multiply(j),ee=Y.toRawBytes();return{head:D,prefix:$,scalar:j,point:Y,pointBytes:ee}}function de(x){return ae(x).pointBytes}function se(x=new Uint8Array,...S){const A=Ar(...S);return ie(o(g(A,Ne("context",x),!!s)))}function Ge(x,S,A={}){x=Ne("message",x),s&&(x=s(x));const{prefix:D,scalar:$,pointBytes:j}=ae(S),Y=se(A.context,D,x),ee=F.multiply(Y).toRawBytes(),X=se(A.context,ee,j,x),oe=J(Y+X*$);_(oe);const Se=Ar(ee,Ot(oe,t.BYTES));return Ne("result",Se,a*2)}const C=Zo;function E(x,S,A,D=C){const{context:$,zip215:j}=D,Y=t.BYTES;x=Ne("signature",x,2*Y),S=Ne("message",S),s&&(S=s(S));const ee=xt(x.slice(Y,2*Y));let X,oe,Se;try{X=b.fromHex(A,j),oe=b.fromHex(x.slice(0,Y),j),Se=F.multiplyUnsafe(ee)}catch{return!1}const Ie=se($,oe.toRawBytes(),X.toRawBytes(),S);return oe.add(X.multiplyUnsafe(Ie)).subtract(Se).clearCofactor().equals(b.ZERO)}return F._setWindowSize(8),{CURVE:e,getPublicKey:de,sign:Ge,verify:E,ExtendedPoint:b,utils:{getExtendedPublicKey:ae,randomPrivateKey:()=>i(t.BYTES),precompute(x=8,S=b.BASE){return S._setWindowSize(x),S.multiply(BigInt(3)),S}}}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Lt=BigInt(0),vn=BigInt(1);function Xo(r){return os(r,{a:"bigint"},{montgomeryBits:"isSafeInteger",nByteLength:"isSafeInteger",adjustScalarBytes:"function",domain:"function",powPminus2:"function",Gu:"bigint"}),Object.freeze({...r})}function Yo(r){const e=Xo(r),{P:t}=e,n=d=>Me(d,t),s=e.montgomeryBits,o=Math.ceil(s/8),i=e.nByteLength,a=e.adjustScalarBytes||(d=>d),c=e.powPminus2||(d=>Fo(d,t-BigInt(2),t));function l(d,R,b){const F=n(d*(R-b));return R=n(R-F),b=n(b+F),[R,b]}function u(d){if(typeof d=="bigint"&&Lt<=d&&d<t)return d;throw new Error("Expected valid scalar 0 < scalar < CURVE.P")}const w=(e.a-BigInt(2))/BigInt(4);function v(d,R){const b=u(d),F=u(R),P=b;let q=vn,J=Lt,ie=b,ae=vn,de=Lt,se;for(let C=BigInt(s-1);C>=Lt;C--){const E=F>>C&vn;de^=E,se=l(de,q,ie),q=se[0],ie=se[1],se=l(de,J,ae),J=se[0],ae=se[1],de=E;const B=q+J,x=n(B*B),S=q-J,A=n(S*S),D=x-A,$=ie+ae,j=ie-ae,Y=n(j*B),ee=n($*S),X=Y+ee,oe=Y-ee;ie=n(X*X),ae=n(P*n(oe*oe)),q=n(x*A),J=n(D*(x+n(w*D)))}se=l(de,q,ie),q=se[0],ie=se[1],se=l(de,J,ae),J=se[0],ae=se[1];const Ge=c(J);return n(q*Ge)}function g(d){return Ot(n(d),o)}function y(d){const R=Ne("u coordinate",d,o);return i===o&&(R[i-1]&=127),xt(R)}function p(d){const R=Ne("scalar",d);if(R.length!==o&&R.length!==i)throw new Error(`Expected ${o} or ${i} bytes, got ${R.length}`);return xt(a(R))}function m(d,R){const b=y(R),F=p(d),P=v(b,F);if(P===Lt)throw new Error("Invalid private or public key received");return g(P)}const I=g(e.Gu);function _(d){return m(d,I)}return{scalarMult:m,scalarMultBase:_,getSharedSecret:(d,R)=>m(d,R),getPublicKey:d=>_(d),utils:{randomPrivateKey:()=>e.randomBytes(e.nByteLength)},GuBytes:I}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Ut=BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),Rr=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752"),Qo=BigInt(0),Ve=BigInt(1),Qt=BigInt(2),ei=BigInt(5),Br=BigInt(10),ti=BigInt(20),ni=BigInt(40),Lr=BigInt(80);function us(r){const e=Ut,n=r*r%e*r%e,s=ze(n,Qt,e)*n%e,o=ze(s,Ve,e)*r%e,i=ze(o,ei,e)*o%e,a=ze(i,Br,e)*i%e,c=ze(a,ti,e)*a%e,l=ze(c,ni,e)*c%e,u=ze(l,Lr,e)*l%e,w=ze(u,Lr,e)*l%e,v=ze(w,Br,e)*i%e;return{pow_p_5_8:ze(v,Qt,e)*r%e,b2:n}}function ls(r){return r[0]&=248,r[31]&=127,r[31]|=64,r}function Xn(r,e){const t=Ut,n=Me(e*e*e,t),s=Me(n*n*e,t),o=us(r*s).pow_p_5_8;let i=Me(r*n*o,t);const a=Me(e*i*i,t),c=i,l=Me(i*Rr,t),u=a===r,w=a===Me(-r,t),v=a===Me(-r*Rr,t);return u&&(i=c),(w||v)&&(i=l),it(i,t)&&(i=Me(-i,t)),{isValid:u||w,value:i}}const N=No(Ut,void 0,!0),Yn={a:BigInt(-1),d:BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),Fp:N,n:BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),h:BigInt(8),Gx:BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),Gy:BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),hash:Zn,randomBytes:as,adjustScalarBytes:ls,uvRatio:Xn},he=Jn(Yn);function fs(r,e,t){if(e.length>255)throw new Error("Context is too big");return Mo(Ko("SigEd25519 no Ed25519 collisions"),new Uint8Array([t?1:0,e.length]),e,r)}Jn({...Yn,domain:fs});Jn({...Yn,domain:fs,prehash:Zn});Yo({P:Ut,a:BigInt(486662),montgomeryBits:255,nByteLength:32,Gu:BigInt(9),powPminus2:r=>{const e=Ut,{pow_p_5_8:t,b2:n}=us(r);return Me(ze(t,BigInt(3),e)*n,e)},adjustScalarBytes:ls,randomBytes:as});const ri=(N.ORDER+BigInt(3))/BigInt(8),si=N.pow(Qt,ri),Cr=N.sqrt(N.neg(N.ONE)),oi=(N.ORDER-BigInt(5))/BigInt(8),Tr=BigInt(486662);function ii(r){let e=N.sqr(r);e=N.mul(e,Qt);let t=N.add(e,N.ONE),n=N.neg(Tr),s=N.sqr(t),o=N.mul(s,t),i=N.mul(e,Tr);i=N.mul(i,n),i=N.add(i,s),i=N.mul(i,n);let a=N.sqr(o);s=N.sqr(a),a=N.mul(a,o),a=N.mul(a,i),s=N.mul(s,a);let c=N.pow(s,oi);c=N.mul(c,a);let l=N.mul(c,Cr);s=N.sqr(c),s=N.mul(s,o);let u=N.eql(s,i),w=N.cmov(l,c,u),v=N.mul(n,e),g=N.mul(c,r);g=N.mul(g,si);let y=N.mul(g,Cr),p=N.mul(i,e);s=N.sqr(g),s=N.mul(s,o);let m=N.eql(s,p),I=N.cmov(y,g,m);s=N.sqr(w),s=N.mul(s,o);let _=N.eql(s,i),d=N.cmov(v,n,_),R=N.cmov(I,w,_),b=N.isOdd(R);return R=N.cmov(R,N.neg(R),_!==b),{xMn:d,xMd:t,yMn:R,yMd:Ve}}const ai=qo(N,N.neg(BigInt(486664)));function ci(r){const{xMn:e,xMd:t,yMn:n,yMd:s}=ii(r);let o=N.mul(e,s);o=N.mul(o,ai);let i=N.mul(t,n),a=N.sub(e,t),c=N.add(e,t),l=N.mul(i,c),u=N.eql(l,N.ZERO);o=N.cmov(o,N.ZERO,u),i=N.cmov(i,N.ONE,u),a=N.cmov(a,N.ONE,u),c=N.cmov(c,N.ONE,u);const w=N.invertBatch([i,c]);return{x:N.mul(o,w[0]),y:N.mul(a,w[1])}}Do(he.ExtendedPoint,r=>ci(r[0]),{DST:"edwards25519_XMD:SHA-512_ELL2_RO_",encodeDST:"edwards25519_XMD:SHA-512_ELL2_NU_",p:N.ORDER,m:1,k:128,expand:"xmd",hash:Zn});function xn(r){if(!(r instanceof Ce))throw new Error("RistrettoPoint expected")}const Hn=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752"),ui=BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235"),li=BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578"),fi=BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838"),di=BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952"),Pr=r=>Xn(Ve,r),hi=BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"),_n=r=>he.CURVE.Fp.create(xt(r)&hi);function Or(r){const{d:e}=he.CURVE,t=he.CURVE.Fp.ORDER,n=he.CURVE.Fp.create,s=n(Hn*r*r),o=n((s+Ve)*fi);let i=BigInt(-1);const a=n((i-e*s)*n(s+e));let{isValid:c,value:l}=Xn(o,a),u=n(l*r);it(u,t)||(u=n(-u)),c||(l=u),c||(i=s);const w=n(i*(s-Ve)*di-a),v=l*l,g=n((l+l)*a),y=n(w*ui),p=n(Ve-v),m=n(Ve+v);return new he.ExtendedPoint(n(g*m),n(p*y),n(y*m),n(g*p))}class Ce{constructor(e){this.ep=e}static fromAffine(e){return new Ce(he.ExtendedPoint.fromAffine(e))}static hashToCurve(e){e=Ne("ristrettoHash",e,64);const t=_n(e.slice(0,32)),n=Or(t),s=_n(e.slice(32,64)),o=Or(s);return new Ce(n.add(o))}static fromHex(e){e=Ne("ristrettoHex",e,32);const{a:t,d:n}=he.CURVE,s=he.CURVE.Fp.ORDER,o=he.CURVE.Fp.create,i="RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint",a=_n(e);if(!zo(Ot(a,32),e)||it(a,s))throw new Error(i);const c=o(a*a),l=o(Ve+t*c),u=o(Ve-t*c),w=o(l*l),v=o(u*u),g=o(t*n*w-v),{isValid:y,value:p}=Pr(o(g*v)),m=o(p*u),I=o(p*m*g);let _=o((a+a)*m);it(_,s)&&(_=o(-_));const d=o(l*I),R=o(_*d);if(!y||it(R,s)||d===Qo)throw new Error(i);return new Ce(new he.ExtendedPoint(_,d,Ve,R))}toRawBytes(){let{ex:e,ey:t,ez:n,et:s}=this.ep;const o=he.CURVE.Fp.ORDER,i=he.CURVE.Fp.create,a=i(i(n+t)*i(n-t)),c=i(e*t),l=i(c*c),{value:u}=Pr(i(a*l)),w=i(u*a),v=i(u*c),g=i(w*v*s);let y;if(it(s*g,o)){let m=i(t*Hn),I=i(e*Hn);e=m,t=I,y=i(w*li)}else y=v;it(e*g,o)&&(t=i(-t));let p=i((n-t)*y);return it(p,o)&&(p=i(-p)),Ot(p,32)}toHex(){return is(this.toRawBytes())}toString(){return this.toHex()}equals(e){xn(e);const{ex:t,ey:n}=this.ep,{ex:s,ey:o}=e.ep,i=he.CURVE.Fp.create,a=i(t*o)===i(n*s),c=i(n*o)===i(t*s);return a||c}add(e){return xn(e),new Ce(this.ep.add(e.ep))}subtract(e){return xn(e),new Ce(this.ep.subtract(e.ep))}multiply(e){return new Ce(this.ep.multiply(e))}multiplyUnsafe(e){return new Ce(this.ep.multiplyUnsafe(e))}}Ce.BASE=new Ce(he.ExtendedPoint.BASE);Ce.ZERO=new Ce(he.ExtendedPoint.ZERO);var Vt=Io.Buffer;function pi(r){if(r.length>=255)throw new TypeError("Alphabet too long");for(var e=new Uint8Array(256),t=0;t<e.length;t++)e[t]=255;for(var n=0;n<r.length;n++){var s=r.charAt(n),o=s.charCodeAt(0);if(e[o]!==255)throw new TypeError(s+" is ambiguous");e[o]=n}var i=r.length,a=r.charAt(0),c=Math.log(i)/Math.log(256),l=Math.log(256)/Math.log(i);function u(g){if((Array.isArray(g)||g instanceof Uint8Array)&&(g=Vt.from(g)),!Vt.isBuffer(g))throw new TypeError("Expected Buffer");if(g.length===0)return"";for(var y=0,p=0,m=0,I=g.length;m!==I&&g[m]===0;)m++,y++;for(var _=(I-m)*l+1>>>0,d=new Uint8Array(_);m!==I;){for(var R=g[m],b=0,F=_-1;(R!==0||b<p)&&F!==-1;F--,b++)R+=256*d[F]>>>0,d[F]=R%i>>>0,R=R/i>>>0;if(R!==0)throw new Error("Non-zero carry");p=b,m++}for(var P=_-p;P!==_&&d[P]===0;)P++;for(var q=a.repeat(y);P<_;++P)q+=r.charAt(d[P]);return q}function w(g){if(typeof g!="string")throw new TypeError("Expected String");if(g.length===0)return Vt.alloc(0);for(var y=0,p=0,m=0;g[y]===a;)p++,y++;for(var I=(g.length-y)*c+1>>>0,_=new Uint8Array(I);g[y];){var d=e[g.charCodeAt(y)];if(d===255)return;for(var R=0,b=I-1;(d!==0||R<m)&&b!==-1;b--,R++)d+=i*_[b]>>>0,_[b]=d%256>>>0,d=d/256>>>0;if(d!==0)throw new Error("Non-zero carry");m=R,y++}for(var F=I-m;F!==I&&_[F]===0;)F++;var P=Vt.allocUnsafe(p+(I-F));P.fill(0,0,p);for(var q=p;F!==I;)P[q++]=_[F++];return P}function v(g){var y=w(g);if(y)return y;throw new Error("Non-base"+i+" character")}return{encode:u,decodeUnsafe:w,decode:v}}var gi=pi,yi=gi,mi="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",ds=yi(mi);const we=cn(ds);var be={};function et(r,e,t){return e<=r&&r<=t}function fn(r){if(r===void 0)return{};if(r===Object(r))return r;throw TypeError("Could not convert argument to dictionary")}function bi(r){for(var e=String(r),t=e.length,n=0,s=[];n<t;){var o=e.charCodeAt(n);if(o<55296||o>57343)s.push(o);else if(56320<=o&&o<=57343)s.push(65533);else if(55296<=o&&o<=56319)if(n===t-1)s.push(65533);else{var i=r.charCodeAt(n+1);if(56320<=i&&i<=57343){var a=o&1023,c=i&1023;s.push(65536+(a<<10)+c),n+=1}else s.push(65533)}n+=1}return s}function wi(r){for(var e="",t=0;t<r.length;++t){var n=r[t];n<=65535?e+=String.fromCharCode(n):(n-=65536,e+=String.fromCharCode((n>>10)+55296,(n&1023)+56320))}return e}var en=-1;function Qn(r){this.tokens=[].slice.call(r)}Qn.prototype={endOfStream:function(){return!this.tokens.length},read:function(){return this.tokens.length?this.tokens.shift():en},prepend:function(r){if(Array.isArray(r))for(var e=r;e.length;)this.tokens.unshift(e.pop());else this.tokens.unshift(r)},push:function(r){if(Array.isArray(r))for(var e=r;e.length;)this.tokens.push(e.shift());else this.tokens.push(r)}};var kt=-1;function kn(r,e){if(r)throw TypeError("Decoder error");return e||65533}var tn="utf-8";function nn(r,e){if(!(this instanceof nn))return new nn(r,e);if(r=r!==void 0?String(r).toLowerCase():tn,r!==tn)throw new Error("Encoding not supported. Only utf-8 is supported");e=fn(e),this._streaming=!1,this._BOMseen=!1,this._decoder=null,this._fatal=!!e.fatal,this._ignoreBOM=!!e.ignoreBOM,Object.defineProperty(this,"encoding",{value:"utf-8"}),Object.defineProperty(this,"fatal",{value:this._fatal}),Object.defineProperty(this,"ignoreBOM",{value:this._ignoreBOM})}nn.prototype={decode:function(e,t){var n;typeof e=="object"&&e instanceof ArrayBuffer?n=new Uint8Array(e):typeof e=="object"&&"buffer"in e&&e.buffer instanceof ArrayBuffer?n=new Uint8Array(e.buffer,e.byteOffset,e.byteLength):n=new Uint8Array(0),t=fn(t),this._streaming||(this._decoder=new Si({fatal:this._fatal}),this._BOMseen=!1),this._streaming=!!t.stream;for(var s=new Qn(n),o=[],i;!s.endOfStream()&&(i=this._decoder.handler(s,s.read()),i!==kt);)i!==null&&(Array.isArray(i)?o.push.apply(o,i):o.push(i));if(!this._streaming){do{if(i=this._decoder.handler(s,s.read()),i===kt)break;i!==null&&(Array.isArray(i)?o.push.apply(o,i):o.push(i))}while(!s.endOfStream());this._decoder=null}return o.length&&["utf-8"].indexOf(this.encoding)!==-1&&!this._ignoreBOM&&!this._BOMseen&&(o[0]===65279?(this._BOMseen=!0,o.shift()):this._BOMseen=!0),wi(o)}};function rn(r,e){if(!(this instanceof rn))return new rn(r,e);if(r=r!==void 0?String(r).toLowerCase():tn,r!==tn)throw new Error("Encoding not supported. Only utf-8 is supported");e=fn(e),this._streaming=!1,this._encoder=null,this._options={fatal:!!e.fatal},Object.defineProperty(this,"encoding",{value:"utf-8"})}rn.prototype={encode:function(e,t){e=e?String(e):"",t=fn(t),this._streaming||(this._encoder=new vi(this._options)),this._streaming=!!t.stream;for(var n=[],s=new Qn(bi(e)),o;!s.endOfStream()&&(o=this._encoder.handler(s,s.read()),o!==kt);)Array.isArray(o)?n.push.apply(n,o):n.push(o);if(!this._streaming){for(;o=this._encoder.handler(s,s.read()),o!==kt;)Array.isArray(o)?n.push.apply(n,o):n.push(o);this._encoder=null}return new Uint8Array(n)}};function Si(r){var e=r.fatal,t=0,n=0,s=0,o=128,i=191;this.handler=function(a,c){if(c===en&&s!==0)return s=0,kn(e);if(c===en)return kt;if(s===0){if(et(c,0,127))return c;if(et(c,194,223))s=1,t=c-192;else if(et(c,224,239))c===224&&(o=160),c===237&&(i=159),s=2,t=c-224;else if(et(c,240,244))c===240&&(o=144),c===244&&(i=143),s=3,t=c-240;else return kn(e);return t=t<<6*s,null}if(!et(c,o,i))return t=s=n=0,o=128,i=191,a.prepend(c),kn(e);if(o=128,i=191,n+=1,t+=c-128<<6*(s-n),n!==s)return null;var l=t;return t=s=n=0,l}}function vi(r){r.fatal,this.handler=function(e,t){if(t===en)return kt;if(et(t,0,127))return t;var n,s;et(t,128,2047)?(n=1,s=192):et(t,2048,65535)?(n=2,s=224):et(t,65536,1114111)&&(n=3,s=240);for(var o=[(t>>6*n)+s];n>0;){var i=t>>6*(n-1);o.push(128|i&63),n-=1}return o}}const xi=Object.freeze(Object.defineProperty({__proto__:null,TextDecoder:nn,TextEncoder:rn},Symbol.toStringTag,{value:"Module"})),_i=zt(xi);var ki=Je&&Je.__createBinding||(Object.create?function(r,e,t,n){n===void 0&&(n=t),Object.defineProperty(r,n,{enumerable:!0,get:function(){return e[t]}})}:function(r,e,t,n){n===void 0&&(n=t),r[n]=e[t]}),Ei=Je&&Je.__setModuleDefault||(Object.create?function(r,e){Object.defineProperty(r,"default",{enumerable:!0,value:e})}:function(r,e){r.default=e}),Xe=Je&&Je.__decorate||function(r,e,t,n){var s=arguments.length,o=s<3?e:n===null?n=Object.getOwnPropertyDescriptor(e,t):n,i;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")o=Reflect.decorate(r,e,t,n);else for(var a=r.length-1;a>=0;a--)(i=r[a])&&(o=(s<3?i(o):s>3?i(e,t,o):i(e,t))||o);return s>3&&o&&Object.defineProperty(e,t,o),o},Ai=Je&&Je.__importStar||function(r){if(r&&r.__esModule)return r;var e={};if(r!=null)for(var t in r)t!=="default"&&Object.hasOwnProperty.call(r,t)&&ki(e,r,t);return Ei(e,r),e},hs=Je&&Je.__importDefault||function(r){return r&&r.__esModule?r:{default:r}};Object.defineProperty(be,"__esModule",{value:!0});var ps=be.deserializeUnchecked=Ss=be.deserialize=ws=be.serialize=be.BinaryReader=be.BinaryWriter=be.BorshError=be.baseDecode=be.baseEncode=void 0;const ct=hs(Ro),gs=hs(ds),Ii=Ai(_i),Ri=typeof TextDecoder!="function"?Ii.TextDecoder:TextDecoder,Bi=new Ri("utf-8",{fatal:!0});function Li(r){return typeof r=="string"&&(r=K.from(r,"utf8")),gs.default.encode(K.from(r))}be.baseEncode=Li;function Ci(r){return K.from(gs.default.decode(r))}be.baseDecode=Ci;const En=1024;class Ae extends Error{constructor(e){super(e),this.fieldPath=[],this.originalMessage=e}addToFieldPath(e){this.fieldPath.splice(0,0,e),this.message=this.originalMessage+": "+this.fieldPath.join(".")}}be.BorshError=Ae;class ys{constructor(){this.buf=K.alloc(En),this.length=0}maybeResize(){this.buf.length<16+this.length&&(this.buf=K.concat([this.buf,K.alloc(En)]))}writeU8(e){this.maybeResize(),this.buf.writeUInt8(e,this.length),this.length+=1}writeU16(e){this.maybeResize(),this.buf.writeUInt16LE(e,this.length),this.length+=2}writeU32(e){this.maybeResize(),this.buf.writeUInt32LE(e,this.length),this.length+=4}writeU64(e){this.maybeResize(),this.writeBuffer(K.from(new ct.default(e).toArray("le",8)))}writeU128(e){this.maybeResize(),this.writeBuffer(K.from(new ct.default(e).toArray("le",16)))}writeU256(e){this.maybeResize(),this.writeBuffer(K.from(new ct.default(e).toArray("le",32)))}writeU512(e){this.maybeResize(),this.writeBuffer(K.from(new ct.default(e).toArray("le",64)))}writeBuffer(e){this.buf=K.concat([K.from(this.buf.subarray(0,this.length)),e,K.alloc(En)]),this.length+=e.length}writeString(e){this.maybeResize();const t=K.from(e,"utf8");this.writeU32(t.length),this.writeBuffer(t)}writeFixedArray(e){this.writeBuffer(K.from(e))}writeArray(e,t){this.maybeResize(),this.writeU32(e.length);for(const n of e)this.maybeResize(),t(n)}toArray(){return this.buf.subarray(0,this.length)}}be.BinaryWriter=ys;function Ye(r,e,t){const n=t.value;t.value=function(...s){try{return n.apply(this,s)}catch(o){if(o instanceof RangeError){const i=o.code;if(["ERR_BUFFER_OUT_OF_BOUNDS","ERR_OUT_OF_RANGE"].indexOf(i)>=0)throw new Ae("Reached the end of buffer when deserializing")}throw o}}}class Ue{constructor(e){this.buf=e,this.offset=0}readU8(){const e=this.buf.readUInt8(this.offset);return this.offset+=1,e}readU16(){const e=this.buf.readUInt16LE(this.offset);return this.offset+=2,e}readU32(){const e=this.buf.readUInt32LE(this.offset);return this.offset+=4,e}readU64(){const e=this.readBuffer(8);return new ct.default(e,"le")}readU128(){const e=this.readBuffer(16);return new ct.default(e,"le")}readU256(){const e=this.readBuffer(32);return new ct.default(e,"le")}readU512(){const e=this.readBuffer(64);return new ct.default(e,"le")}readBuffer(e){if(this.offset+e>this.buf.length)throw new Ae(`Expected buffer length ${e} isn't within bounds`);const t=this.buf.slice(this.offset,this.offset+e);return this.offset+=e,t}readString(){const e=this.readU32(),t=this.readBuffer(e);try{return Bi.decode(t)}catch(n){throw new Ae(`Error decoding UTF-8 string: ${n}`)}}readFixedArray(e){return new Uint8Array(this.readBuffer(e))}readArray(e){const t=this.readU32(),n=Array();for(let s=0;s<t;++s)n.push(e());return n}}Xe([Ye],Ue.prototype,"readU8",null);Xe([Ye],Ue.prototype,"readU16",null);Xe([Ye],Ue.prototype,"readU32",null);Xe([Ye],Ue.prototype,"readU64",null);Xe([Ye],Ue.prototype,"readU128",null);Xe([Ye],Ue.prototype,"readU256",null);Xe([Ye],Ue.prototype,"readU512",null);Xe([Ye],Ue.prototype,"readString",null);Xe([Ye],Ue.prototype,"readFixedArray",null);Xe([Ye],Ue.prototype,"readArray",null);be.BinaryReader=Ue;function ms(r){return r.charAt(0).toUpperCase()+r.slice(1)}function dt(r,e,t,n,s){try{if(typeof n=="string")s[`write${ms(n)}`](t);else if(n instanceof Array)if(typeof n[0]=="number"){if(t.length!==n[0])throw new Ae(`Expecting byte array of length ${n[0]}, but got ${t.length} bytes`);s.writeFixedArray(t)}else if(n.length===2&&typeof n[1]=="number"){if(t.length!==n[1])throw new Ae(`Expecting byte array of length ${n[1]}, but got ${t.length} bytes`);for(let o=0;o<n[1];o++)dt(r,null,t[o],n[0],s)}else s.writeArray(t,o=>{dt(r,e,o,n[0],s)});else if(n.kind!==void 0)switch(n.kind){case"option":{t==null?s.writeU8(0):(s.writeU8(1),dt(r,e,t,n.type,s));break}case"map":{s.writeU32(t.size),t.forEach((o,i)=>{dt(r,e,i,n.key,s),dt(r,e,o,n.value,s)});break}default:throw new Ae(`FieldType ${n} unrecognized`)}else bs(r,t,s)}catch(o){throw o instanceof Ae&&o.addToFieldPath(e),o}}function bs(r,e,t){if(typeof e.borshSerialize=="function"){e.borshSerialize(t);return}const n=r.get(e.constructor);if(!n)throw new Ae(`Class ${e.constructor.name} is missing in schema`);if(n.kind==="struct")n.fields.map(([s,o])=>{dt(r,s,e[s],o,t)});else if(n.kind==="enum"){const s=e[n.field];for(let o=0;o<n.values.length;++o){const[i,a]=n.values[o];if(i===s){t.writeU8(o),dt(r,i,e[i],a,t);break}}}else throw new Ae(`Unexpected schema kind: ${n.kind} for ${e.constructor.name}`)}function Ti(r,e,t=ys){const n=new t;return bs(r,e,n),n.toArray()}var ws=be.serialize=Ti;function ht(r,e,t,n){try{if(typeof t=="string")return n[`read${ms(t)}`]();if(t instanceof Array){if(typeof t[0]=="number")return n.readFixedArray(t[0]);if(typeof t[1]=="number"){const s=[];for(let o=0;o<t[1];o++)s.push(ht(r,null,t[0],n));return s}else return n.readArray(()=>ht(r,e,t[0],n))}if(t.kind==="option")return n.readU8()?ht(r,e,t.type,n):void 0;if(t.kind==="map"){let s=new Map;const o=n.readU32();for(let i=0;i<o;i++){const a=ht(r,e,t.key,n),c=ht(r,e,t.value,n);s.set(a,c)}return s}return er(r,t,n)}catch(s){throw s instanceof Ae&&s.addToFieldPath(e),s}}function er(r,e,t){if(typeof e.borshDeserialize=="function")return e.borshDeserialize(t);const n=r.get(e);if(!n)throw new Ae(`Class ${e.name} is missing in schema`);if(n.kind==="struct"){const s={};for(const[o,i]of r.get(e).fields)s[o]=ht(r,o,i,t);return new e(s)}if(n.kind==="enum"){const s=t.readU8();if(s>=n.values.length)throw new Ae(`Enum index: ${s} is out of range`);const[o,i]=n.values[s],a=ht(r,o,i,t);return new e({[o]:a})}throw new Ae(`Unexpected schema kind: ${n.kind} for ${e.constructor.name}`)}function Pi(r,e,t,n=Ue){const s=new n(t),o=er(r,e,s);if(s.offset<t.length)throw new Ae(`Unexpected ${t.length-s.offset} bytes after deserialized data`);return o}var Ss=be.deserialize=Pi;function Oi(r,e,t,n=Ue){const s=new n(t);return er(r,e,s)}ps=be.deserializeUnchecked=Oi;var h={};Object.defineProperty(h,"__esModule",{value:!0});h.s16=h.s8=h.nu64be=h.u48be=h.u40be=h.u32be=h.u24be=h.u16be=me=h.nu64=h.u48=h.u40=H=h.u32=h.u24=qe=h.u16=ne=h.u8=pt=h.offset=h.greedy=h.Constant=h.UTF8=h.CString=h.Blob=h.Boolean=h.BitField=h.BitStructure=h.VariantLayout=h.Union=h.UnionLayoutDiscriminator=h.UnionDiscriminator=h.Structure=h.Sequence=h.DoubleBE=h.Double=h.FloatBE=h.Float=h.NearInt64BE=h.NearInt64=h.NearUInt64BE=h.NearUInt64=h.IntBE=h.Int=h.UIntBE=h.UInt=h.OffsetLayout=h.GreedyCount=h.ExternalLayout=h.bindConstructorLayout=h.nameWithProperty=h.Layout=h.uint8ArrayToBuffer=h.checkUint8Array=void 0;h.constant=h.utf8=h.cstr=ce=h.blob=h.unionLayoutDiscriminator=h.union=Ee=h.seq=h.bits=z=h.struct=h.f64be=h.f64=h.f32be=h.f32=h.ns64be=h.s48be=h.s40be=h.s32be=h.s24be=h.s16be=Te=h.ns64=h.s48=h.s40=h.s32=h.s24=void 0;const tr=Bo;function It(r){if(!(r instanceof Uint8Array))throw new TypeError("b must be a Uint8Array")}h.checkUint8Array=It;function te(r){return It(r),tr.Buffer.from(r.buffer,r.byteOffset,r.length)}h.uint8ArrayToBuffer=te;class re{constructor(e,t){if(!Number.isInteger(e))throw new TypeError("span must be an integer");this.span=e,this.property=t}makeDestinationObject(){return{}}getSpan(e,t){if(0>this.span)throw new RangeError("indeterminate span");return this.span}replicate(e){const t=Object.create(this.constructor.prototype);return Object.assign(t,this),t.property=e,t}fromArray(e){}}h.Layout=re;function nr(r,e){return e.property?r+"["+e.property+"]":r}h.nameWithProperty=nr;function Ui(r,e){if(typeof r!="function")throw new TypeError("Class must be constructor");if(Object.prototype.hasOwnProperty.call(r,"layout_"))throw new Error("Class is already bound to a layout");if(!(e&&e instanceof re))throw new TypeError("layout must be a Layout");if(Object.prototype.hasOwnProperty.call(e,"boundConstructor_"))throw new Error("layout is already bound to a constructor");r.layout_=e,e.boundConstructor_=r,e.makeDestinationObject=()=>new r,Object.defineProperty(r.prototype,"encode",{value(t,n){return e.encode(this,t,n)},writable:!0}),Object.defineProperty(r,"decode",{value(t,n){return e.decode(t,n)},writable:!0})}h.bindConstructorLayout=Ui;class Re extends re{isCount(){throw new Error("ExternalLayout is abstract")}}h.ExternalLayout=Re;class vs extends Re{constructor(e=1,t){if(!Number.isInteger(e)||0>=e)throw new TypeError("elementSpan must be a (positive) integer");super(-1,t),this.elementSpan=e}isCount(){return!0}decode(e,t=0){It(e);const n=e.length-t;return Math.floor(n/this.elementSpan)}encode(e,t,n){return 0}}h.GreedyCount=vs;class rr extends Re{constructor(e,t=0,n){if(!(e instanceof re))throw new TypeError("layout must be a Layout");if(!Number.isInteger(t))throw new TypeError("offset must be integer or undefined");super(e.span,n||e.property),this.layout=e,this.offset=t}isCount(){return this.layout instanceof De||this.layout instanceof Ke}decode(e,t=0){return this.layout.decode(e,t+this.offset)}encode(e,t,n=0){return this.layout.encode(e,t,n+this.offset)}}h.OffsetLayout=rr;class De extends re{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return te(e).readUIntLE(t,this.span)}encode(e,t,n=0){return te(t).writeUIntLE(e,n,this.span),this.span}}h.UInt=De;class Ke extends re{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return te(e).readUIntBE(t,this.span)}encode(e,t,n=0){return te(t).writeUIntBE(e,n,this.span),this.span}}h.UIntBE=Ke;class gt extends re{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return te(e).readIntLE(t,this.span)}encode(e,t,n=0){return te(t).writeIntLE(e,n,this.span),this.span}}h.Int=gt;class Rt extends re{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return te(e).readIntBE(t,this.span)}encode(e,t,n=0){return te(t).writeIntBE(e,n,this.span),this.span}}h.IntBE=Rt;const Gn=Math.pow(2,32);function dn(r){const e=Math.floor(r/Gn),t=r-e*Gn;return{hi32:e,lo32:t}}function hn(r,e){return r*Gn+e}class xs extends re{constructor(e){super(8,e)}decode(e,t=0){const n=te(e),s=n.readUInt32LE(t),o=n.readUInt32LE(t+4);return hn(o,s)}encode(e,t,n=0){const s=dn(e),o=te(t);return o.writeUInt32LE(s.lo32,n),o.writeUInt32LE(s.hi32,n+4),8}}h.NearUInt64=xs;class _s extends re{constructor(e){super(8,e)}decode(e,t=0){const n=te(e),s=n.readUInt32BE(t),o=n.readUInt32BE(t+4);return hn(s,o)}encode(e,t,n=0){const s=dn(e),o=te(t);return o.writeUInt32BE(s.hi32,n),o.writeUInt32BE(s.lo32,n+4),8}}h.NearUInt64BE=_s;class ks extends re{constructor(e){super(8,e)}decode(e,t=0){const n=te(e),s=n.readUInt32LE(t),o=n.readInt32LE(t+4);return hn(o,s)}encode(e,t,n=0){const s=dn(e),o=te(t);return o.writeUInt32LE(s.lo32,n),o.writeInt32LE(s.hi32,n+4),8}}h.NearInt64=ks;class Es extends re{constructor(e){super(8,e)}decode(e,t=0){const n=te(e),s=n.readInt32BE(t),o=n.readUInt32BE(t+4);return hn(s,o)}encode(e,t,n=0){const s=dn(e),o=te(t);return o.writeInt32BE(s.hi32,n),o.writeUInt32BE(s.lo32,n+4),8}}h.NearInt64BE=Es;class As extends re{constructor(e){super(4,e)}decode(e,t=0){return te(e).readFloatLE(t)}encode(e,t,n=0){return te(t).writeFloatLE(e,n),4}}h.Float=As;class Is extends re{constructor(e){super(4,e)}decode(e,t=0){return te(e).readFloatBE(t)}encode(e,t,n=0){return te(t).writeFloatBE(e,n),4}}h.FloatBE=Is;class Rs extends re{constructor(e){super(8,e)}decode(e,t=0){return te(e).readDoubleLE(t)}encode(e,t,n=0){return te(t).writeDoubleLE(e,n),8}}h.Double=Rs;class Bs extends re{constructor(e){super(8,e)}decode(e,t=0){return te(e).readDoubleBE(t)}encode(e,t,n=0){return te(t).writeDoubleBE(e,n),8}}h.DoubleBE=Bs;class Ls extends re{constructor(e,t,n){if(!(e instanceof re))throw new TypeError("elementLayout must be a Layout");if(!(t instanceof Re&&t.isCount()||Number.isInteger(t)&&0<=t))throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");let s=-1;!(t instanceof Re)&&0<e.span&&(s=t*e.span),super(s,n),this.elementLayout=e,this.count=t}getSpan(e,t=0){if(0<=this.span)return this.span;let n=0,s=this.count;if(s instanceof Re&&(s=s.decode(e,t)),0<this.elementLayout.span)n=s*this.elementLayout.span;else{let o=0;for(;o<s;)n+=this.elementLayout.getSpan(e,t+n),++o}return n}decode(e,t=0){const n=[];let s=0,o=this.count;for(o instanceof Re&&(o=o.decode(e,t));s<o;)n.push(this.elementLayout.decode(e,t)),t+=this.elementLayout.getSpan(e,t),s+=1;return n}encode(e,t,n=0){const s=this.elementLayout,o=e.reduce((i,a)=>i+s.encode(a,t,n+i),0);return this.count instanceof Re&&this.count.encode(e.length,t,n),o}}h.Sequence=Ls;class Cs extends re{constructor(e,t,n){if(!(Array.isArray(e)&&e.reduce((o,i)=>o&&i instanceof re,!0)))throw new TypeError("fields must be array of Layout instances");typeof t=="boolean"&&n===void 0&&(n=t,t=void 0);for(const o of e)if(0>o.span&&o.property===void 0)throw new Error("fields cannot contain unnamed variable-length layout");let s=-1;try{s=e.reduce((o,i)=>o+i.getSpan(),0)}catch{}super(s,t),this.fields=e,this.decodePrefixes=!!n}getSpan(e,t=0){if(0<=this.span)return this.span;let n=0;try{n=this.fields.reduce((s,o)=>{const i=o.getSpan(e,t);return t+=i,s+i},0)}catch{throw new RangeError("indeterminate span")}return n}decode(e,t=0){It(e);const n=this.makeDestinationObject();for(const s of this.fields)if(s.property!==void 0&&(n[s.property]=s.decode(e,t)),t+=s.getSpan(e,t),this.decodePrefixes&&e.length===t)break;return n}encode(e,t,n=0){const s=n;let o=0,i=0;for(const a of this.fields){let c=a.span;if(i=0<c?c:0,a.property!==void 0){const l=e[a.property];l!==void 0&&(i=a.encode(l,t,n),0>c&&(c=a.getSpan(t,n)))}o=n,n+=c}return o+i-s}fromArray(e){const t=this.makeDestinationObject();for(const n of this.fields)n.property!==void 0&&0<e.length&&(t[n.property]=e.shift());return t}layoutFor(e){if(typeof e!="string")throw new TypeError("property must be string");for(const t of this.fields)if(t.property===e)return t}offsetOf(e){if(typeof e!="string")throw new TypeError("property must be string");let t=0;for(const n of this.fields){if(n.property===e)return t;0>n.span?t=-1:0<=t&&(t+=n.span)}}}h.Structure=Cs;class sr{constructor(e){this.property=e}decode(e,t){throw new Error("UnionDiscriminator is abstract")}encode(e,t,n){throw new Error("UnionDiscriminator is abstract")}}h.UnionDiscriminator=sr;class sn extends sr{constructor(e,t){if(!(e instanceof Re&&e.isCount()))throw new TypeError("layout must be an unsigned integer ExternalLayout");super(t||e.property||"variant"),this.layout=e}decode(e,t){return this.layout.decode(e,t)}encode(e,t,n){return this.layout.encode(e,t,n)}}h.UnionLayoutDiscriminator=sn;class or extends re{constructor(e,t,n){let s;if(e instanceof De||e instanceof Ke)s=new sn(new rr(e));else if(e instanceof Re&&e.isCount())s=new sn(e);else if(e instanceof sr)s=e;else throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");if(t===void 0&&(t=null),!(t===null||t instanceof re))throw new TypeError("defaultLayout must be null or a Layout");if(t!==null){if(0>t.span)throw new Error("defaultLayout must have constant span");t.property===void 0&&(t=t.replicate("content"))}let o=-1;t&&(o=t.span,0<=o&&(e instanceof De||e instanceof Ke)&&(o+=s.layout.span)),super(o,n),this.discriminator=s,this.usesPrefixDiscriminator=e instanceof De||e instanceof Ke,this.defaultLayout=t,this.registry={};let i=this.defaultGetSourceVariant.bind(this);this.getSourceVariant=function(a){return i(a)},this.configGetSourceVariant=function(a){i=a.bind(this)}}getSpan(e,t=0){if(0<=this.span)return this.span;const n=this.getVariant(e,t);if(!n)throw new Error("unable to determine span for unrecognized variant");return n.getSpan(e,t)}defaultGetSourceVariant(e){if(Object.prototype.hasOwnProperty.call(e,this.discriminator.property)){if(this.defaultLayout&&this.defaultLayout.property&&Object.prototype.hasOwnProperty.call(e,this.defaultLayout.property))return;const t=this.registry[e[this.discriminator.property]];if(t&&(!t.layout||t.property&&Object.prototype.hasOwnProperty.call(e,t.property)))return t}else for(const t in this.registry){const n=this.registry[t];if(n.property&&Object.prototype.hasOwnProperty.call(e,n.property))return n}throw new Error("unable to infer src variant")}decode(e,t=0){let n;const s=this.discriminator,o=s.decode(e,t),i=this.registry[o];if(i===void 0){const a=this.defaultLayout;let c=0;this.usesPrefixDiscriminator&&(c=s.layout.span),n=this.makeDestinationObject(),n[s.property]=o,n[a.property]=a.decode(e,t+c)}else n=i.decode(e,t);return n}encode(e,t,n=0){const s=this.getSourceVariant(e);if(s===void 0){const o=this.discriminator,i=this.defaultLayout;let a=0;return this.usesPrefixDiscriminator&&(a=o.layout.span),o.encode(e[o.property],t,n),a+i.encode(e[i.property],t,n+a)}return s.encode(e,t,n)}addVariant(e,t,n){const s=new Ts(this,e,t,n);return this.registry[e]=s,s}getVariant(e,t=0){let n;return e instanceof Uint8Array?n=this.discriminator.decode(e,t):n=e,this.registry[n]}}h.Union=or;class Ts extends re{constructor(e,t,n,s){if(!(e instanceof or))throw new TypeError("union must be a Union");if(!Number.isInteger(t)||0>t)throw new TypeError("variant must be a (non-negative) integer");if(typeof n=="string"&&s===void 0&&(s=n,n=null),n){if(!(n instanceof re))throw new TypeError("layout must be a Layout");if(e.defaultLayout!==null&&0<=n.span&&n.span>e.defaultLayout.span)throw new Error("variant span exceeds span of containing union");if(typeof s!="string")throw new TypeError("variant must have a String property")}let o=e.span;0>e.span&&(o=n?n.span:0,0<=o&&e.usesPrefixDiscriminator&&(o+=e.discriminator.layout.span)),super(o,s),this.union=e,this.variant=t,this.layout=n||null}getSpan(e,t=0){if(0<=this.span)return this.span;let n=0;this.union.usesPrefixDiscriminator&&(n=this.union.discriminator.layout.span);let s=0;return this.layout&&(s=this.layout.getSpan(e,t+n)),n+s}decode(e,t=0){const n=this.makeDestinationObject();if(this!==this.union.getVariant(e,t))throw new Error("variant mismatch");let s=0;return this.union.usesPrefixDiscriminator&&(s=this.union.discriminator.layout.span),this.layout?n[this.property]=this.layout.decode(e,t+s):this.property?n[this.property]=!0:this.union.usesPrefixDiscriminator&&(n[this.union.discriminator.property]=this.variant),n}encode(e,t,n=0){let s=0;if(this.union.usesPrefixDiscriminator&&(s=this.union.discriminator.layout.span),this.layout&&!Object.prototype.hasOwnProperty.call(e,this.property))throw new TypeError("variant lacks property "+this.property);this.union.discriminator.encode(this.variant,t,n);let o=s;if(this.layout&&(this.layout.encode(e[this.property],t,n+s),o+=this.layout.getSpan(t,n+s),0<=this.union.span&&o>this.union.span))throw new Error("encoded variant overruns containing union");return o}fromArray(e){if(this.layout)return this.layout.fromArray(e)}}h.VariantLayout=Ts;function wt(r){return 0>r&&(r+=4294967296),r}class ir extends re{constructor(e,t,n){if(!(e instanceof De||e instanceof Ke))throw new TypeError("word must be a UInt or UIntBE layout");if(typeof t=="string"&&n===void 0&&(n=t,t=!1),4<e.span)throw new RangeError("word cannot exceed 32 bits");super(e.span,n),this.word=e,this.msb=!!t,this.fields=[];let s=0;this._packedSetValue=function(o){return s=wt(o),this},this._packedGetValue=function(){return s}}decode(e,t=0){const n=this.makeDestinationObject(),s=this.word.decode(e,t);this._packedSetValue(s);for(const o of this.fields)o.property!==void 0&&(n[o.property]=o.decode(e));return n}encode(e,t,n=0){const s=this.word.decode(t,n);this._packedSetValue(s);for(const o of this.fields)if(o.property!==void 0){const i=e[o.property];i!==void 0&&o.encode(i)}return this.word.encode(this._packedGetValue(),t,n)}addField(e,t){const n=new ar(this,e,t);return this.fields.push(n),n}addBoolean(e){const t=new Ps(this,e);return this.fields.push(t),t}fieldFor(e){if(typeof e!="string")throw new TypeError("property must be string");for(const t of this.fields)if(t.property===e)return t}}h.BitStructure=ir;class ar{constructor(e,t,n){if(!(e instanceof ir))throw new TypeError("container must be a BitStructure");if(!Number.isInteger(t)||0>=t)throw new TypeError("bits must be positive integer");const s=8*e.span,o=e.fields.reduce((i,a)=>i+a.bits,0);if(t+o>s)throw new Error("bits too long for span remainder ("+(s-o)+" of "+s+" remain)");this.container=e,this.bits=t,this.valueMask=(1<<t)-1,t===32&&(this.valueMask=4294967295),this.start=o,this.container.msb&&(this.start=s-o-t),this.wordMask=wt(this.valueMask<<this.start),this.property=n}decode(e,t){const n=this.container._packedGetValue();return wt(n&this.wordMask)>>>this.start}encode(e){if(typeof e!="number"||!Number.isInteger(e)||e!==wt(e&this.valueMask))throw new TypeError(nr("BitField.encode",this)+" value must be integer not exceeding "+this.valueMask);const t=this.container._packedGetValue(),n=wt(e<<this.start);this.container._packedSetValue(wt(t&~this.wordMask)|n)}}h.BitField=ar;let Ps=class extends ar{constructor(e,t){super(e,1,t)}decode(e,t){return!!super.decode(e,t)}encode(e){typeof e=="boolean"&&(e=+e),super.encode(e)}};h.Boolean=Ps;class Os extends re{constructor(e,t){if(!(e instanceof Re&&e.isCount()||Number.isInteger(e)&&0<=e))throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");let n=-1;e instanceof Re||(n=e),super(n,t),this.length=e}getSpan(e,t){let n=this.span;return 0>n&&(n=this.length.decode(e,t)),n}decode(e,t=0){let n=this.span;return 0>n&&(n=this.length.decode(e,t)),te(e).slice(t,t+n)}encode(e,t,n){let s=this.length;if(this.length instanceof Re&&(s=e.length),!(e instanceof Uint8Array&&s===e.length))throw new TypeError(nr("Blob.encode",this)+" requires (length "+s+") Uint8Array as src");if(n+s>t.length)throw new RangeError("encoding overruns Uint8Array");const o=te(e);return te(t).write(o.toString("hex"),n,s,"hex"),this.length instanceof Re&&this.length.encode(s,t,n),s}}h.Blob=Os;class Us extends re{constructor(e){super(-1,e)}getSpan(e,t=0){It(e);let n=t;for(;n<e.length&&e[n]!==0;)n+=1;return 1+n-t}decode(e,t=0){const n=this.getSpan(e,t);return te(e).slice(t,t+n-1).toString("utf-8")}encode(e,t,n=0){typeof e!="string"&&(e=String(e));const s=tr.Buffer.from(e,"utf8"),o=s.length;if(n+o>t.length)throw new RangeError("encoding overruns Buffer");const i=te(t);return s.copy(i,n),i[n+o]=0,o+1}}h.CString=Us;class Fs extends re{constructor(e,t){if(typeof e=="string"&&t===void 0&&(t=e,e=void 0),e===void 0)e=-1;else if(!Number.isInteger(e))throw new TypeError("maxSpan must be an integer");super(-1,t),this.maxSpan=e}getSpan(e,t=0){return It(e),e.length-t}decode(e,t=0){const n=this.getSpan(e,t);if(0<=this.maxSpan&&this.maxSpan<n)throw new RangeError("text length exceeds maxSpan");return te(e).slice(t,t+n).toString("utf-8")}encode(e,t,n=0){typeof e!="string"&&(e=String(e));const s=tr.Buffer.from(e,"utf8"),o=s.length;if(0<=this.maxSpan&&this.maxSpan<o)throw new RangeError("text length exceeds maxSpan");if(n+o>t.length)throw new RangeError("encoding overruns Buffer");return s.copy(te(t),n),o}}h.UTF8=Fs;class Ns extends re{constructor(e,t){super(0,t),this.value=e}decode(e,t){return this.value}encode(e,t,n){return 0}}h.Constant=Ns;h.greedy=(r,e)=>new vs(r,e);var pt=h.offset=(r,e,t)=>new rr(r,e,t),ne=h.u8=r=>new De(1,r),qe=h.u16=r=>new De(2,r);h.u24=r=>new De(3,r);var H=h.u32=r=>new De(4,r);h.u40=r=>new De(5,r);h.u48=r=>new De(6,r);var me=h.nu64=r=>new xs(r);h.u16be=r=>new Ke(2,r);h.u24be=r=>new Ke(3,r);h.u32be=r=>new Ke(4,r);h.u40be=r=>new Ke(5,r);h.u48be=r=>new Ke(6,r);h.nu64be=r=>new _s(r);h.s8=r=>new gt(1,r);h.s16=r=>new gt(2,r);h.s24=r=>new gt(3,r);h.s32=r=>new gt(4,r);h.s40=r=>new gt(5,r);h.s48=r=>new gt(6,r);var Te=h.ns64=r=>new ks(r);h.s16be=r=>new Rt(2,r);h.s24be=r=>new Rt(3,r);h.s32be=r=>new Rt(4,r);h.s40be=r=>new Rt(5,r);h.s48be=r=>new Rt(6,r);h.ns64be=r=>new Es(r);h.f32=r=>new As(r);h.f32be=r=>new Is(r);h.f64=r=>new Rs(r);h.f64be=r=>new Bs(r);var z=h.struct=(r,e,t)=>new Cs(r,e,t);h.bits=(r,e,t)=>new ir(r,e,t);var Ee=h.seq=(r,e,t)=>new Ls(r,e,t);h.union=(r,e,t)=>new or(r,e,t);h.unionLayoutDiscriminator=(r,e)=>new sn(r,e);var ce=h.blob=(r,e)=>new Os(r,e);h.cstr=r=>new Us(r);h.utf8=(r,e)=>new Fs(r,e);h.constant=(r,e)=>new Ns(r,e);var Mt={};Object.defineProperty(Mt,"__esModule",{value:!0});function Fi(r){{const e=K.from(r);e.reverse();const t=e.toString("hex");return t.length===0?BigInt(0):BigInt(`0x${t}`)}}var Ni=Mt.toBigIntLE=Fi;function qi(r){{const e=r.toString("hex");return e.length===0?BigInt(0):BigInt(`0x${e}`)}}Mt.toBigIntBE=qi;function Di(r,e){{const t=r.toString(16),n=K.from(t.padStart(e*2,"0").slice(0,e*2),"hex");return n.reverse(),n}}var zi=Mt.toBufferLE=Di;function Mi(r,e){{const t=r.toString(16);return K.from(t.padStart(e*2,"0").slice(0,e*2),"hex")}}Mt.toBufferBE=Mi;class Ki extends TypeError{constructor(e,t){let n;const{message:s,...o}=e,{path:i}=e,a=i.length===0?s:"At path: "+i.join(".")+" -- "+s;super(a),Object.assign(this,o),this.name=this.constructor.name,this.failures=()=>{var c;return(c=n)!=null?c:n=[e,...t()]}}}function Hi(r){return lt(r)&&typeof r[Symbol.iterator]=="function"}function lt(r){return typeof r=="object"&&r!=null}function He(r){return typeof r=="string"?JSON.stringify(r):""+r}function Gi(r){const{done:e,value:t}=r.next();return e?void 0:t}function Wi(r,e,t,n){if(r===!0)return;r===!1?r={}:typeof r=="string"&&(r={message:r});const{path:s,branch:o}=e,{type:i}=t,{refinement:a,message:c="Expected a value of type `"+i+"`"+(a?" with refinement `"+a+"`":"")+", but received: `"+He(n)+"`"}=r;return{value:n,type:i,refinement:a,key:s[s.length-1],path:s,branch:o,...r,message:c}}function*Ur(r,e,t,n){Hi(r)||(r=[r]);for(const s of r){const o=Wi(s,e,t,n);o&&(yield o)}}function*cr(r,e,t={}){const{path:n=[],branch:s=[r],coerce:o=!1,mask:i=!1}=t,a={path:n,branch:s};if(o&&(r=e.coercer(r,a),i&&e.type!=="type"&&lt(e.schema)&&lt(r)&&!Array.isArray(r)))for(const l in r)e.schema[l]===void 0&&delete r[l];let c=!0;for(const l of e.validator(r,a))c=!1,yield[l,void 0];for(let[l,u,w]of e.entries(r,a)){const v=cr(u,w,{path:l===void 0?n:[...n,l],branch:l===void 0?s:[...s,u],coerce:o,mask:i});for(const g of v)g[0]?(c=!1,yield[g[0],void 0]):o&&(u=g[1],l===void 0?r=u:r instanceof Map?r.set(l,u):r instanceof Set?r.add(u):lt(r)&&(r[l]=u))}if(c)for(const l of e.refiner(r,a))c=!1,yield[l,void 0];c&&(yield[void 0,r])}let Qe=class{constructor(e){const{type:t,schema:n,validator:s,refiner:o,coercer:i=c=>c,entries:a=function*(){}}=e;this.type=t,this.schema=n,this.entries=a,this.coercer=i,s?this.validator=(c,l)=>{const u=s(c,l);return Ur(u,l,this,c)}:this.validator=()=>[],o?this.refiner=(c,l)=>{const u=o(c,l);return Ur(u,l,this,c)}:this.refiner=()=>[]}assert(e){return $i(e,this)}create(e){return T(e,this)}is(e){return qs(e,this)}mask(e){return ji(e,this)}validate(e,t={}){return Kt(e,this,t)}};function $i(r,e){const t=Kt(r,e);if(t[0])throw t[0]}function T(r,e){const t=Kt(r,e,{coerce:!0});if(t[0])throw t[0];return t[1]}function ji(r,e){const t=Kt(r,e,{coerce:!0,mask:!0});if(t[0])throw t[0];return t[1]}function qs(r,e){return!Kt(r,e)[0]}function Kt(r,e,t={}){const n=cr(r,e,t),s=Gi(n);return s[0]?[new Ki(s[0],function*(){for(const i of n)i[0]&&(yield i[0])}),void 0]:[void 0,s[1]]}function yt(r,e){return new Qe({type:r,schema:null,validator:e})}function Vi(){return yt("any",()=>!0)}function O(r){return new Qe({type:"array",schema:r,*entries(e){if(r&&Array.isArray(e))for(const[t,n]of e.entries())yield[t,n,r]},coercer(e){return Array.isArray(e)?e.slice():e},validator(e){return Array.isArray(e)||"Expected an array value, but received: "+He(e)}})}function tt(){return yt("boolean",r=>typeof r=="boolean")}function ur(r){return yt("instance",e=>e instanceof r||"Expected a `"+r.name+"` instance, but received: "+He(e))}function fe(r){const e=He(r),t=typeof r;return new Qe({type:"literal",schema:t==="string"||t==="number"||t==="boolean"?r:null,validator(n){return n===r||"Expected the literal `"+e+"`, but received: "+He(n)}})}function Zi(){return yt("never",()=>!1)}function U(r){return new Qe({...r,validator:(e,t)=>e===null||r.validator(e,t),refiner:(e,t)=>e===null||r.refiner(e,t)})}function f(){return yt("number",r=>typeof r=="number"&&!isNaN(r)||"Expected a number, but received: "+He(r))}function G(r){return new Qe({...r,validator:(e,t)=>e===void 0||r.validator(e,t),refiner:(e,t)=>e===void 0||r.refiner(e,t)})}function Ds(r,e){return new Qe({type:"record",schema:null,*entries(t){if(lt(t))for(const n in t){const s=t[n];yield[n,n,r],yield[n,s,e]}},validator(t){return lt(t)||"Expected an object, but received: "+He(t)}})}function L(){return yt("string",r=>typeof r=="string"||"Expected a string, but received: "+He(r))}function lr(r){const e=Zi();return new Qe({type:"tuple",schema:null,*entries(t){if(Array.isArray(t)){const n=Math.max(r.length,t.length);for(let s=0;s<n;s++)yield[s,t[s],r[s]||e]}},validator(t){return Array.isArray(t)||"Expected an array, but received: "+He(t)}})}function k(r){const e=Object.keys(r);return new Qe({type:"type",schema:r,*entries(t){if(lt(t))for(const n of e)yield[n,t[n],r[n]]},validator(t){return lt(t)||"Expected an object, but received: "+He(t)}})}function Be(r){const e=r.map(t=>t.type).join(" | ");return new Qe({type:"union",schema:null,validator(t,n){const s=[];for(const o of r){const[...i]=cr(t,o,n),[a]=i;if(a[0])for(const[c]of i)c&&s.push(c);else return[]}return["Expected the value to satisfy a union of `"+e+"`, but received: "+He(t),...s]}})}function Ht(){return yt("unknown",()=>!0)}function Gt(r,e,t){return new Qe({...r,coercer:(n,s)=>qs(n,e)?r.coercer(t(n,s),s):r.coercer(n,s)})}var Zt,Ji=new Uint8Array(16);function zs(){if(!Zt&&(Zt=typeof crypto<"u"&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto)||typeof msCrypto<"u"&&typeof msCrypto.getRandomValues=="function"&&msCrypto.getRandomValues.bind(msCrypto),!Zt))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return Zt(Ji)}const Xi=/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;function pn(r){return typeof r=="string"&&Xi.test(r)}var ye=[];for(var An=0;An<256;++An)ye.push((An+256).toString(16).substr(1));function gn(r){var e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:0,t=(ye[r[e+0]]+ye[r[e+1]]+ye[r[e+2]]+ye[r[e+3]]+"-"+ye[r[e+4]]+ye[r[e+5]]+"-"+ye[r[e+6]]+ye[r[e+7]]+"-"+ye[r[e+8]]+ye[r[e+9]]+"-"+ye[r[e+10]]+ye[r[e+11]]+ye[r[e+12]]+ye[r[e+13]]+ye[r[e+14]]+ye[r[e+15]]).toLowerCase();if(!pn(t))throw TypeError("Stringified UUID is invalid");return t}var Fr,In,Rn=0,Bn=0;function Yi(r,e,t){var n=e&&t||0,s=e||new Array(16);r=r||{};var o=r.node||Fr,i=r.clockseq!==void 0?r.clockseq:In;if(o==null||i==null){var a=r.random||(r.rng||zs)();o==null&&(o=Fr=[a[0]|1,a[1],a[2],a[3],a[4],a[5]]),i==null&&(i=In=(a[6]<<8|a[7])&16383)}var c=r.msecs!==void 0?r.msecs:Date.now(),l=r.nsecs!==void 0?r.nsecs:Bn+1,u=c-Rn+(l-Bn)/1e4;if(u<0&&r.clockseq===void 0&&(i=i+1&16383),(u<0||c>Rn)&&r.nsecs===void 0&&(l=0),l>=1e4)throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");Rn=c,Bn=l,In=i,c+=122192928e5;var w=((c&268435455)*1e4+l)%4294967296;s[n++]=w>>>24&255,s[n++]=w>>>16&255,s[n++]=w>>>8&255,s[n++]=w&255;var v=c/4294967296*1e4&268435455;s[n++]=v>>>8&255,s[n++]=v&255,s[n++]=v>>>24&15|16,s[n++]=v>>>16&255,s[n++]=i>>>8|128,s[n++]=i&255;for(var g=0;g<6;++g)s[n+g]=o[g];return e||gn(s)}function Ms(r){if(!pn(r))throw TypeError("Invalid UUID");var e,t=new Uint8Array(16);return t[0]=(e=parseInt(r.slice(0,8),16))>>>24,t[1]=e>>>16&255,t[2]=e>>>8&255,t[3]=e&255,t[4]=(e=parseInt(r.slice(9,13),16))>>>8,t[5]=e&255,t[6]=(e=parseInt(r.slice(14,18),16))>>>8,t[7]=e&255,t[8]=(e=parseInt(r.slice(19,23),16))>>>8,t[9]=e&255,t[10]=(e=parseInt(r.slice(24,36),16))/1099511627776&255,t[11]=e/4294967296&255,t[12]=e>>>24&255,t[13]=e>>>16&255,t[14]=e>>>8&255,t[15]=e&255,t}function Qi(r){r=unescape(encodeURIComponent(r));for(var e=[],t=0;t<r.length;++t)e.push(r.charCodeAt(t));return e}var ea="6ba7b810-9dad-11d1-80b4-00c04fd430c8",ta="6ba7b811-9dad-11d1-80b4-00c04fd430c8";function Ks(r,e,t){function n(s,o,i,a){if(typeof s=="string"&&(s=Qi(s)),typeof o=="string"&&(o=Ms(o)),o.length!==16)throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");var c=new Uint8Array(16+s.length);if(c.set(o),c.set(s,o.length),c=t(c),c[6]=c[6]&15|e,c[8]=c[8]&63|128,i){a=a||0;for(var l=0;l<16;++l)i[a+l]=c[l];return i}return gn(c)}try{n.name=r}catch{}return n.DNS=ea,n.URL=ta,n}function na(r){if(typeof r=="string"){var e=unescape(encodeURIComponent(r));r=new Uint8Array(e.length);for(var t=0;t<e.length;++t)r[t]=e.charCodeAt(t)}return ra(sa(oa(r),r.length*8))}function ra(r){for(var e=[],t=r.length*32,n="0123456789abcdef",s=0;s<t;s+=8){var o=r[s>>5]>>>s%32&255,i=parseInt(n.charAt(o>>>4&15)+n.charAt(o&15),16);e.push(i)}return e}function Hs(r){return(r+64>>>9<<4)+14+1}function sa(r,e){r[e>>5]|=128<<e%32,r[Hs(e)-1]=e;for(var t=1732584193,n=-271733879,s=-1732584194,o=271733878,i=0;i<r.length;i+=16){var a=t,c=n,l=s,u=o;t=ve(t,n,s,o,r[i],7,-680876936),o=ve(o,t,n,s,r[i+1],12,-389564586),s=ve(s,o,t,n,r[i+2],17,606105819),n=ve(n,s,o,t,r[i+3],22,-1044525330),t=ve(t,n,s,o,r[i+4],7,-176418897),o=ve(o,t,n,s,r[i+5],12,1200080426),s=ve(s,o,t,n,r[i+6],17,-1473231341),n=ve(n,s,o,t,r[i+7],22,-45705983),t=ve(t,n,s,o,r[i+8],7,1770035416),o=ve(o,t,n,s,r[i+9],12,-1958414417),s=ve(s,o,t,n,r[i+10],17,-42063),n=ve(n,s,o,t,r[i+11],22,-1990404162),t=ve(t,n,s,o,r[i+12],7,1804603682),o=ve(o,t,n,s,r[i+13],12,-40341101),s=ve(s,o,t,n,r[i+14],17,-1502002290),n=ve(n,s,o,t,r[i+15],22,1236535329),t=xe(t,n,s,o,r[i+1],5,-165796510),o=xe(o,t,n,s,r[i+6],9,-1069501632),s=xe(s,o,t,n,r[i+11],14,643717713),n=xe(n,s,o,t,r[i],20,-373897302),t=xe(t,n,s,o,r[i+5],5,-701558691),o=xe(o,t,n,s,r[i+10],9,38016083),s=xe(s,o,t,n,r[i+15],14,-660478335),n=xe(n,s,o,t,r[i+4],20,-405537848),t=xe(t,n,s,o,r[i+9],5,568446438),o=xe(o,t,n,s,r[i+14],9,-1019803690),s=xe(s,o,t,n,r[i+3],14,-187363961),n=xe(n,s,o,t,r[i+8],20,1163531501),t=xe(t,n,s,o,r[i+13],5,-1444681467),o=xe(o,t,n,s,r[i+2],9,-51403784),s=xe(s,o,t,n,r[i+7],14,1735328473),n=xe(n,s,o,t,r[i+12],20,-1926607734),t=_e(t,n,s,o,r[i+5],4,-378558),o=_e(o,t,n,s,r[i+8],11,-2022574463),s=_e(s,o,t,n,r[i+11],16,1839030562),n=_e(n,s,o,t,r[i+14],23,-35309556),t=_e(t,n,s,o,r[i+1],4,-1530992060),o=_e(o,t,n,s,r[i+4],11,1272893353),s=_e(s,o,t,n,r[i+7],16,-155497632),n=_e(n,s,o,t,r[i+10],23,-1094730640),t=_e(t,n,s,o,r[i+13],4,681279174),o=_e(o,t,n,s,r[i],11,-358537222),s=_e(s,o,t,n,r[i+3],16,-722521979),n=_e(n,s,o,t,r[i+6],23,76029189),t=_e(t,n,s,o,r[i+9],4,-640364487),o=_e(o,t,n,s,r[i+12],11,-421815835),s=_e(s,o,t,n,r[i+15],16,530742520),n=_e(n,s,o,t,r[i+2],23,-995338651),t=ke(t,n,s,o,r[i],6,-198630844),o=ke(o,t,n,s,r[i+7],10,1126891415),s=ke(s,o,t,n,r[i+14],15,-1416354905),n=ke(n,s,o,t,r[i+5],21,-57434055),t=ke(t,n,s,o,r[i+12],6,1700485571),o=ke(o,t,n,s,r[i+3],10,-1894986606),s=ke(s,o,t,n,r[i+10],15,-1051523),n=ke(n,s,o,t,r[i+1],21,-2054922799),t=ke(t,n,s,o,r[i+8],6,1873313359),o=ke(o,t,n,s,r[i+15],10,-30611744),s=ke(s,o,t,n,r[i+6],15,-1560198380),n=ke(n,s,o,t,r[i+13],21,1309151649),t=ke(t,n,s,o,r[i+4],6,-145523070),o=ke(o,t,n,s,r[i+11],10,-1120210379),s=ke(s,o,t,n,r[i+2],15,718787259),n=ke(n,s,o,t,r[i+9],21,-343485551),t=ut(t,a),n=ut(n,c),s=ut(s,l),o=ut(o,u)}return[t,n,s,o]}function oa(r){if(r.length===0)return[];for(var e=r.length*8,t=new Uint32Array(Hs(e)),n=0;n<e;n+=8)t[n>>5]|=(r[n/8]&255)<<n%32;return t}function ut(r,e){var t=(r&65535)+(e&65535),n=(r>>16)+(e>>16)+(t>>16);return n<<16|t&65535}function ia(r,e){return r<<e|r>>>32-e}function yn(r,e,t,n,s,o){return ut(ia(ut(ut(e,r),ut(n,o)),s),t)}function ve(r,e,t,n,s,o,i){return yn(e&t|~e&n,r,e,s,o,i)}function xe(r,e,t,n,s,o,i){return yn(e&n|t&~n,r,e,s,o,i)}function _e(r,e,t,n,s,o,i){return yn(e^t^n,r,e,s,o,i)}function ke(r,e,t,n,s,o,i){return yn(t^(e|~n),r,e,s,o,i)}var aa=Ks("v3",48,na);const ca=aa;function ua(r,e,t){r=r||{};var n=r.random||(r.rng||zs)();if(n[6]=n[6]&15|64,n[8]=n[8]&63|128,e){t=t||0;for(var s=0;s<16;++s)e[t+s]=n[s];return e}return gn(n)}function la(r,e,t,n){switch(r){case 0:return e&t^~e&n;case 1:return e^t^n;case 2:return e&t^e&n^t&n;case 3:return e^t^n}}function Ln(r,e){return r<<e|r>>>32-e}function fa(r){var e=[1518500249,1859775393,2400959708,3395469782],t=[1732584193,4023233417,2562383102,271733878,3285377520];if(typeof r=="string"){var n=unescape(encodeURIComponent(r));r=[];for(var s=0;s<n.length;++s)r.push(n.charCodeAt(s))}else Array.isArray(r)||(r=Array.prototype.slice.call(r));r.push(128);for(var o=r.length/4+2,i=Math.ceil(o/16),a=new Array(i),c=0;c<i;++c){for(var l=new Uint32Array(16),u=0;u<16;++u)l[u]=r[c*64+u*4]<<24|r[c*64+u*4+1]<<16|r[c*64+u*4+2]<<8|r[c*64+u*4+3];a[c]=l}a[i-1][14]=(r.length-1)*8/Math.pow(2,32),a[i-1][14]=Math.floor(a[i-1][14]),a[i-1][15]=(r.length-1)*8&4294967295;for(var w=0;w<i;++w){for(var v=new Uint32Array(80),g=0;g<16;++g)v[g]=a[w][g];for(var y=16;y<80;++y)v[y]=Ln(v[y-3]^v[y-8]^v[y-14]^v[y-16],1);for(var p=t[0],m=t[1],I=t[2],_=t[3],d=t[4],R=0;R<80;++R){var b=Math.floor(R/20),F=Ln(p,5)+la(b,m,I,_)+d+e[b]+v[R]>>>0;d=_,_=I,I=Ln(m,30)>>>0,m=p,p=F}t[0]=t[0]+p>>>0,t[1]=t[1]+m>>>0,t[2]=t[2]+I>>>0,t[3]=t[3]+_>>>0,t[4]=t[4]+d>>>0}return[t[0]>>24&255,t[0]>>16&255,t[0]>>8&255,t[0]&255,t[1]>>24&255,t[1]>>16&255,t[1]>>8&255,t[1]&255,t[2]>>24&255,t[2]>>16&255,t[2]>>8&255,t[2]&255,t[3]>>24&255,t[3]>>16&255,t[3]>>8&255,t[3]&255,t[4]>>24&255,t[4]>>16&255,t[4]>>8&255,t[4]&255]}var da=Ks("v5",80,fa);const ha=da,pa="00000000-0000-0000-0000-000000000000";function ga(r){if(!pn(r))throw TypeError("Invalid UUID");return parseInt(r.substr(14,1),16)}const ya=Object.freeze(Object.defineProperty({__proto__:null,NIL:pa,parse:Ms,stringify:gn,v1:Yi,v3:ca,v4:ua,v5:ha,validate:pn,version:ga},Symbol.toStringTag,{value:"Module"})),Gs=zt(ya),ma=Gs.v4,ba=function(r,e,t,n){if(typeof r!="string")throw new TypeError(r+" must be a string");n=n||{};const s=typeof n.version=="number"?n.version:2;if(s!==1&&s!==2)throw new TypeError(s+" must be 1 or 2");const o={method:r};if(s===2&&(o.jsonrpc="2.0"),e){if(typeof e!="object"&&!Array.isArray(e))throw new TypeError(e+" must be an object, array or omitted");o.params=e}if(typeof t>"u"){const i=typeof n.generator=="function"?n.generator:function(){return ma()};o.id=i(o,n)}else s===2&&t===null?n.notificationIdNull&&(o.id=null):o.id=t;return o};var wa=ba;const Sa=Gs.v4,va=wa,Ft=function(r,e){if(!(this instanceof Ft))return new Ft(r,e);e||(e={}),this.options={reviver:typeof e.reviver<"u"?e.reviver:null,replacer:typeof e.replacer<"u"?e.replacer:null,generator:typeof e.generator<"u"?e.generator:function(){return Sa()},version:typeof e.version<"u"?e.version:2,notificationIdNull:typeof e.notificationIdNull=="boolean"?e.notificationIdNull:!1},this.callServer=r};var xa=Ft;Ft.prototype.request=function(r,e,t,n){const s=this;let o=null;const i=Array.isArray(r)&&typeof e=="function";if(this.options.version===1&&i)throw new TypeError("JSON-RPC 1.0 does not support batching");if(i||!i&&r&&typeof r=="object"&&typeof e=="function")n=e,o=r;else{typeof t=="function"&&(n=t,t=void 0);const l=typeof n=="function";try{o=va(r,e,t,{generator:this.options.generator,version:this.options.version,notificationIdNull:this.options.notificationIdNull})}catch(u){if(l)return n(u);throw u}if(!l)return o}let c;try{c=JSON.stringify(o,this.options.replacer)}catch(l){return n(l)}return this.callServer(c,function(l,u){s._parseResponse(l,u,n)}),o};Ft.prototype._parseResponse=function(r,e,t){if(r){t(r);return}if(!e)return t();let n;try{n=JSON.parse(e,this.options.reviver)}catch(s){return t(s)}if(t.length===3)if(Array.isArray(n)){const s=function(i){return typeof i.error<"u"},o=function(i){return!s(i)};return t(null,n.filter(s),n.filter(o))}else return t(null,n.error,n.result);t(null,n)};const _a=cn(xa);var Ws={},$s={exports:{}};(function(r){function e(t){return t&&t.__esModule?t:{default:t}}r.exports=e,r.exports.__esModule=!0,r.exports.default=r.exports})($s);var js=$s.exports,Cn={exports:{}},Tn={exports:{}},Nr;function Vs(){return Nr||(Nr=1,function(r){function e(t){"@babel/helpers - typeof";return r.exports=e=typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?function(n){return typeof n}:function(n){return n&&typeof Symbol=="function"&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},r.exports.__esModule=!0,r.exports.default=r.exports,e(t)}r.exports=e,r.exports.__esModule=!0,r.exports.default=r.exports}(Tn)),Tn.exports}var qr;function ka(){return qr||(qr=1,function(r){var e=Vs().default;function t(){r.exports=t=function(){return n},r.exports.__esModule=!0,r.exports.default=r.exports;var n={},s=Object.prototype,o=s.hasOwnProperty,i=Object.defineProperty||function(C,E,B){C[E]=B.value},a=typeof Symbol=="function"?Symbol:{},c=a.iterator||"@@iterator",l=a.asyncIterator||"@@asyncIterator",u=a.toStringTag||"@@toStringTag";function w(C,E,B){return Object.defineProperty(C,E,{value:B,enumerable:!0,configurable:!0,writable:!0}),C[E]}try{w({},"")}catch{w=function(B,x,S){return B[x]=S}}function v(C,E,B,x){var S=E&&E.prototype instanceof p?E:p,A=Object.create(S.prototype),D=new de(x||[]);return i(A,"_invoke",{value:q(C,B,D)}),A}function g(C,E,B){try{return{type:"normal",arg:C.call(E,B)}}catch(x){return{type:"throw",arg:x}}}n.wrap=v;var y={};function p(){}function m(){}function I(){}var _={};w(_,c,function(){return this});var d=Object.getPrototypeOf,R=d&&d(d(se([])));R&&R!==s&&o.call(R,c)&&(_=R);var b=I.prototype=p.prototype=Object.create(_);function F(C){["next","throw","return"].forEach(function(E){w(C,E,function(B){return this._invoke(E,B)})})}function P(C,E){function B(S,A,D,$){var j=g(C[S],C,A);if(j.type!=="throw"){var Y=j.arg,ee=Y.value;return ee&&e(ee)=="object"&&o.call(ee,"__await")?E.resolve(ee.__await).then(function(X){B("next",X,D,$)},function(X){B("throw",X,D,$)}):E.resolve(ee).then(function(X){Y.value=X,D(Y)},function(X){return B("throw",X,D,$)})}$(j.arg)}var x;i(this,"_invoke",{value:function(A,D){function $(){return new E(function(j,Y){B(A,D,j,Y)})}return x=x?x.then($,$):$()}})}function q(C,E,B){var x="suspendedStart";return function(S,A){if(x==="executing")throw new Error("Generator is already running");if(x==="completed"){if(S==="throw")throw A;return Ge()}for(B.method=S,B.arg=A;;){var D=B.delegate;if(D){var $=J(D,B);if($){if($===y)continue;return $}}if(B.method==="next")B.sent=B._sent=B.arg;else if(B.method==="throw"){if(x==="suspendedStart")throw x="completed",B.arg;B.dispatchException(B.arg)}else B.method==="return"&&B.abrupt("return",B.arg);x="executing";var j=g(C,E,B);if(j.type==="normal"){if(x=B.done?"completed":"suspendedYield",j.arg===y)continue;return{value:j.arg,done:B.done}}j.type==="throw"&&(x="completed",B.method="throw",B.arg=j.arg)}}}function J(C,E){var B=E.method,x=C.iterator[B];if(x===void 0)return E.delegate=null,B==="throw"&&C.iterator.return&&(E.method="return",E.arg=void 0,J(C,E),E.method==="throw")||B!=="return"&&(E.method="throw",E.arg=new TypeError("The iterator does not provide a '"+B+"' method")),y;var S=g(x,C.iterator,E.arg);if(S.type==="throw")return E.method="throw",E.arg=S.arg,E.delegate=null,y;var A=S.arg;return A?A.done?(E[C.resultName]=A.value,E.next=C.nextLoc,E.method!=="return"&&(E.method="next",E.arg=void 0),E.delegate=null,y):A:(E.method="throw",E.arg=new TypeError("iterator result is not an object"),E.delegate=null,y)}function ie(C){var E={tryLoc:C[0]};1 in C&&(E.catchLoc=C[1]),2 in C&&(E.finallyLoc=C[2],E.afterLoc=C[3]),this.tryEntries.push(E)}function ae(C){var E=C.completion||{};E.type="normal",delete E.arg,C.completion=E}function de(C){this.tryEntries=[{tryLoc:"root"}],C.forEach(ie,this),this.reset(!0)}function se(C){if(C){var E=C[c];if(E)return E.call(C);if(typeof C.next=="function")return C;if(!isNaN(C.length)){var B=-1,x=function S(){for(;++B<C.length;)if(o.call(C,B))return S.value=C[B],S.done=!1,S;return S.value=void 0,S.done=!0,S};return x.next=x}}return{next:Ge}}function Ge(){return{value:void 0,done:!0}}return m.prototype=I,i(b,"constructor",{value:I,configurable:!0}),i(I,"constructor",{value:m,configurable:!0}),m.displayName=w(I,u,"GeneratorFunction"),n.isGeneratorFunction=function(C){var E=typeof C=="function"&&C.constructor;return!!E&&(E===m||(E.displayName||E.name)==="GeneratorFunction")},n.mark=function(C){return Object.setPrototypeOf?Object.setPrototypeOf(C,I):(C.__proto__=I,w(C,u,"GeneratorFunction")),C.prototype=Object.create(b),C},n.awrap=function(C){return{__await:C}},F(P.prototype),w(P.prototype,l,function(){return this}),n.AsyncIterator=P,n.async=function(C,E,B,x,S){S===void 0&&(S=Promise);var A=new P(v(C,E,B,x),S);return n.isGeneratorFunction(E)?A:A.next().then(function(D){return D.done?D.value:A.next()})},F(b),w(b,u,"Generator"),w(b,c,function(){return this}),w(b,"toString",function(){return"[object Generator]"}),n.keys=function(C){var E=Object(C),B=[];for(var x in E)B.push(x);return B.reverse(),function S(){for(;B.length;){var A=B.pop();if(A in E)return S.value=A,S.done=!1,S}return S.done=!0,S}},n.values=se,de.prototype={constructor:de,reset:function(E){if(this.prev=0,this.next=0,this.sent=this._sent=void 0,this.done=!1,this.delegate=null,this.method="next",this.arg=void 0,this.tryEntries.forEach(ae),!E)for(var B in this)B.charAt(0)==="t"&&o.call(this,B)&&!isNaN(+B.slice(1))&&(this[B]=void 0)},stop:function(){this.done=!0;var E=this.tryEntries[0].completion;if(E.type==="throw")throw E.arg;return this.rval},dispatchException:function(E){if(this.done)throw E;var B=this;function x(Y,ee){return D.type="throw",D.arg=E,B.next=Y,ee&&(B.method="next",B.arg=void 0),!!ee}for(var S=this.tryEntries.length-1;S>=0;--S){var A=this.tryEntries[S],D=A.completion;if(A.tryLoc==="root")return x("end");if(A.tryLoc<=this.prev){var $=o.call(A,"catchLoc"),j=o.call(A,"finallyLoc");if($&&j){if(this.prev<A.catchLoc)return x(A.catchLoc,!0);if(this.prev<A.finallyLoc)return x(A.finallyLoc)}else if($){if(this.prev<A.catchLoc)return x(A.catchLoc,!0)}else{if(!j)throw new Error("try statement without catch or finally");if(this.prev<A.finallyLoc)return x(A.finallyLoc)}}}},abrupt:function(E,B){for(var x=this.tryEntries.length-1;x>=0;--x){var S=this.tryEntries[x];if(S.tryLoc<=this.prev&&o.call(S,"finallyLoc")&&this.prev<S.finallyLoc){var A=S;break}}A&&(E==="break"||E==="continue")&&A.tryLoc<=B&&B<=A.finallyLoc&&(A=null);var D=A?A.completion:{};return D.type=E,D.arg=B,A?(this.method="next",this.next=A.finallyLoc,y):this.complete(D)},complete:function(E,B){if(E.type==="throw")throw E.arg;return E.type==="break"||E.type==="continue"?this.next=E.arg:E.type==="return"?(this.rval=this.arg=E.arg,this.method="return",this.next="end"):E.type==="normal"&&B&&(this.next=B),y},finish:function(E){for(var B=this.tryEntries.length-1;B>=0;--B){var x=this.tryEntries[B];if(x.finallyLoc===E)return this.complete(x.completion,x.afterLoc),ae(x),y}},catch:function(E){for(var B=this.tryEntries.length-1;B>=0;--B){var x=this.tryEntries[B];if(x.tryLoc===E){var S=x.completion;if(S.type==="throw"){var A=S.arg;ae(x)}return A}}throw new Error("illegal catch attempt")},delegateYield:function(E,B,x){return this.delegate={iterator:se(E),resultName:B,nextLoc:x},this.method==="next"&&(this.arg=void 0),y}},n}r.exports=t,r.exports.__esModule=!0,r.exports.default=r.exports}(Cn)),Cn.exports}var Pn,Dr;function Ea(){if(Dr)return Pn;Dr=1;var r=ka()();Pn=r;try{regeneratorRuntime=r}catch{typeof globalThis=="object"?globalThis.regeneratorRuntime=r:Function("r","regeneratorRuntime = r")(r)}return Pn}var On={exports:{}},zr;function Aa(){return zr||(zr=1,function(r){function e(n,s,o,i,a,c,l){try{var u=n[c](l),w=u.value}catch(v){o(v);return}u.done?s(w):Promise.resolve(w).then(i,a)}function t(n){return function(){var s=this,o=arguments;return new Promise(function(i,a){var c=n.apply(s,o);function l(w){e(c,i,a,l,u,"next",w)}function u(w){e(c,i,a,l,u,"throw",w)}l(void 0)})}}r.exports=t,r.exports.__esModule=!0,r.exports.default=r.exports}(On)),On.exports}const Ia=zt(Lo),Zs=zt(Co),Js=zt(To);var Un={exports:{}},Fn={exports:{}},Mr;function Ra(){return Mr||(Mr=1,function(r){function e(t,n){return r.exports=e=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(o,i){return o.__proto__=i,o},r.exports.__esModule=!0,r.exports.default=r.exports,e(t,n)}r.exports=e,r.exports.__esModule=!0,r.exports.default=r.exports}(Fn)),Fn.exports}var Kr;function Xs(){return Kr||(Kr=1,function(r){var e=Ra();function t(n,s){if(typeof s!="function"&&s!==null)throw new TypeError("Super expression must either be null or a function");n.prototype=Object.create(s&&s.prototype,{constructor:{value:n,writable:!0,configurable:!0}}),Object.defineProperty(n,"prototype",{writable:!1}),s&&e(n,s)}r.exports=t,r.exports.__esModule=!0,r.exports.default=r.exports}(Un)),Un.exports}var Nn={exports:{}},qn={exports:{}},Hr;function Ba(){return Hr||(Hr=1,function(r){function e(t){if(t===void 0)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}r.exports=e,r.exports.__esModule=!0,r.exports.default=r.exports}(qn)),qn.exports}var Gr;function Ys(){return Gr||(Gr=1,function(r){var e=Vs().default,t=Ba();function n(s,o){if(o&&(e(o)==="object"||typeof o=="function"))return o;if(o!==void 0)throw new TypeError("Derived constructors may only return object or undefined");return t(s)}r.exports=n,r.exports.__esModule=!0,r.exports.default=r.exports}(Nn)),Nn.exports}var Dn={exports:{}},Wr;function Qs(){return Wr||(Wr=1,function(r){function e(t){return r.exports=e=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(s){return s.__proto__||Object.getPrototypeOf(s)},r.exports.__esModule=!0,r.exports.default=r.exports,e(t)}r.exports=e,r.exports.__esModule=!0,r.exports.default=r.exports}(Dn)),Dn.exports}(function(r){var e=js;Object.defineProperty(r,"__esModule",{value:!0}),r.default=void 0;var t=e(Ea()),n=e(Aa()),s=e(Ia),o=e(Zs),i=e(Js),a=e(Xs()),c=e(Ys()),l=e(Qs()),u=ss;function w(p){var m=v();return function(){var _=(0,l.default)(p),d;if(m){var R=(0,l.default)(this).constructor;d=Reflect.construct(_,arguments,R)}else d=_.apply(this,arguments);return(0,c.default)(this,d)}}function v(){if(typeof Reflect>"u"||!Reflect.construct||Reflect.construct.sham)return!1;if(typeof Proxy=="function")return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){})),!0}catch{return!1}}var g=function(p,m){var I={};for(var _ in p)Object.prototype.hasOwnProperty.call(p,_)&&m.indexOf(_)<0&&(I[_]=p[_]);if(p!=null&&typeof Object.getOwnPropertySymbols=="function")for(var d=0,_=Object.getOwnPropertySymbols(p);d<_.length;d++)m.indexOf(_[d])<0&&Object.prototype.propertyIsEnumerable.call(p,_[d])&&(I[_[d]]=p[_[d]]);return I},y=function(p){(0,a.default)(I,p);var m=w(I);function I(_){var d,R=arguments.length>1&&arguments[1]!==void 0?arguments[1]:"ws://localhost:8080",b=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{},F=arguments.length>3?arguments[3]:void 0;(0,o.default)(this,I);var P=b.autoconnect,q=P===void 0?!0:P,J=b.reconnect,ie=J===void 0?!0:J,ae=b.reconnect_interval,de=ae===void 0?1e3:ae,se=b.max_reconnects,Ge=se===void 0?5:se,C=g(b,["autoconnect","reconnect","reconnect_interval","max_reconnects"]);return d=m.call(this),d.webSocketFactory=_,d.queue={},d.rpc_id=0,d.address=R,d.autoconnect=q,d.ready=!1,d.reconnect=ie,d.reconnect_timer_id=void 0,d.reconnect_interval=de,d.max_reconnects=Ge,d.rest_options=C,d.current_reconnects=0,d.generate_request_id=F||function(){return++d.rpc_id},d.autoconnect&&d._connect(d.address,Object.assign({autoconnect:d.autoconnect,reconnect:d.reconnect,reconnect_interval:d.reconnect_interval,max_reconnects:d.max_reconnects},d.rest_options)),d}return(0,i.default)(I,[{key:"connect",value:function(){this.socket||this._connect(this.address,Object.assign({autoconnect:this.autoconnect,reconnect:this.reconnect,reconnect_interval:this.reconnect_interval,max_reconnects:this.max_reconnects},this.rest_options))}},{key:"call",value:function(d,R,b,F){var P=this;return!F&&(0,s.default)(b)==="object"&&(F=b,b=null),new Promise(function(q,J){if(!P.ready)return J(new Error("socket not ready"));var ie=P.generate_request_id(d,R),ae={jsonrpc:"2.0",method:d,params:R||null,id:ie};P.socket.send(JSON.stringify(ae),F,function(de){if(de)return J(de);P.queue[ie]={promise:[q,J]},b&&(P.queue[ie].timeout=setTimeout(function(){delete P.queue[ie],J(new Error("reply timeout"))},b))})})}},{key:"login",value:function(){var _=(0,n.default)(t.default.mark(function R(b){var F;return t.default.wrap(function(q){for(;;)switch(q.prev=q.next){case 0:return q.next=2,this.call("rpc.login",b);case 2:if(F=q.sent,F){q.next=5;break}throw new Error("authentication failed");case 5:return q.abrupt("return",F);case 6:case"end":return q.stop()}},R,this)}));function d(R){return _.apply(this,arguments)}return d}()},{key:"listMethods",value:function(){var _=(0,n.default)(t.default.mark(function R(){return t.default.wrap(function(F){for(;;)switch(F.prev=F.next){case 0:return F.next=2,this.call("__listMethods");case 2:return F.abrupt("return",F.sent);case 3:case"end":return F.stop()}},R,this)}));function d(){return _.apply(this,arguments)}return d}()},{key:"notify",value:function(d,R){var b=this;return new Promise(function(F,P){if(!b.ready)return P(new Error("socket not ready"));var q={jsonrpc:"2.0",method:d,params:R||null};b.socket.send(JSON.stringify(q),function(J){if(J)return P(J);F()})})}},{key:"subscribe",value:function(){var _=(0,n.default)(t.default.mark(function R(b){var F;return t.default.wrap(function(q){for(;;)switch(q.prev=q.next){case 0:return typeof b=="string"&&(b=[b]),q.next=3,this.call("rpc.on",b);case 3:if(F=q.sent,!(typeof b=="string"&&F[b]!=="ok")){q.next=6;break}throw new Error("Failed subscribing to an event '"+b+"' with: "+F[b]);case 6:return q.abrupt("return",F);case 7:case"end":return q.stop()}},R,this)}));function d(R){return _.apply(this,arguments)}return d}()},{key:"unsubscribe",value:function(){var _=(0,n.default)(t.default.mark(function R(b){var F;return t.default.wrap(function(q){for(;;)switch(q.prev=q.next){case 0:return typeof b=="string"&&(b=[b]),q.next=3,this.call("rpc.off",b);case 3:if(F=q.sent,!(typeof b=="string"&&F[b]!=="ok")){q.next=6;break}throw new Error("Failed unsubscribing from an event with: "+F);case 6:return q.abrupt("return",F);case 7:case"end":return q.stop()}},R,this)}));function d(R){return _.apply(this,arguments)}return d}()},{key:"close",value:function(d,R){this.socket.close(d||1e3,R)}},{key:"_connect",value:function(d,R){var b=this;clearTimeout(this.reconnect_timer_id),this.socket=this.webSocketFactory(d,R),this.socket.addEventListener("open",function(){b.ready=!0,b.emit("open"),b.current_reconnects=0}),this.socket.addEventListener("message",function(F){var P=F.data;P instanceof ArrayBuffer&&(P=K.from(P).toString());try{P=JSON.parse(P)}catch{return}if(P.notification&&b.listeners(P.notification).length){if(!Object.keys(P.params).length)return b.emit(P.notification);var q=[P.notification];if(P.params.constructor===Object)q.push(P.params);else for(var J=0;J<P.params.length;J++)q.push(P.params[J]);return Promise.resolve().then(function(){b.emit.apply(b,q)})}if(!b.queue[P.id])return P.method&&P.params?Promise.resolve().then(function(){b.emit(P.method,P.params)}):void 0;"error"in P=="result"in P&&b.queue[P.id].promise[1](new Error('Server response malformed. Response must include either "result" or "error", but not both.')),b.queue[P.id].timeout&&clearTimeout(b.queue[P.id].timeout),P.error?b.queue[P.id].promise[1](P.error):b.queue[P.id].promise[0](P.result),delete b.queue[P.id]}),this.socket.addEventListener("error",function(F){return b.emit("error",F)}),this.socket.addEventListener("close",function(F){var P=F.code,q=F.reason;b.ready&&setTimeout(function(){return b.emit("close",P,q)},0),b.ready=!1,b.socket=void 0,P!==1e3&&(b.current_reconnects++,b.reconnect&&(b.max_reconnects>b.current_reconnects||b.max_reconnects===0)&&(b.reconnect_timer_id=setTimeout(function(){return b._connect(d,R)},b.reconnect_interval)))})}}]),I}(u.EventEmitter);r.default=y})(Ws);const La=cn(Ws);var eo={};(function(r){var e=js;Object.defineProperty(r,"__esModule",{value:!0}),r.default=w;var t=e(Zs),n=e(Js),s=e(Xs()),o=e(Ys()),i=e(Qs()),a=ss;function c(v){var g=l();return function(){var p=(0,i.default)(v),m;if(g){var I=(0,i.default)(this).constructor;m=Reflect.construct(p,arguments,I)}else m=p.apply(this,arguments);return(0,o.default)(this,m)}}function l(){if(typeof Reflect>"u"||!Reflect.construct||Reflect.construct.sham)return!1;if(typeof Proxy=="function")return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){})),!0}catch{return!1}}var u=function(v){(0,s.default)(y,v);var g=c(y);function y(p,m,I){var _;return(0,t.default)(this,y),_=g.call(this),_.socket=new window.WebSocket(p,I),_.socket.onopen=function(){return _.emit("open")},_.socket.onmessage=function(d){return _.emit("message",d.data)},_.socket.onerror=function(d){return _.emit("error",d)},_.socket.onclose=function(d){_.emit("close",d.code,d.reason)},_}return(0,n.default)(y,[{key:"send",value:function(m,I,_){var d=_||I;try{this.socket.send(m),d()}catch(R){d(R)}}},{key:"close",value:function(m,I){this.socket.close(m,I)}},{key:"addEventListener",value:function(m,I,_){this.socket.addEventListener(m,I,_)}}]),y}(a.EventEmitter);function w(v,g){return new u(v,g)}})(eo);const Ca=cn(eo);he.utils.randomPrivateKey;const $r=()=>{const r=he.utils.randomPrivateKey(),e=Wn(r),t=new Uint8Array(64);return t.set(r),t.set(e,32),{publicKey:e,secretKey:t}},Wn=he.getPublicKey;function jr(r){try{return he.ExtendedPoint.fromHex(r),!0}catch{return!1}}const to=(r,e)=>he.sign(r,e.slice(0,32)),Ta=he.verify,Et=r=>K.isBuffer(r)?r:r instanceof Uint8Array?K.from(r.buffer,r.byteOffset,r.byteLength):K.from(r);class Pa{constructor(e){Object.assign(this,e)}encode(){return K.from(ws(Xt,this))}static decode(e){return Ss(Xt,this,e)}static decodeUnchecked(e){return ps(Xt,this,e)}}const Xt=new Map;let no;const Oa=32,Ze=32;function Ua(r){return r._bn!==void 0}let Vr=1;no=Symbol.toStringTag;class W extends Pa{constructor(e){if(super({}),this._bn=void 0,Ua(e))this._bn=e._bn;else{if(typeof e=="string"){const t=we.decode(e);if(t.length!=Ze)throw new Error("Invalid public key input");this._bn=new Er(t)}else this._bn=new Er(e);if(this._bn.byteLength()>Ze)throw new Error("Invalid public key input")}}static unique(){const e=new W(Vr);return Vr+=1,new W(e.toBuffer())}equals(e){return this._bn.eq(e._bn)}toBase58(){return we.encode(this.toBytes())}toJSON(){return this.toBase58()}toBytes(){const e=this.toBuffer();return new Uint8Array(e.buffer,e.byteOffset,e.byteLength)}toBuffer(){const e=this._bn.toArrayLike(K);if(e.length===Ze)return e;const t=K.alloc(32);return e.copy(t,32-e.length),t}get[no](){return`PublicKey(${this.toString()})`}toString(){return this.toBase58()}static async createWithSeed(e,t,n){const s=K.concat([e.toBuffer(),K.from(t),n.toBuffer()]),o=Ir(s);return new W(o)}static createProgramAddressSync(e,t){let n=K.alloc(0);e.forEach(function(o){if(o.length>Oa)throw new TypeError("Max seed length exceeded");n=K.concat([n,Et(o)])}),n=K.concat([n,t.toBuffer(),K.from("ProgramDerivedAddress")]);const s=Ir(n);if(jr(s))throw new Error("Invalid seeds, address must fall off the curve");return new W(s)}static async createProgramAddress(e,t){return this.createProgramAddressSync(e,t)}static findProgramAddressSync(e,t){let n=255,s;for(;n!=0;){try{const o=e.concat(K.from([n]));s=this.createProgramAddressSync(o,t)}catch(o){if(o instanceof TypeError)throw o;n--;continue}return[s,n]}throw new Error("Unable to find a viable program address nonce")}static async findProgramAddress(e,t){return this.findProgramAddressSync(e,t)}static isOnCurve(e){const t=new W(e);return jr(t.toBytes())}}W.default=new W("11111111111111111111111111111111");Xt.set(W,{kind:"struct",fields:[["_bn","u256"]]});new W("BPFLoader1111111111111111111111111111111111");const _t=1280-40-8,fr=127,Nt=64;class ro extends Error{constructor(e){super(`Signature ${e} has expired: block height exceeded.`),this.signature=void 0,this.signature=e}}Object.defineProperty(ro.prototype,"name",{value:"TransactionExpiredBlockheightExceededError"});class so extends Error{constructor(e,t){super(`Transaction was not confirmed in ${t.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ${e} using the Solana Explorer or CLI tools.`),this.signature=void 0,this.signature=e}}Object.defineProperty(so.prototype,"name",{value:"TransactionExpiredTimeoutError"});class Tt extends Error{constructor(e){super(`Signature ${e} has expired: the nonce is no longer valid.`),this.signature=void 0,this.signature=e}}Object.defineProperty(Tt.prototype,"name",{value:"TransactionExpiredNonceInvalidError"});class on{constructor(e,t){this.staticAccountKeys=void 0,this.accountKeysFromLookups=void 0,this.staticAccountKeys=e,this.accountKeysFromLookups=t}keySegments(){const e=[this.staticAccountKeys];return this.accountKeysFromLookups&&(e.push(this.accountKeysFromLookups.writable),e.push(this.accountKeysFromLookups.readonly)),e}get(e){for(const t of this.keySegments()){if(e<t.length)return t[e];e-=t.length}}get length(){return this.keySegments().flat().length}compileInstructions(e){if(this.length>255+1)throw new Error("Account index overflow encountered during compilation");const n=new Map;this.keySegments().flat().forEach((o,i)=>{n.set(o.toBase58(),i)});const s=o=>{const i=n.get(o.toBase58());if(i===void 0)throw new Error("Encountered an unknown instruction account key during compilation");return i};return e.map(o=>({programIdIndex:s(o.programId),accountKeyIndexes:o.keys.map(i=>s(i.pubkey)),data:o.data}))}}const Q=(r="publicKey")=>ce(32,r),Fa=(r="signature")=>ce(64,r),vt=(r="string")=>{const e=z([H("length"),H("lengthPadding"),ce(pt(H(),-8),"chars")],r),t=e.decode.bind(e),n=e.encode.bind(e),s=e;return s.decode=(o,i)=>t(o,i).chars.toString(),s.encode=(o,i,a)=>{const c={chars:K.from(o,"utf8")};return n(c,i,a)},s.alloc=o=>H().span+H().span+K.from(o,"utf8").length,s},Na=(r="authorized")=>z([Q("staker"),Q("withdrawer")],r),qa=(r="lockup")=>z([Te("unixTimestamp"),Te("epoch"),Q("custodian")],r),Da=(r="voteInit")=>z([Q("nodePubkey"),Q("authorizedVoter"),Q("authorizedWithdrawer"),ne("commission")],r),za=(r="voteAuthorizeWithSeedArgs")=>z([H("voteAuthorizationType"),Q("currentAuthorityDerivedKeyOwnerPubkey"),vt("currentAuthorityDerivedKeySeed"),Q("newAuthorized")],r);function Pe(r){let e=0,t=0;for(;;){let n=r.shift();if(e|=(n&127)<<t*7,t+=1,!(n&128))break}return e}function Oe(r,e){let t=e;for(;;){let n=t&127;if(t>>=7,t==0){r.push(n);break}else n|=128,r.push(n)}}function ue(r,e){if(!r)throw new Error(e||"Assertion failed")}class mn{constructor(e,t){this.payer=void 0,this.keyMetaMap=void 0,this.payer=e,this.keyMetaMap=t}static compile(e,t){const n=new Map,s=i=>{const a=i.toBase58();let c=n.get(a);return c===void 0&&(c={isSigner:!1,isWritable:!1,isInvoked:!1},n.set(a,c)),c},o=s(t);o.isSigner=!0,o.isWritable=!0;for(const i of e){s(i.programId).isInvoked=!0;for(const a of i.keys){const c=s(a.pubkey);c.isSigner||(c.isSigner=a.isSigner),c.isWritable||(c.isWritable=a.isWritable)}}return new mn(t,n)}getMessageComponents(){const e=[...this.keyMetaMap.entries()];ue(e.length<=256,"Max static account keys length exceeded");const t=e.filter(([,c])=>c.isSigner&&c.isWritable),n=e.filter(([,c])=>c.isSigner&&!c.isWritable),s=e.filter(([,c])=>!c.isSigner&&c.isWritable),o=e.filter(([,c])=>!c.isSigner&&!c.isWritable),i={numRequiredSignatures:t.length+n.length,numReadonlySignedAccounts:n.length,numReadonlyUnsignedAccounts:o.length};{ue(t.length>0,"Expected at least one writable signer key");const[c]=t[0];ue(c===this.payer.toBase58(),"Expected first writable signer key to be the fee payer")}const a=[...t.map(([c])=>new W(c)),...n.map(([c])=>new W(c)),...s.map(([c])=>new W(c)),...o.map(([c])=>new W(c))];return[i,a]}extractTableLookup(e){const[t,n]=this.drainKeysFoundInLookupTable(e.state.addresses,i=>!i.isSigner&&!i.isInvoked&&i.isWritable),[s,o]=this.drainKeysFoundInLookupTable(e.state.addresses,i=>!i.isSigner&&!i.isInvoked&&!i.isWritable);if(!(t.length===0&&s.length===0))return[{accountKey:e.key,writableIndexes:t,readonlyIndexes:s},{writable:n,readonly:o}]}drainKeysFoundInLookupTable(e,t){const n=new Array,s=new Array;for(const[o,i]of this.keyMetaMap.entries())if(t(i)){const a=new W(o),c=e.findIndex(l=>l.equals(a));c>=0&&(ue(c<256,"Max lookup table index exceeded"),n.push(c),s.push(a),this.keyMetaMap.delete(o))}return[n,s]}}class nt{constructor(e){this.header=void 0,this.accountKeys=void 0,this.recentBlockhash=void 0,this.instructions=void 0,this.indexToProgramIds=new Map,this.header=e.header,this.accountKeys=e.accountKeys.map(t=>new W(t)),this.recentBlockhash=e.recentBlockhash,this.instructions=e.instructions,this.instructions.forEach(t=>this.indexToProgramIds.set(t.programIdIndex,this.accountKeys[t.programIdIndex]))}get version(){return"legacy"}get staticAccountKeys(){return this.accountKeys}get compiledInstructions(){return this.instructions.map(e=>({programIdIndex:e.programIdIndex,accountKeyIndexes:e.accounts,data:we.decode(e.data)}))}get addressTableLookups(){return[]}getAccountKeys(){return new on(this.staticAccountKeys)}static compile(e){const t=mn.compile(e.instructions,e.payerKey),[n,s]=t.getMessageComponents(),i=new on(s).compileInstructions(e.instructions).map(a=>({programIdIndex:a.programIdIndex,accounts:a.accountKeyIndexes,data:we.encode(a.data)}));return new nt({header:n,accountKeys:s,recentBlockhash:e.recentBlockhash,instructions:i})}isAccountSigner(e){return e<this.header.numRequiredSignatures}isAccountWritable(e){const t=this.header.numRequiredSignatures;if(e>=this.header.numRequiredSignatures){const n=e-t,o=this.accountKeys.length-t-this.header.numReadonlyUnsignedAccounts;return n<o}else{const n=t-this.header.numReadonlySignedAccounts;return e<n}}isProgramId(e){return this.indexToProgramIds.has(e)}programIds(){return[...this.indexToProgramIds.values()]}nonProgramIds(){return this.accountKeys.filter((e,t)=>!this.isProgramId(t))}serialize(){const e=this.accountKeys.length;let t=[];Oe(t,e);const n=this.instructions.map(w=>{const{accounts:v,programIdIndex:g}=w,y=Array.from(we.decode(w.data));let p=[];Oe(p,v.length);let m=[];return Oe(m,y.length),{programIdIndex:g,keyIndicesCount:K.from(p),keyIndices:v,dataLength:K.from(m),data:y}});let s=[];Oe(s,n.length);let o=K.alloc(_t);K.from(s).copy(o);let i=s.length;n.forEach(w=>{const g=z([ne("programIdIndex"),ce(w.keyIndicesCount.length,"keyIndicesCount"),Ee(ne("keyIndex"),w.keyIndices.length,"keyIndices"),ce(w.dataLength.length,"dataLength"),Ee(ne("userdatum"),w.data.length,"data")]).encode(w,o,i);i+=g}),o=o.slice(0,i);const a=z([ce(1,"numRequiredSignatures"),ce(1,"numReadonlySignedAccounts"),ce(1,"numReadonlyUnsignedAccounts"),ce(t.length,"keyCount"),Ee(Q("key"),e,"keys"),Q("recentBlockhash")]),c={numRequiredSignatures:K.from([this.header.numRequiredSignatures]),numReadonlySignedAccounts:K.from([this.header.numReadonlySignedAccounts]),numReadonlyUnsignedAccounts:K.from([this.header.numReadonlyUnsignedAccounts]),keyCount:K.from(t),keys:this.accountKeys.map(w=>Et(w.toBytes())),recentBlockhash:we.decode(this.recentBlockhash)};let l=K.alloc(2048);const u=a.encode(c,l);return o.copy(l,u),l.slice(0,u+o.length)}static from(e){let t=[...e];const n=t.shift();if(n!==(n&fr))throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");const s=t.shift(),o=t.shift(),i=Pe(t);let a=[];for(let v=0;v<i;v++){const g=t.slice(0,Ze);t=t.slice(Ze),a.push(new W(K.from(g)))}const c=t.slice(0,Ze);t=t.slice(Ze);const l=Pe(t);let u=[];for(let v=0;v<l;v++){const g=t.shift(),y=Pe(t),p=t.slice(0,y);t=t.slice(y);const m=Pe(t),I=t.slice(0,m),_=we.encode(K.from(I));t=t.slice(m),u.push({programIdIndex:g,accounts:p,data:_})}const w={header:{numRequiredSignatures:n,numReadonlySignedAccounts:s,numReadonlyUnsignedAccounts:o},recentBlockhash:we.encode(K.from(c)),accountKeys:a,instructions:u};return new nt(w)}}class qt{constructor(e){this.header=void 0,this.staticAccountKeys=void 0,this.recentBlockhash=void 0,this.compiledInstructions=void 0,this.addressTableLookups=void 0,this.header=e.header,this.staticAccountKeys=e.staticAccountKeys,this.recentBlockhash=e.recentBlockhash,this.compiledInstructions=e.compiledInstructions,this.addressTableLookups=e.addressTableLookups}get version(){return 0}get numAccountKeysFromLookups(){let e=0;for(const t of this.addressTableLookups)e+=t.readonlyIndexes.length+t.writableIndexes.length;return e}getAccountKeys(e){let t;if(e&&"accountKeysFromLookups"in e&&e.accountKeysFromLookups){if(this.numAccountKeysFromLookups!=e.accountKeysFromLookups.writable.length+e.accountKeysFromLookups.readonly.length)throw new Error("Failed to get account keys because of a mismatch in the number of account keys from lookups");t=e.accountKeysFromLookups}else if(e&&"addressLookupTableAccounts"in e&&e.addressLookupTableAccounts)t=this.resolveAddressTableLookups(e.addressLookupTableAccounts);else if(this.addressTableLookups.length>0)throw new Error("Failed to get account keys because address table lookups were not resolved");return new on(this.staticAccountKeys,t)}isAccountSigner(e){return e<this.header.numRequiredSignatures}isAccountWritable(e){const t=this.header.numRequiredSignatures,n=this.staticAccountKeys.length;if(e>=n){const s=e-n,o=this.addressTableLookups.reduce((i,a)=>i+a.writableIndexes.length,0);return s<o}else if(e>=this.header.numRequiredSignatures){const s=e-t,i=n-t-this.header.numReadonlyUnsignedAccounts;return s<i}else{const s=t-this.header.numReadonlySignedAccounts;return e<s}}resolveAddressTableLookups(e){const t={writable:[],readonly:[]};for(const n of this.addressTableLookups){const s=e.find(o=>o.key.equals(n.accountKey));if(!s)throw new Error(`Failed to find address lookup table account for table key ${n.accountKey.toBase58()}`);for(const o of n.writableIndexes)if(o<s.state.addresses.length)t.writable.push(s.state.addresses[o]);else throw new Error(`Failed to find address for index ${o} in address lookup table ${n.accountKey.toBase58()}`);for(const o of n.readonlyIndexes)if(o<s.state.addresses.length)t.readonly.push(s.state.addresses[o]);else throw new Error(`Failed to find address for index ${o} in address lookup table ${n.accountKey.toBase58()}`)}return t}static compile(e){const t=mn.compile(e.instructions,e.payerKey),n=new Array,s={writable:new Array,readonly:new Array},o=e.addressLookupTableAccounts||[];for(const u of o){const w=t.extractTableLookup(u);if(w!==void 0){const[v,{writable:g,readonly:y}]=w;n.push(v),s.writable.push(...g),s.readonly.push(...y)}}const[i,a]=t.getMessageComponents(),l=new on(a,s).compileInstructions(e.instructions);return new qt({header:i,staticAccountKeys:a,recentBlockhash:e.recentBlockhash,compiledInstructions:l,addressTableLookups:n})}serialize(){const e=Array();Oe(e,this.staticAccountKeys.length);const t=this.serializeInstructions(),n=Array();Oe(n,this.compiledInstructions.length);const s=this.serializeAddressTableLookups(),o=Array();Oe(o,this.addressTableLookups.length);const i=z([ne("prefix"),z([ne("numRequiredSignatures"),ne("numReadonlySignedAccounts"),ne("numReadonlyUnsignedAccounts")],"header"),ce(e.length,"staticAccountKeysLength"),Ee(Q(),this.staticAccountKeys.length,"staticAccountKeys"),Q("recentBlockhash"),ce(n.length,"instructionsLength"),ce(t.length,"serializedInstructions"),ce(o.length,"addressTableLookupsLength"),ce(s.length,"serializedAddressTableLookups")]),a=new Uint8Array(_t),c=128,l=i.encode({prefix:c,header:this.header,staticAccountKeysLength:new Uint8Array(e),staticAccountKeys:this.staticAccountKeys.map(u=>u.toBytes()),recentBlockhash:we.decode(this.recentBlockhash),instructionsLength:new Uint8Array(n),serializedInstructions:t,addressTableLookupsLength:new Uint8Array(o),serializedAddressTableLookups:s},a);return a.slice(0,l)}serializeInstructions(){let e=0;const t=new Uint8Array(_t);for(const n of this.compiledInstructions){const s=Array();Oe(s,n.accountKeyIndexes.length);const o=Array();Oe(o,n.data.length);const i=z([ne("programIdIndex"),ce(s.length,"encodedAccountKeyIndexesLength"),Ee(ne(),n.accountKeyIndexes.length,"accountKeyIndexes"),ce(o.length,"encodedDataLength"),ce(n.data.length,"data")]);e+=i.encode({programIdIndex:n.programIdIndex,encodedAccountKeyIndexesLength:new Uint8Array(s),accountKeyIndexes:n.accountKeyIndexes,encodedDataLength:new Uint8Array(o),data:n.data},t,e)}return t.slice(0,e)}serializeAddressTableLookups(){let e=0;const t=new Uint8Array(_t);for(const n of this.addressTableLookups){const s=Array();Oe(s,n.writableIndexes.length);const o=Array();Oe(o,n.readonlyIndexes.length);const i=z([Q("accountKey"),ce(s.length,"encodedWritableIndexesLength"),Ee(ne(),n.writableIndexes.length,"writableIndexes"),ce(o.length,"encodedReadonlyIndexesLength"),Ee(ne(),n.readonlyIndexes.length,"readonlyIndexes")]);e+=i.encode({accountKey:n.accountKey.toBytes(),encodedWritableIndexesLength:new Uint8Array(s),writableIndexes:n.writableIndexes,encodedReadonlyIndexesLength:new Uint8Array(o),readonlyIndexes:n.readonlyIndexes},t,e)}return t.slice(0,e)}static deserialize(e){let t=[...e];const n=t.shift(),s=n&fr;ue(n!==s,"Expected versioned message but received legacy message");const o=s;ue(o===0,`Expected versioned message with version 0 but found version ${o}`);const i={numRequiredSignatures:t.shift(),numReadonlySignedAccounts:t.shift(),numReadonlyUnsignedAccounts:t.shift()},a=[],c=Pe(t);for(let y=0;y<c;y++)a.push(new W(t.splice(0,Ze)));const l=we.encode(t.splice(0,Ze)),u=Pe(t),w=[];for(let y=0;y<u;y++){const p=t.shift(),m=Pe(t),I=t.splice(0,m),_=Pe(t),d=new Uint8Array(t.splice(0,_));w.push({programIdIndex:p,accountKeyIndexes:I,data:d})}const v=Pe(t),g=[];for(let y=0;y<v;y++){const p=new W(t.splice(0,Ze)),m=Pe(t),I=t.splice(0,m),_=Pe(t),d=t.splice(0,_);g.push({accountKey:p,writableIndexes:I,readonlyIndexes:d})}return new qt({header:i,staticAccountKeys:a,recentBlockhash:l,compiledInstructions:w,addressTableLookups:g})}}const oo={deserializeMessageVersion(r){const e=r[0],t=e&fr;return t===e?"legacy":t},deserialize:r=>{const e=oo.deserializeMessageVersion(r);if(e==="legacy")return nt.from(r);if(e===0)return qt.deserialize(r);throw new Error(`Transaction message version ${e} deserialization is not supported`)}};let je;(function(r){r[r.BLOCKHEIGHT_EXCEEDED=0]="BLOCKHEIGHT_EXCEEDED",r[r.PROCESSED=1]="PROCESSED",r[r.TIMED_OUT=2]="TIMED_OUT",r[r.NONCE_INVALID=3]="NONCE_INVALID"})(je||(je={}));const Ma=K.alloc(Nt).fill(0);class Zr{constructor(e){this.keys=void 0,this.programId=void 0,this.data=K.alloc(0),this.programId=e.programId,this.keys=e.keys,e.data&&(this.data=e.data)}toJSON(){return{keys:this.keys.map(({pubkey:e,isSigner:t,isWritable:n})=>({pubkey:e.toJSON(),isSigner:t,isWritable:n})),programId:this.programId.toJSON(),data:[...this.data]}}}class at{get signature(){return this.signatures.length>0?this.signatures[0].signature:null}constructor(e){if(this.signatures=[],this.feePayer=void 0,this.instructions=[],this.recentBlockhash=void 0,this.lastValidBlockHeight=void 0,this.nonceInfo=void 0,this.minNonceContextSlot=void 0,this._message=void 0,this._json=void 0,!!e)if(e.feePayer&&(this.feePayer=e.feePayer),e.signatures&&(this.signatures=e.signatures),Object.prototype.hasOwnProperty.call(e,"nonceInfo")){const{minContextSlot:t,nonceInfo:n}=e;this.minNonceContextSlot=t,this.nonceInfo=n}else if(Object.prototype.hasOwnProperty.call(e,"lastValidBlockHeight")){const{blockhash:t,lastValidBlockHeight:n}=e;this.recentBlockhash=t,this.lastValidBlockHeight=n}else{const{recentBlockhash:t,nonceInfo:n}=e;n&&(this.nonceInfo=n),this.recentBlockhash=t}}toJSON(){return{recentBlockhash:this.recentBlockhash||null,feePayer:this.feePayer?this.feePayer.toJSON():null,nonceInfo:this.nonceInfo?{nonce:this.nonceInfo.nonce,nonceInstruction:this.nonceInfo.nonceInstruction.toJSON()}:null,instructions:this.instructions.map(e=>e.toJSON()),signers:this.signatures.map(({publicKey:e})=>e.toJSON())}}add(...e){if(e.length===0)throw new Error("No instructions");return e.forEach(t=>{"instructions"in t?this.instructions=this.instructions.concat(t.instructions):"data"in t&&"programId"in t&&"keys"in t?this.instructions.push(t):this.instructions.push(new Zr(t))}),this}compileMessage(){if(this._message&&JSON.stringify(this.toJSON())===JSON.stringify(this._json))return this._message;let e,t;if(this.nonceInfo?(e=this.nonceInfo.nonce,this.instructions[0]!=this.nonceInfo.nonceInstruction?t=[this.nonceInfo.nonceInstruction,...this.instructions]:t=this.instructions):(e=this.recentBlockhash,t=this.instructions),!e)throw new Error("Transaction recentBlockhash required");t.length<1&&console.warn("No instructions provided");let n;if(this.feePayer)n=this.feePayer;else if(this.signatures.length>0&&this.signatures[0].publicKey)n=this.signatures[0].publicKey;else throw new Error("Transaction fee payer required");for(let p=0;p<t.length;p++)if(t[p].programId===void 0)throw new Error(`Transaction instruction index ${p} has undefined program id`);const s=[],o=[];t.forEach(p=>{p.keys.forEach(I=>{o.push({...I})});const m=p.programId.toString();s.includes(m)||s.push(m)}),s.forEach(p=>{o.push({pubkey:new W(p),isSigner:!1,isWritable:!1})});const i=[];o.forEach(p=>{const m=p.pubkey.toString(),I=i.findIndex(_=>_.pubkey.toString()===m);I>-1?(i[I].isWritable=i[I].isWritable||p.isWritable,i[I].isSigner=i[I].isSigner||p.isSigner):i.push(p)}),i.sort(function(p,m){return p.isSigner!==m.isSigner?p.isSigner?-1:1:p.isWritable!==m.isWritable?p.isWritable?-1:1:p.pubkey.toBase58().localeCompare(m.pubkey.toBase58())});const a=i.findIndex(p=>p.pubkey.equals(n));if(a>-1){const[p]=i.splice(a,1);p.isSigner=!0,p.isWritable=!0,i.unshift(p)}else i.unshift({pubkey:n,isSigner:!0,isWritable:!0});for(const p of this.signatures){const m=i.findIndex(I=>I.pubkey.equals(p.publicKey));if(m>-1)i[m].isSigner||(i[m].isSigner=!0,console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release."));else throw new Error(`unknown signer: ${p.publicKey.toString()}`)}let c=0,l=0,u=0;const w=[],v=[];i.forEach(({pubkey:p,isSigner:m,isWritable:I})=>{m?(w.push(p.toString()),c+=1,I||(l+=1)):(v.push(p.toString()),I||(u+=1))});const g=w.concat(v),y=t.map(p=>{const{data:m,programId:I}=p;return{programIdIndex:g.indexOf(I.toString()),accounts:p.keys.map(_=>g.indexOf(_.pubkey.toString())),data:we.encode(m)}});return y.forEach(p=>{ue(p.programIdIndex>=0),p.accounts.forEach(m=>ue(m>=0))}),new nt({header:{numRequiredSignatures:c,numReadonlySignedAccounts:l,numReadonlyUnsignedAccounts:u},accountKeys:g,recentBlockhash:e,instructions:y})}_compile(){const e=this.compileMessage(),t=e.accountKeys.slice(0,e.header.numRequiredSignatures);return this.signatures.length===t.length&&this.signatures.every((s,o)=>t[o].equals(s.publicKey))||(this.signatures=t.map(n=>({signature:null,publicKey:n}))),e}serializeMessage(){return this._compile().serialize()}async getEstimatedFee(e){return(await e.getFeeForMessage(this.compileMessage())).value}setSigners(...e){if(e.length===0)throw new Error("No signers");const t=new Set;this.signatures=e.filter(n=>{const s=n.toString();return t.has(s)?!1:(t.add(s),!0)}).map(n=>({signature:null,publicKey:n}))}sign(...e){if(e.length===0)throw new Error("No signers");const t=new Set,n=[];for(const o of e){const i=o.publicKey.toString();t.has(i)||(t.add(i),n.push(o))}this.signatures=n.map(o=>({signature:null,publicKey:o.publicKey}));const s=this._compile();this._partialSign(s,...n)}partialSign(...e){if(e.length===0)throw new Error("No signers");const t=new Set,n=[];for(const o of e){const i=o.publicKey.toString();t.has(i)||(t.add(i),n.push(o))}const s=this._compile();this._partialSign(s,...n)}_partialSign(e,...t){const n=e.serialize();t.forEach(s=>{const o=to(n,s.secretKey);this._addSignature(s.publicKey,Et(o))})}addSignature(e,t){this._compile(),this._addSignature(e,t)}_addSignature(e,t){ue(t.length===64);const n=this.signatures.findIndex(s=>e.equals(s.publicKey));if(n<0)throw new Error(`unknown signer: ${e.toString()}`);this.signatures[n].signature=K.from(t)}verifySignatures(e){return this._verifySignatures(this.serializeMessage(),e===void 0?!0:e)}_verifySignatures(e,t){for(const{signature:n,publicKey:s}of this.signatures)if(n===null){if(t)return!1}else if(!Ta(n,e,s.toBytes()))return!1;return!0}serialize(e){const{requireAllSignatures:t,verifySignatures:n}=Object.assign({requireAllSignatures:!0,verifySignatures:!0},e),s=this.serializeMessage();if(n&&!this._verifySignatures(s,t))throw new Error("Signature verification failed");return this._serialize(s)}_serialize(e){const{signatures:t}=this,n=[];Oe(n,t.length);const s=n.length+t.length*64+e.length,o=K.alloc(s);return ue(t.length<256),K.from(n).copy(o,0),t.forEach(({signature:i},a)=>{i!==null&&(ue(i.length===64,"signature has invalid length"),K.from(i).copy(o,n.length+a*64))}),e.copy(o,n.length+t.length*64),ue(o.length<=_t,`Transaction too large: ${o.length} > ${_t}`),o}get keys(){return ue(this.instructions.length===1),this.instructions[0].keys.map(e=>e.pubkey)}get programId(){return ue(this.instructions.length===1),this.instructions[0].programId}get data(){return ue(this.instructions.length===1),this.instructions[0].data}static from(e){let t=[...e];const n=Pe(t);let s=[];for(let o=0;o<n;o++){const i=t.slice(0,Nt);t=t.slice(Nt),s.push(we.encode(K.from(i)))}return at.populate(nt.from(t),s)}static populate(e,t=[]){const n=new at;return n.recentBlockhash=e.recentBlockhash,e.header.numRequiredSignatures>0&&(n.feePayer=e.accountKeys[0]),t.forEach((s,o)=>{const i={signature:s==we.encode(Ma)?null:we.decode(s),publicKey:e.accountKeys[o]};n.signatures.push(i)}),e.instructions.forEach(s=>{const o=s.accounts.map(i=>{const a=e.accountKeys[i];return{pubkey:a,isSigner:n.signatures.some(c=>c.publicKey.toString()===a.toString())||e.isAccountSigner(i),isWritable:e.isAccountWritable(i)}});n.instructions.push(new Zr({keys:o,programId:e.accountKeys[s.programIdIndex],data:we.decode(s.data)}))}),n._message=e,n._json=n.toJSON(),n}}class io{get version(){return this.message.version}constructor(e,t){if(this.signatures=void 0,this.message=void 0,t!==void 0)ue(t.length===e.header.numRequiredSignatures,"Expected signatures length to be equal to the number of required signatures"),this.signatures=t;else{const n=[];for(let s=0;s<e.header.numRequiredSignatures;s++)n.push(new Uint8Array(Nt));this.signatures=n}this.message=e}serialize(){const e=this.message.serialize(),t=Array();Oe(t,this.signatures.length);const n=z([ce(t.length,"encodedSignaturesLength"),Ee(Fa(),this.signatures.length,"signatures"),ce(e.length,"serializedMessage")]),s=new Uint8Array(2048),o=n.encode({encodedSignaturesLength:new Uint8Array(t),signatures:this.signatures,serializedMessage:e},s);return s.slice(0,o)}static deserialize(e){let t=[...e];const n=[],s=Pe(t);for(let i=0;i<s;i++)n.push(new Uint8Array(t.splice(0,Nt)));const o=oo.deserialize(new Uint8Array(t));return new io(o,n)}sign(e){const t=this.message.serialize(),n=this.message.staticAccountKeys.slice(0,this.message.header.numRequiredSignatures);for(const s of e){const o=n.findIndex(i=>i.equals(s.publicKey));ue(o>=0,`Cannot sign with non signer key ${s.publicKey.toBase58()}`),this.signatures[o]=to(t,s.secretKey)}}addSignature(e,t){ue(t.byteLength===64,"Signature must be 64 bytes long");const s=this.message.staticAccountKeys.slice(0,this.message.header.numRequiredSignatures).findIndex(o=>o.equals(e));ue(s>=0,`Can not add signature; \`${e.toBase58()}\` is not required to sign this transaction`),this.signatures[s]=t}}new W("SysvarC1ock11111111111111111111111111111111");new W("SysvarEpochSchedu1e111111111111111111111111");new W("Sysvar1nstructions1111111111111111111111111");new W("SysvarRecentB1ockHashes11111111111111111111");new W("SysvarRent111111111111111111111111111111111");new W("SysvarRewards111111111111111111111111111111");new W("SysvarS1otHashes111111111111111111111111111");new W("SysvarS1otHistory11111111111111111111111111");new W("SysvarStakeHistory1111111111111111111111111");function St(r){return new Promise(e=>setTimeout(e,r))}const Ka=me("lamportsPerSignature"),ao=z([H("version"),H("state"),Q("authorizedPubkey"),Q("nonce"),z([Ka],"feeCalculator")]);ao.span;class dr{constructor(e){this.authorizedPubkey=void 0,this.nonce=void 0,this.feeCalculator=void 0,this.authorizedPubkey=e.authorizedPubkey,this.nonce=e.nonce,this.feeCalculator=e.feeCalculator}static fromAccountData(e){const t=ao.decode(Et(e),0);return new dr({authorizedPubkey:new W(t.authorizedPubkey),nonce:new W(t.nonce).toString(),feeCalculator:t.feeCalculator})}}const Ha=r=>{const e=r.decode.bind(r),t=r.encode.bind(r);return{decode:e,encode:t}},Ga=r=>e=>{const t=ce(r,e),{encode:n,decode:s}=Ha(t),o=t;return o.decode=(i,a)=>{const c=s(i,a);return Ni(K.from(c))},o.encode=(i,a,c)=>{const l=zi(i,r);return n(l,a,c)},o},At=Ga(8);Object.freeze({Create:{index:0,layout:z([H("instruction"),Te("lamports"),Te("space"),Q("programId")])},Assign:{index:1,layout:z([H("instruction"),Q("programId")])},Transfer:{index:2,layout:z([H("instruction"),At("lamports")])},CreateWithSeed:{index:3,layout:z([H("instruction"),Q("base"),vt("seed"),Te("lamports"),Te("space"),Q("programId")])},AdvanceNonceAccount:{index:4,layout:z([H("instruction")])},WithdrawNonceAccount:{index:5,layout:z([H("instruction"),Te("lamports")])},InitializeNonceAccount:{index:6,layout:z([H("instruction"),Q("authorized")])},AuthorizeNonceAccount:{index:7,layout:z([H("instruction"),Q("authorized")])},Allocate:{index:8,layout:z([H("instruction"),Te("space")])},AllocateWithSeed:{index:9,layout:z([H("instruction"),Q("base"),vt("seed"),Te("space"),Q("programId")])},AssignWithSeed:{index:10,layout:z([H("instruction"),Q("base"),vt("seed"),Q("programId")])},TransferWithSeed:{index:11,layout:z([H("instruction"),At("lamports"),vt("seed"),Q("programId")])},UpgradeNonceAccount:{index:12,layout:z([H("instruction")])}});new W("11111111111111111111111111111111");new W("BPFLoader2111111111111111111111111111111111");var Wa=Object.prototype.toString,$a=Object.keys||function(r){var e=[];for(var t in r)e.push(t);return e};function Pt(r,e){var t,n,s,o,i,a,c;if(r===!0)return"true";if(r===!1)return"false";switch(typeof r){case"object":if(r===null)return null;if(r.toJSON&&typeof r.toJSON=="function")return Pt(r.toJSON(),e);if(c=Wa.call(r),c==="[object Array]"){for(s="[",n=r.length-1,t=0;t<n;t++)s+=Pt(r[t],!0)+",";return n>-1&&(s+=Pt(r[t],!0)),s+"]"}else if(c==="[object Object]"){for(o=$a(r).sort(),n=o.length,s="",t=0;t<n;)i=o[t],a=Pt(r[i],!1),a!==void 0&&(s&&(s+=","),s+=JSON.stringify(i)+":"+a),t++;return"{"+s+"}"}else return JSON.stringify(r);case"function":case"undefined":return e?null:void 0;case"string":return JSON.stringify(r);default:return isFinite(r)?r:null}}var ja=function(r){var e=Pt(r,!1);if(e!==void 0)return""+e},Jr=ja;const Ct=32;function zn(r){let e=0;for(;r>1;)r/=2,e++;return e}function Va(r){return r===0?1:(r--,r|=r>>1,r|=r>>2,r|=r>>4,r|=r>>8,r|=r>>16,r|=r>>32,r+1)}class Za{constructor(e,t,n,s,o){this.slotsPerEpoch=void 0,this.leaderScheduleSlotOffset=void 0,this.warmup=void 0,this.firstNormalEpoch=void 0,this.firstNormalSlot=void 0,this.slotsPerEpoch=e,this.leaderScheduleSlotOffset=t,this.warmup=n,this.firstNormalEpoch=s,this.firstNormalSlot=o}getEpoch(e){return this.getEpochAndSlotIndex(e)[0]}getEpochAndSlotIndex(e){if(e<this.firstNormalSlot){const t=zn(Va(e+Ct+1))-zn(Ct)-1,n=this.getSlotsInEpoch(t),s=e-(n-Ct);return[t,s]}else{const t=e-this.firstNormalSlot,n=Math.floor(t/this.slotsPerEpoch),s=this.firstNormalEpoch+n,o=t%this.slotsPerEpoch;return[s,o]}}getFirstSlotInEpoch(e){return e<=this.firstNormalEpoch?(Math.pow(2,e)-1)*Ct:(e-this.firstNormalEpoch)*this.slotsPerEpoch+this.firstNormalSlot}getLastSlotInEpoch(e){return this.getFirstSlotInEpoch(e)+this.getSlotsInEpoch(e)-1}getSlotsInEpoch(e){return e<this.firstNormalEpoch?Math.pow(2,e+zn(Ct)):this.slotsPerEpoch}}class Xr extends Error{constructor(e,t){super(e),this.logs=void 0,this.logs=t}}class M extends Error{constructor({code:e,message:t,data:n},s){super(s!=null?`${s}: ${t}`:t),this.code=void 0,this.data=void 0,this.code=e,this.data=n,this.name="SolanaJSONRPCError"}}var Ja=globalThis.fetch;class Xa extends La{constructor(e,t,n){const s=o=>{const i=Ca(o,{autoconnect:!0,max_reconnects:5,reconnect:!0,reconnect_interval:1e3,...t});return"socket"in i?this.underlyingSocket=i.socket:this.underlyingSocket=i,i};super(s,e,t,n),this.underlyingSocket=void 0}call(...e){const t=this.underlyingSocket?.readyState;return t===1?super.call(...e):Promise.reject(new Error("Tried to call a JSON-RPC method `"+e[0]+"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was "+t+")"))}notify(...e){const t=this.underlyingSocket?.readyState;return t===1?super.notify(...e):Promise.reject(new Error("Tried to send a JSON-RPC notification `"+e[0]+"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was "+t+")"))}}const Ya=160,Qa=64,ec=Ya/Qa,tc=1e3/ec;function nc(r,e){let t;try{t=r.layout.decode(e)}catch(n){throw new Error("invalid instruction; "+n)}if(t.typeIndex!==r.index)throw new Error(`invalid account data; account type mismatch ${t.typeIndex} != ${r.index}`);return t}const Yr=56;class Qr{constructor(e){this.key=void 0,this.state=void 0,this.key=e.key,this.state=e.state}isActive(){const e=BigInt("0xffffffffffffffff");return this.state.deactivationSlot===e}static deserialize(e){const t=nc(rc,e),n=e.length-Yr;ue(n>=0,"lookup table is invalid"),ue(n%32===0,"lookup table is invalid");const s=n/32,{addresses:o}=z([Ee(Q(),s,"addresses")]).decode(e.slice(Yr));return{deactivationSlot:t.deactivationSlot,lastExtendedSlot:t.lastExtendedSlot,lastExtendedSlotStartIndex:t.lastExtendedStartIndex,authority:t.authority.length!==0?new W(t.authority[0]):void 0,addresses:o.map(i=>new W(i))}}}const rc={index:1,layout:z([H("typeIndex"),At("deactivationSlot"),me("lastExtendedSlot"),ne("lastExtendedStartIndex"),ne(),Ee(Q(),pt(ne(),-1),"authority")])},sc=/^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i;function oc(r){const e=r.match(sc);if(e==null)throw TypeError(`Failed to validate endpoint URL \`${r}\``);const[t,n,s,o]=e,i=r.startsWith("https:")?"wss:":"ws:",a=s==null?null:parseInt(s.slice(1),10),c=a==null?"":`:${a+1}`;return`${i}//${n}${c}${o}`}const ge=Gt(ur(W),L(),r=>new W(r)),co=lr([L(),fe("base64")]),hr=Gt(ur(K),co,r=>K.from(r[0],"base64")),ic=30*1e3;function ac(r){if(/^https?:/.test(r)===!1)throw new TypeError("Endpoint URL must start with `http:` or `https:`.");return r}function le(r){let e,t;if(typeof r=="string")e=r;else if(r){const{commitment:n,...s}=r;e=n,t=s}return{commitment:e,config:t}}function uo(r){return Be([k({jsonrpc:fe("2.0"),id:L(),result:r}),k({jsonrpc:fe("2.0"),id:L(),error:k({code:Ht(),message:L(),data:G(Vi())})})])}const cc=uo(Ht());function Z(r){return Gt(uo(r),cc,e=>"error"in e?e:{...e,result:T(e.result,r)})}function pe(r){return Z(k({context:k({slot:f()}),value:r}))}function bn(r){return k({context:k({slot:f()}),value:r})}function Mn(r,e){return r===0?new qt({header:e.header,staticAccountKeys:e.accountKeys.map(t=>new W(t)),recentBlockhash:e.recentBlockhash,compiledInstructions:e.instructions.map(t=>({programIdIndex:t.programIdIndex,accountKeyIndexes:t.accounts,data:we.decode(t.data)})),addressTableLookups:e.addressTableLookups}):new nt(e)}const uc=k({foundation:f(),foundationTerm:f(),initial:f(),taper:f(),terminal:f()}),lc=Z(O(U(k({epoch:f(),effectiveSlot:f(),amount:f(),postBalance:f(),commission:G(U(f()))})))),fc=O(k({slot:f(),prioritizationFee:f()})),dc=k({total:f(),validator:f(),foundation:f(),epoch:f()}),hc=k({epoch:f(),slotIndex:f(),slotsInEpoch:f(),absoluteSlot:f(),blockHeight:G(f()),transactionCount:G(f())}),pc=k({slotsPerEpoch:f(),leaderScheduleSlotOffset:f(),warmup:tt(),firstNormalEpoch:f(),firstNormalSlot:f()}),gc=Ds(L(),O(f())),mt=U(Be([k({}),L()])),yc=k({err:mt}),mc=fe("receivedSignature"),bc=k({"solana-core":L(),"feature-set":G(f())}),es=pe(k({err:U(Be([k({}),L()])),logs:U(O(L())),accounts:G(U(O(U(k({executable:tt(),owner:L(),lamports:f(),data:O(L()),rentEpoch:G(f())}))))),unitsConsumed:G(f()),returnData:G(U(k({programId:L(),data:lr([L(),fe("base64")])})))})),wc=pe(k({byIdentity:Ds(L(),O(f())),range:k({firstSlot:f(),lastSlot:f()})}));function Sc(r,e,t,n,s,o){const i=t||Ja;let a;o!=null&&console.warn("You have supplied an `httpAgent` when creating a `Connection` in a browser environment.It has been ignored; `httpAgent` is only used in Node environments.");let c;return n&&(c=async(u,w)=>{const v=await new Promise((g,y)=>{try{n(u,w,(p,m)=>g([p,m]))}catch(p){y(p)}});return await i(...v)}),new _a(async(u,w)=>{const v={method:"POST",body:u,agent:a,headers:Object.assign({"Content-Type":"application/json"},e||{},Su)};try{let g=5,y,p=500;for(;c?y=await c(r,v):y=await i(r,v),!(y.status!==429||s===!0||(g-=1,g===0));)console.log(`Server responded with ${y.status} ${y.statusText}.  Retrying after ${p}ms delay...`),await St(p),p*=2;const m=await y.text();y.ok?w(null,m):w(new Error(`${y.status} ${y.statusText}: ${m}`))}catch(g){g instanceof Error&&w(g)}},{})}function vc(r){return(e,t)=>new Promise((n,s)=>{r.request(e,t,(o,i)=>{if(o){s(o);return}n(i)})})}function xc(r){return e=>new Promise((t,n)=>{e.length===0&&t([]);const s=e.map(o=>r.request(o.methodName,o.args));r.request(s,(o,i)=>{if(o){n(o);return}t(i)})})}const _c=Z(uc),kc=Z(dc),Ec=Z(fc),Ac=Z(hc),Ic=Z(pc),Rc=Z(gc),Bc=Z(f()),Lc=pe(k({total:f(),circulating:f(),nonCirculating:f(),nonCirculatingAccounts:O(ge)})),$n=k({amount:L(),uiAmount:U(f()),decimals:f(),uiAmountString:G(L())}),Cc=pe(O(k({address:ge,amount:L(),uiAmount:U(f()),decimals:f(),uiAmountString:G(L())}))),Tc=pe(O(k({pubkey:ge,account:k({executable:tt(),owner:ge,lamports:f(),data:hr,rentEpoch:f()})}))),jn=k({program:L(),parsed:Ht(),space:f()}),Pc=pe(O(k({pubkey:ge,account:k({executable:tt(),owner:ge,lamports:f(),data:jn,rentEpoch:f()})}))),Oc=pe(O(k({lamports:f(),address:ge}))),Dt=k({executable:tt(),owner:ge,lamports:f(),data:hr,rentEpoch:f()}),Uc=k({pubkey:ge,account:Dt}),Fc=Gt(Be([ur(K),jn]),Be([co,jn]),r=>Array.isArray(r)?T(r,hr):r),Vn=k({executable:tt(),owner:ge,lamports:f(),data:Fc,rentEpoch:f()}),Nc=k({pubkey:ge,account:Vn}),qc=k({state:Be([fe("active"),fe("inactive"),fe("activating"),fe("deactivating")]),active:f(),inactive:f()}),Dc=Z(O(k({signature:L(),slot:f(),err:mt,memo:U(L()),blockTime:G(U(f()))}))),zc=Z(O(k({signature:L(),slot:f(),err:mt,memo:U(L()),blockTime:G(U(f()))}))),Mc=k({subscription:f(),result:bn(Dt)}),Kc=k({pubkey:ge,account:Dt}),Hc=k({subscription:f(),result:bn(Kc)}),Gc=k({parent:f(),slot:f(),root:f()}),Wc=k({subscription:f(),result:Gc}),$c=Be([k({type:Be([fe("firstShredReceived"),fe("completed"),fe("optimisticConfirmation"),fe("root")]),slot:f(),timestamp:f()}),k({type:fe("createdBank"),parent:f(),slot:f(),timestamp:f()}),k({type:fe("frozen"),slot:f(),timestamp:f(),stats:k({numTransactionEntries:f(),numSuccessfulTransactions:f(),numFailedTransactions:f(),maxTransactionsPerEntry:f()})}),k({type:fe("dead"),slot:f(),timestamp:f(),err:L()})]),jc=k({subscription:f(),result:$c}),Vc=k({subscription:f(),result:bn(Be([yc,mc]))}),Zc=k({subscription:f(),result:f()}),Jc=k({pubkey:L(),gossip:U(L()),tpu:U(L()),rpc:U(L()),version:U(L())}),ts=k({votePubkey:L(),nodePubkey:L(),activatedStake:f(),epochVoteAccount:tt(),epochCredits:O(lr([f(),f(),f()])),commission:f(),lastVote:f(),rootSlot:U(f())}),Xc=Z(k({current:O(ts),delinquent:O(ts)})),Yc=Be([fe("processed"),fe("confirmed"),fe("finalized")]),Qc=k({slot:f(),confirmations:U(f()),err:mt,confirmationStatus:G(Yc)}),eu=pe(O(U(Qc))),tu=Z(f()),lo=k({accountKey:ge,writableIndexes:O(f()),readonlyIndexes:O(f())}),pr=k({signatures:O(L()),message:k({accountKeys:O(L()),header:k({numRequiredSignatures:f(),numReadonlySignedAccounts:f(),numReadonlyUnsignedAccounts:f()}),instructions:O(k({accounts:O(f()),data:L(),programIdIndex:f()})),recentBlockhash:L(),addressTableLookups:G(O(lo))})}),fo=k({pubkey:ge,signer:tt(),writable:tt(),source:G(Be([fe("transaction"),fe("lookupTable")]))}),ho=k({accountKeys:O(fo),signatures:O(L())}),po=k({parsed:Ht(),program:L(),programId:ge}),go=k({accounts:O(ge),data:L(),programId:ge}),nu=Be([go,po]),ru=Be([k({parsed:Ht(),program:L(),programId:L()}),k({accounts:O(L()),data:L(),programId:L()})]),yo=Gt(nu,ru,r=>"accounts"in r?T(r,go):T(r,po)),mo=k({signatures:O(L()),message:k({accountKeys:O(fo),instructions:O(yo),recentBlockhash:L(),addressTableLookups:G(U(O(lo)))})}),an=k({accountIndex:f(),mint:L(),owner:G(L()),uiTokenAmount:$n}),bo=k({writable:O(ge),readonly:O(ge)}),wn=k({err:mt,fee:f(),innerInstructions:G(U(O(k({index:f(),instructions:O(k({accounts:O(f()),data:L(),programIdIndex:f()}))})))),preBalances:O(f()),postBalances:O(f()),logMessages:G(U(O(L()))),preTokenBalances:G(U(O(an))),postTokenBalances:G(U(O(an))),loadedAddresses:G(bo),computeUnitsConsumed:G(f())}),gr=k({err:mt,fee:f(),innerInstructions:G(U(O(k({index:f(),instructions:O(yo)})))),preBalances:O(f()),postBalances:O(f()),logMessages:G(U(O(L()))),preTokenBalances:G(U(O(an))),postTokenBalances:G(U(O(an))),loadedAddresses:G(bo),computeUnitsConsumed:G(f())}),Bt=Be([fe(0),fe("legacy")]),bt=k({pubkey:L(),lamports:f(),postBalance:U(f()),rewardType:U(L()),commission:G(U(f()))}),su=Z(U(k({blockhash:L(),previousBlockhash:L(),parentSlot:f(),transactions:O(k({transaction:pr,meta:U(wn),version:G(Bt)})),rewards:G(O(bt)),blockTime:U(f()),blockHeight:U(f())}))),ou=Z(U(k({blockhash:L(),previousBlockhash:L(),parentSlot:f(),rewards:G(O(bt)),blockTime:U(f()),blockHeight:U(f())}))),iu=Z(U(k({blockhash:L(),previousBlockhash:L(),parentSlot:f(),transactions:O(k({transaction:ho,meta:U(wn),version:G(Bt)})),rewards:G(O(bt)),blockTime:U(f()),blockHeight:U(f())}))),au=Z(U(k({blockhash:L(),previousBlockhash:L(),parentSlot:f(),transactions:O(k({transaction:mo,meta:U(gr),version:G(Bt)})),rewards:G(O(bt)),blockTime:U(f()),blockHeight:U(f())}))),cu=Z(U(k({blockhash:L(),previousBlockhash:L(),parentSlot:f(),transactions:O(k({transaction:ho,meta:U(gr),version:G(Bt)})),rewards:G(O(bt)),blockTime:U(f()),blockHeight:U(f())}))),uu=Z(U(k({blockhash:L(),previousBlockhash:L(),parentSlot:f(),rewards:G(O(bt)),blockTime:U(f()),blockHeight:U(f())}))),lu=Z(U(k({blockhash:L(),previousBlockhash:L(),parentSlot:f(),transactions:O(k({transaction:pr,meta:U(wn)})),rewards:G(O(bt)),blockTime:U(f())}))),ns=Z(U(k({blockhash:L(),previousBlockhash:L(),parentSlot:f(),signatures:O(L()),blockTime:U(f())}))),Kn=Z(U(k({slot:f(),meta:wn,blockTime:G(U(f())),transaction:pr,version:G(Bt)}))),Jt=Z(U(k({slot:f(),transaction:mo,meta:U(gr),blockTime:G(U(f())),version:G(Bt)}))),fu=pe(k({blockhash:L(),feeCalculator:k({lamportsPerSignature:f()})})),du=pe(k({blockhash:L(),lastValidBlockHeight:f()})),hu=k({slot:f(),numTransactions:f(),numSlots:f(),samplePeriodSecs:f()}),pu=Z(O(hu)),gu=pe(U(k({feeCalculator:k({lamportsPerSignature:f()})}))),yu=Z(L()),mu=Z(L()),bu=k({err:mt,logs:O(L()),signature:L()}),wu=k({result:bn(bu),subscription:f()}),Su={"solana-client":"js/0.0.0-development"};class Eu{constructor(e,t){this._commitment=void 0,this._confirmTransactionInitialTimeout=void 0,this._rpcEndpoint=void 0,this._rpcWsEndpoint=void 0,this._rpcClient=void 0,this._rpcRequest=void 0,this._rpcBatchRequest=void 0,this._rpcWebSocket=void 0,this._rpcWebSocketConnected=!1,this._rpcWebSocketHeartbeat=null,this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketGeneration=0,this._disableBlockhashCaching=!1,this._pollingBlockhash=!1,this._blockhashInfo={latestBlockhash:null,lastFetch:0,transactionSignatures:[],simulatedSignatures:[]},this._nextClientSubscriptionId=0,this._subscriptionDisposeFunctionsByClientSubscriptionId={},this._subscriptionHashByClientSubscriptionId={},this._subscriptionStateChangeCallbacksByHash={},this._subscriptionCallbacksByServerSubscriptionId={},this._subscriptionsByHash={},this._subscriptionsAutoDisposedByRpc=new Set,this.getBlockHeight=(()=>{const l={};return async u=>{const{commitment:w,config:v}=le(u),g=this._buildArgs([],w,void 0,v),y=Jr(g);return l[y]=l[y]??(async()=>{try{const p=await this._rpcRequest("getBlockHeight",g),m=T(p,Z(f()));if("error"in m)throw new M(m.error,"failed to get block height information");return m.result}finally{delete l[y]}})(),await l[y]}})();let n,s,o,i,a,c;t&&typeof t=="string"?this._commitment=t:t&&(this._commitment=t.commitment,this._confirmTransactionInitialTimeout=t.confirmTransactionInitialTimeout,n=t.wsEndpoint,s=t.httpHeaders,o=t.fetch,i=t.fetchMiddleware,a=t.disableRetryOnRateLimit,c=t.httpAgent),this._rpcEndpoint=ac(e),this._rpcWsEndpoint=n||oc(e),this._rpcClient=Sc(e,s,o,i,a,c),this._rpcRequest=vc(this._rpcClient),this._rpcBatchRequest=xc(this._rpcClient),this._rpcWebSocket=new Xa(this._rpcWsEndpoint,{autoconnect:!1,max_reconnects:1/0}),this._rpcWebSocket.on("open",this._wsOnOpen.bind(this)),this._rpcWebSocket.on("error",this._wsOnError.bind(this)),this._rpcWebSocket.on("close",this._wsOnClose.bind(this)),this._rpcWebSocket.on("accountNotification",this._wsOnAccountNotification.bind(this)),this._rpcWebSocket.on("programNotification",this._wsOnProgramAccountNotification.bind(this)),this._rpcWebSocket.on("slotNotification",this._wsOnSlotNotification.bind(this)),this._rpcWebSocket.on("slotsUpdatesNotification",this._wsOnSlotUpdatesNotification.bind(this)),this._rpcWebSocket.on("signatureNotification",this._wsOnSignatureNotification.bind(this)),this._rpcWebSocket.on("rootNotification",this._wsOnRootNotification.bind(this)),this._rpcWebSocket.on("logsNotification",this._wsOnLogsNotification.bind(this))}get commitment(){return this._commitment}get rpcEndpoint(){return this._rpcEndpoint}async getBalanceAndContext(e,t){const{commitment:n,config:s}=le(t),o=this._buildArgs([e.toBase58()],n,void 0,s),i=await this._rpcRequest("getBalance",o),a=T(i,pe(f()));if("error"in a)throw new M(a.error,`failed to get balance for ${e.toBase58()}`);return a.result}async getBalance(e,t){return await this.getBalanceAndContext(e,t).then(n=>n.value).catch(n=>{throw new Error("failed to get balance of account "+e.toBase58()+": "+n)})}async getBlockTime(e){const t=await this._rpcRequest("getBlockTime",[e]),n=T(t,Z(U(f())));if("error"in n)throw new M(n.error,`failed to get block time for slot ${e}`);return n.result}async getMinimumLedgerSlot(){const e=await this._rpcRequest("minimumLedgerSlot",[]),t=T(e,Z(f()));if("error"in t)throw new M(t.error,"failed to get minimum ledger slot");return t.result}async getFirstAvailableBlock(){const e=await this._rpcRequest("getFirstAvailableBlock",[]),t=T(e,Bc);if("error"in t)throw new M(t.error,"failed to get first available block");return t.result}async getSupply(e){let t={};typeof e=="string"?t={commitment:e}:e?t={...e,commitment:e&&e.commitment||this.commitment}:t={commitment:this.commitment};const n=await this._rpcRequest("getSupply",[t]),s=T(n,Lc);if("error"in s)throw new M(s.error,"failed to get supply");return s.result}async getTokenSupply(e,t){const n=this._buildArgs([e.toBase58()],t),s=await this._rpcRequest("getTokenSupply",n),o=T(s,pe($n));if("error"in o)throw new M(o.error,"failed to get token supply");return o.result}async getTokenAccountBalance(e,t){const n=this._buildArgs([e.toBase58()],t),s=await this._rpcRequest("getTokenAccountBalance",n),o=T(s,pe($n));if("error"in o)throw new M(o.error,"failed to get token account balance");return o.result}async getTokenAccountsByOwner(e,t,n){const{commitment:s,config:o}=le(n);let i=[e.toBase58()];"mint"in t?i.push({mint:t.mint.toBase58()}):i.push({programId:t.programId.toBase58()});const a=this._buildArgs(i,s,"base64",o),c=await this._rpcRequest("getTokenAccountsByOwner",a),l=T(c,Tc);if("error"in l)throw new M(l.error,`failed to get token accounts owned by account ${e.toBase58()}`);return l.result}async getParsedTokenAccountsByOwner(e,t,n){let s=[e.toBase58()];"mint"in t?s.push({mint:t.mint.toBase58()}):s.push({programId:t.programId.toBase58()});const o=this._buildArgs(s,n,"jsonParsed"),i=await this._rpcRequest("getTokenAccountsByOwner",o),a=T(i,Pc);if("error"in a)throw new M(a.error,`failed to get token accounts owned by account ${e.toBase58()}`);return a.result}async getLargestAccounts(e){const t={...e,commitment:e&&e.commitment||this.commitment},n=t.filter||t.commitment?[t]:[],s=await this._rpcRequest("getLargestAccounts",n),o=T(s,Oc);if("error"in o)throw new M(o.error,"failed to get largest accounts");return o.result}async getTokenLargestAccounts(e,t){const n=this._buildArgs([e.toBase58()],t),s=await this._rpcRequest("getTokenLargestAccounts",n),o=T(s,Cc);if("error"in o)throw new M(o.error,"failed to get token largest accounts");return o.result}async getAccountInfoAndContext(e,t){const{commitment:n,config:s}=le(t),o=this._buildArgs([e.toBase58()],n,"base64",s),i=await this._rpcRequest("getAccountInfo",o),a=T(i,pe(U(Dt)));if("error"in a)throw new M(a.error,`failed to get info about account ${e.toBase58()}`);return a.result}async getParsedAccountInfo(e,t){const{commitment:n,config:s}=le(t),o=this._buildArgs([e.toBase58()],n,"jsonParsed",s),i=await this._rpcRequest("getAccountInfo",o),a=T(i,pe(U(Vn)));if("error"in a)throw new M(a.error,`failed to get info about account ${e.toBase58()}`);return a.result}async getAccountInfo(e,t){try{return(await this.getAccountInfoAndContext(e,t)).value}catch(n){throw new Error("failed to get info about account "+e.toBase58()+": "+n)}}async getMultipleParsedAccounts(e,t){const{commitment:n,config:s}=le(t),o=e.map(l=>l.toBase58()),i=this._buildArgs([o],n,"jsonParsed",s),a=await this._rpcRequest("getMultipleAccounts",i),c=T(a,pe(O(U(Vn))));if("error"in c)throw new M(c.error,`failed to get info for accounts ${o}`);return c.result}async getMultipleAccountsInfoAndContext(e,t){const{commitment:n,config:s}=le(t),o=e.map(l=>l.toBase58()),i=this._buildArgs([o],n,"base64",s),a=await this._rpcRequest("getMultipleAccounts",i),c=T(a,pe(O(U(Dt))));if("error"in c)throw new M(c.error,`failed to get info for accounts ${o}`);return c.result}async getMultipleAccountsInfo(e,t){return(await this.getMultipleAccountsInfoAndContext(e,t)).value}async getStakeActivation(e,t,n){const{commitment:s,config:o}=le(t),i=this._buildArgs([e.toBase58()],s,void 0,{...o,epoch:n??o?.epoch}),a=await this._rpcRequest("getStakeActivation",i),c=T(a,Z(qc));if("error"in c)throw new M(c.error,`failed to get Stake Activation ${e.toBase58()}`);return c.result}async getProgramAccounts(e,t){const{commitment:n,config:s}=le(t),{encoding:o,...i}=s||{},a=this._buildArgs([e.toBase58()],n,o||"base64",i),c=await this._rpcRequest("getProgramAccounts",a),l=T(c,Z(O(Uc)));if("error"in l)throw new M(l.error,`failed to get accounts owned by program ${e.toBase58()}`);return l.result}async getParsedProgramAccounts(e,t){const{commitment:n,config:s}=le(t),o=this._buildArgs([e.toBase58()],n,"jsonParsed",s),i=await this._rpcRequest("getProgramAccounts",o),a=T(i,Z(O(Nc)));if("error"in a)throw new M(a.error,`failed to get accounts owned by program ${e.toBase58()}`);return a.result}async confirmTransaction(e,t){let n;if(typeof e=="string")n=e;else{const o=e;if(o.abortSignal?.aborted)return Promise.reject(o.abortSignal.reason);n=o.signature}let s;try{s=we.decode(n)}catch{throw new Error("signature must be base58 encoded: "+n)}return ue(s.length===64,"signature has invalid length"),typeof e=="string"?await this.confirmTransactionUsingLegacyTimeoutStrategy({commitment:t||this.commitment,signature:n}):"lastValidBlockHeight"in e?await this.confirmTransactionUsingBlockHeightExceedanceStrategy({commitment:t||this.commitment,strategy:e}):await this.confirmTransactionUsingDurableNonceStrategy({commitment:t||this.commitment,strategy:e})}getCancellationPromise(e){return new Promise((t,n)=>{e!=null&&(e.aborted?n(e.reason):e.addEventListener("abort",()=>{n(e.reason)}))})}getTransactionConfirmationPromise({commitment:e,signature:t}){let n,s,o=!1;const i=new Promise((c,l)=>{try{n=this.onSignature(t,(w,v)=>{n=void 0;const g={context:v,value:w};c({__type:je.PROCESSED,response:g})},e);const u=new Promise(w=>{n==null?w():s=this._onSubscriptionStateChange(n,v=>{v==="subscribed"&&w()})});(async()=>{if(await u,o)return;const w=await this.getSignatureStatus(t);if(o||w==null)return;const{context:v,value:g}=w;if(g!=null)if(g?.err)l(g.err);else{switch(e){case"confirmed":case"single":case"singleGossip":{if(g.confirmationStatus==="processed")return;break}case"finalized":case"max":case"root":{if(g.confirmationStatus==="processed"||g.confirmationStatus==="confirmed")return;break}case"processed":case"recent":}o=!0,c({__type:je.PROCESSED,response:{context:v,value:g}})}})()}catch(u){l(u)}});return{abortConfirmation:()=>{s&&(s(),s=void 0),n!=null&&(this.removeSignatureListener(n),n=void 0)},confirmationPromise:i}}async confirmTransactionUsingBlockHeightExceedanceStrategy({commitment:e,strategy:{abortSignal:t,lastValidBlockHeight:n,signature:s}}){let o=!1;const i=new Promise(w=>{const v=async()=>{try{return await this.getBlockHeight(e)}catch{return-1}};(async()=>{let g=await v();if(!o){for(;g<=n;)if(await St(1e3),o||(g=await v(),o))return;w({__type:je.BLOCKHEIGHT_EXCEEDED})}})()}),{abortConfirmation:a,confirmationPromise:c}=this.getTransactionConfirmationPromise({commitment:e,signature:s}),l=this.getCancellationPromise(t);let u;try{const w=await Promise.race([l,c,i]);if(w.__type===je.PROCESSED)u=w.response;else throw new ro(s)}finally{o=!0,a()}return u}async confirmTransactionUsingDurableNonceStrategy({commitment:e,strategy:{abortSignal:t,minContextSlot:n,nonceAccountPubkey:s,nonceValue:o,signature:i}}){let a=!1;const c=new Promise(g=>{let y=o,p=null;const m=async()=>{try{const{context:I,value:_}=await this.getNonceAndContext(s,{commitment:e,minContextSlot:n});return p=I.slot,_?.nonce}catch{return y}};(async()=>{if(y=await m(),!a)for(;;){if(o!==y){g({__type:je.NONCE_INVALID,slotInWhichNonceDidAdvance:p});return}if(await St(2e3),a||(y=await m(),a))return}})()}),{abortConfirmation:l,confirmationPromise:u}=this.getTransactionConfirmationPromise({commitment:e,signature:i}),w=this.getCancellationPromise(t);let v;try{const g=await Promise.race([w,u,c]);if(g.__type===je.PROCESSED)v=g.response;else{let y;for(;;){const p=await this.getSignatureStatus(i);if(p==null)break;if(p.context.slot<(g.slotInWhichNonceDidAdvance??n)){await St(400);continue}y=p;break}if(y?.value){const p=e||"finalized",{confirmationStatus:m}=y.value;switch(p){case"processed":case"recent":if(m!=="processed"&&m!=="confirmed"&&m!=="finalized")throw new Tt(i);break;case"confirmed":case"single":case"singleGossip":if(m!=="confirmed"&&m!=="finalized")throw new Tt(i);break;case"finalized":case"max":case"root":if(m!=="finalized")throw new Tt(i);break;default:(I=>{})(p)}v={context:y.context,value:{err:y.value.err}}}else throw new Tt(i)}}finally{a=!0,l()}return v}async confirmTransactionUsingLegacyTimeoutStrategy({commitment:e,signature:t}){let n;const s=new Promise(c=>{let l=this._confirmTransactionInitialTimeout||6e4;switch(e){case"processed":case"recent":case"single":case"confirmed":case"singleGossip":{l=this._confirmTransactionInitialTimeout||3e4;break}}n=setTimeout(()=>c({__type:je.TIMED_OUT,timeoutMs:l}),l)}),{abortConfirmation:o,confirmationPromise:i}=this.getTransactionConfirmationPromise({commitment:e,signature:t});let a;try{const c=await Promise.race([i,s]);if(c.__type===je.PROCESSED)a=c.response;else throw new so(t,c.timeoutMs/1e3)}finally{clearTimeout(n),o()}return a}async getClusterNodes(){const e=await this._rpcRequest("getClusterNodes",[]),t=T(e,Z(O(Jc)));if("error"in t)throw new M(t.error,"failed to get cluster nodes");return t.result}async getVoteAccounts(e){const t=this._buildArgs([],e),n=await this._rpcRequest("getVoteAccounts",t),s=T(n,Xc);if("error"in s)throw new M(s.error,"failed to get vote accounts");return s.result}async getSlot(e){const{commitment:t,config:n}=le(e),s=this._buildArgs([],t,void 0,n),o=await this._rpcRequest("getSlot",s),i=T(o,Z(f()));if("error"in i)throw new M(i.error,"failed to get slot");return i.result}async getSlotLeader(e){const{commitment:t,config:n}=le(e),s=this._buildArgs([],t,void 0,n),o=await this._rpcRequest("getSlotLeader",s),i=T(o,Z(L()));if("error"in i)throw new M(i.error,"failed to get slot leader");return i.result}async getSlotLeaders(e,t){const n=[e,t],s=await this._rpcRequest("getSlotLeaders",n),o=T(s,Z(O(ge)));if("error"in o)throw new M(o.error,"failed to get slot leaders");return o.result}async getSignatureStatus(e,t){const{context:n,value:s}=await this.getSignatureStatuses([e],t);ue(s.length===1);const o=s[0];return{context:n,value:o}}async getSignatureStatuses(e,t){const n=[e];t&&n.push(t);const s=await this._rpcRequest("getSignatureStatuses",n),o=T(s,eu);if("error"in o)throw new M(o.error,"failed to get signature status");return o.result}async getTransactionCount(e){const{commitment:t,config:n}=le(e),s=this._buildArgs([],t,void 0,n),o=await this._rpcRequest("getTransactionCount",s),i=T(o,Z(f()));if("error"in i)throw new M(i.error,"failed to get transaction count");return i.result}async getTotalSupply(e){return(await this.getSupply({commitment:e,excludeNonCirculatingAccountsList:!0})).value.total}async getInflationGovernor(e){const t=this._buildArgs([],e),n=await this._rpcRequest("getInflationGovernor",t),s=T(n,_c);if("error"in s)throw new M(s.error,"failed to get inflation");return s.result}async getInflationReward(e,t,n){const{commitment:s,config:o}=le(n),i=this._buildArgs([e.map(l=>l.toBase58())],s,void 0,{...o,epoch:t??o?.epoch}),a=await this._rpcRequest("getInflationReward",i),c=T(a,lc);if("error"in c)throw new M(c.error,"failed to get inflation reward");return c.result}async getInflationRate(){const e=await this._rpcRequest("getInflationRate",[]),t=T(e,kc);if("error"in t)throw new M(t.error,"failed to get inflation rate");return t.result}async getEpochInfo(e){const{commitment:t,config:n}=le(e),s=this._buildArgs([],t,void 0,n),o=await this._rpcRequest("getEpochInfo",s),i=T(o,Ac);if("error"in i)throw new M(i.error,"failed to get epoch info");return i.result}async getEpochSchedule(){const e=await this._rpcRequest("getEpochSchedule",[]),t=T(e,Ic);if("error"in t)throw new M(t.error,"failed to get epoch schedule");const n=t.result;return new Za(n.slotsPerEpoch,n.leaderScheduleSlotOffset,n.warmup,n.firstNormalEpoch,n.firstNormalSlot)}async getLeaderSchedule(){const e=await this._rpcRequest("getLeaderSchedule",[]),t=T(e,Rc);if("error"in t)throw new M(t.error,"failed to get leader schedule");return t.result}async getMinimumBalanceForRentExemption(e,t){const n=this._buildArgs([e],t),s=await this._rpcRequest("getMinimumBalanceForRentExemption",n),o=T(s,tu);return"error"in o?(console.warn("Unable to fetch minimum balance for rent exemption"),0):o.result}async getRecentBlockhashAndContext(e){const t=this._buildArgs([],e),n=await this._rpcRequest("getRecentBlockhash",t),s=T(n,fu);if("error"in s)throw new M(s.error,"failed to get recent blockhash");return s.result}async getRecentPerformanceSamples(e){const t=await this._rpcRequest("getRecentPerformanceSamples",e?[e]:[]),n=T(t,pu);if("error"in n)throw new M(n.error,"failed to get recent performance samples");return n.result}async getFeeCalculatorForBlockhash(e,t){const n=this._buildArgs([e],t),s=await this._rpcRequest("getFeeCalculatorForBlockhash",n),o=T(s,gu);if("error"in o)throw new M(o.error,"failed to get fee calculator");const{context:i,value:a}=o.result;return{context:i,value:a!==null?a.feeCalculator:null}}async getFeeForMessage(e,t){const n=Et(e.serialize()).toString("base64"),s=this._buildArgs([n],t),o=await this._rpcRequest("getFeeForMessage",s),i=T(o,pe(U(f())));if("error"in i)throw new M(i.error,"failed to get fee for message");if(i.result===null)throw new Error("invalid blockhash");return i.result}async getRecentPrioritizationFees(e){const t=e?.lockedWritableAccounts?.map(i=>i.toBase58()),n=this._buildArgs(t?.length?[t]:[]),s=await this._rpcRequest("getRecentPrioritizationFees",n),o=T(s,Ec);if("error"in o)throw new M(o.error,"failed to get recent prioritization fees");return o.result}async getRecentBlockhash(e){try{return(await this.getRecentBlockhashAndContext(e)).value}catch(t){throw new Error("failed to get recent blockhash: "+t)}}async getLatestBlockhash(e){try{return(await this.getLatestBlockhashAndContext(e)).value}catch(t){throw new Error("failed to get recent blockhash: "+t)}}async getLatestBlockhashAndContext(e){const{commitment:t,config:n}=le(e),s=this._buildArgs([],t,void 0,n),o=await this._rpcRequest("getLatestBlockhash",s),i=T(o,du);if("error"in i)throw new M(i.error,"failed to get latest blockhash");return i.result}async getVersion(){const e=await this._rpcRequest("getVersion",[]),t=T(e,Z(bc));if("error"in t)throw new M(t.error,"failed to get version");return t.result}async getGenesisHash(){const e=await this._rpcRequest("getGenesisHash",[]),t=T(e,Z(L()));if("error"in t)throw new M(t.error,"failed to get genesis hash");return t.result}async getBlock(e,t){const{commitment:n,config:s}=le(t),o=this._buildArgsAtLeastConfirmed([e],n,void 0,s),i=await this._rpcRequest("getBlock",o);try{switch(s?.transactionDetails){case"accounts":{const a=T(i,iu);if("error"in a)throw a.error;return a.result}case"none":{const a=T(i,ou);if("error"in a)throw a.error;return a.result}default:{const a=T(i,su);if("error"in a)throw a.error;const{result:c}=a;return c?{...c,transactions:c.transactions.map(({transaction:l,meta:u,version:w})=>({meta:u,transaction:{...l,message:Mn(w,l.message)},version:w}))}:null}}}catch(a){throw new M(a,"failed to get confirmed block")}}async getParsedBlock(e,t){const{commitment:n,config:s}=le(t),o=this._buildArgsAtLeastConfirmed([e],n,"jsonParsed",s),i=await this._rpcRequest("getBlock",o);try{switch(s?.transactionDetails){case"accounts":{const a=T(i,cu);if("error"in a)throw a.error;return a.result}case"none":{const a=T(i,uu);if("error"in a)throw a.error;return a.result}default:{const a=T(i,au);if("error"in a)throw a.error;return a.result}}}catch(a){throw new M(a,"failed to get block")}}async getBlockProduction(e){let t,n;if(typeof e=="string")n=e;else if(e){const{commitment:a,...c}=e;n=a,t=c}const s=this._buildArgs([],n,"base64",t),o=await this._rpcRequest("getBlockProduction",s),i=T(o,wc);if("error"in i)throw new M(i.error,"failed to get block production information");return i.result}async getTransaction(e,t){const{commitment:n,config:s}=le(t),o=this._buildArgsAtLeastConfirmed([e],n,void 0,s),i=await this._rpcRequest("getTransaction",o),a=T(i,Kn);if("error"in a)throw new M(a.error,"failed to get transaction");const c=a.result;return c&&{...c,transaction:{...c.transaction,message:Mn(c.version,c.transaction.message)}}}async getParsedTransaction(e,t){const{commitment:n,config:s}=le(t),o=this._buildArgsAtLeastConfirmed([e],n,"jsonParsed",s),i=await this._rpcRequest("getTransaction",o),a=T(i,Jt);if("error"in a)throw new M(a.error,"failed to get transaction");return a.result}async getParsedTransactions(e,t){const{commitment:n,config:s}=le(t),o=e.map(c=>({methodName:"getTransaction",args:this._buildArgsAtLeastConfirmed([c],n,"jsonParsed",s)}));return(await this._rpcBatchRequest(o)).map(c=>{const l=T(c,Jt);if("error"in l)throw new M(l.error,"failed to get transactions");return l.result})}async getTransactions(e,t){const{commitment:n,config:s}=le(t),o=e.map(c=>({methodName:"getTransaction",args:this._buildArgsAtLeastConfirmed([c],n,void 0,s)}));return(await this._rpcBatchRequest(o)).map(c=>{const l=T(c,Kn);if("error"in l)throw new M(l.error,"failed to get transactions");const u=l.result;return u&&{...u,transaction:{...u.transaction,message:Mn(u.version,u.transaction.message)}}})}async getConfirmedBlock(e,t){const n=this._buildArgsAtLeastConfirmed([e],t),s=await this._rpcRequest("getConfirmedBlock",n),o=T(s,lu);if("error"in o)throw new M(o.error,"failed to get confirmed block");const i=o.result;if(!i)throw new Error("Confirmed block "+e+" not found");const a={...i,transactions:i.transactions.map(({transaction:c,meta:l})=>{const u=new nt(c.message);return{meta:l,transaction:{...c,message:u}}})};return{...a,transactions:a.transactions.map(({transaction:c,meta:l})=>({meta:l,transaction:at.populate(c.message,c.signatures)}))}}async getBlocks(e,t,n){const s=this._buildArgsAtLeastConfirmed(t!==void 0?[e,t]:[e],n),o=await this._rpcRequest("getBlocks",s),i=T(o,Z(O(f())));if("error"in i)throw new M(i.error,"failed to get blocks");return i.result}async getBlockSignatures(e,t){const n=this._buildArgsAtLeastConfirmed([e],t,void 0,{transactionDetails:"signatures",rewards:!1}),s=await this._rpcRequest("getBlock",n),o=T(s,ns);if("error"in o)throw new M(o.error,"failed to get block");const i=o.result;if(!i)throw new Error("Block "+e+" not found");return i}async getConfirmedBlockSignatures(e,t){const n=this._buildArgsAtLeastConfirmed([e],t,void 0,{transactionDetails:"signatures",rewards:!1}),s=await this._rpcRequest("getConfirmedBlock",n),o=T(s,ns);if("error"in o)throw new M(o.error,"failed to get confirmed block");const i=o.result;if(!i)throw new Error("Confirmed block "+e+" not found");return i}async getConfirmedTransaction(e,t){const n=this._buildArgsAtLeastConfirmed([e],t),s=await this._rpcRequest("getConfirmedTransaction",n),o=T(s,Kn);if("error"in o)throw new M(o.error,"failed to get transaction");const i=o.result;if(!i)return i;const a=new nt(i.transaction.message),c=i.transaction.signatures;return{...i,transaction:at.populate(a,c)}}async getParsedConfirmedTransaction(e,t){const n=this._buildArgsAtLeastConfirmed([e],t,"jsonParsed"),s=await this._rpcRequest("getConfirmedTransaction",n),o=T(s,Jt);if("error"in o)throw new M(o.error,"failed to get confirmed transaction");return o.result}async getParsedConfirmedTransactions(e,t){const n=e.map(i=>({methodName:"getConfirmedTransaction",args:this._buildArgsAtLeastConfirmed([i],t,"jsonParsed")}));return(await this._rpcBatchRequest(n)).map(i=>{const a=T(i,Jt);if("error"in a)throw new M(a.error,"failed to get confirmed transactions");return a.result})}async getConfirmedSignaturesForAddress(e,t,n){let s={},o=await this.getFirstAvailableBlock();for(;!("until"in s)&&(t--,!(t<=0||t<o));)try{const c=await this.getConfirmedBlockSignatures(t,"finalized");c.signatures.length>0&&(s.until=c.signatures[c.signatures.length-1].toString())}catch(c){if(c instanceof Error&&c.message.includes("skipped"))continue;throw c}let i=await this.getSlot("finalized");for(;!("before"in s)&&(n++,!(n>i));)try{const c=await this.getConfirmedBlockSignatures(n);c.signatures.length>0&&(s.before=c.signatures[c.signatures.length-1].toString())}catch(c){if(c instanceof Error&&c.message.includes("skipped"))continue;throw c}return(await this.getConfirmedSignaturesForAddress2(e,s)).map(c=>c.signature)}async getConfirmedSignaturesForAddress2(e,t,n){const s=this._buildArgsAtLeastConfirmed([e.toBase58()],n,void 0,t),o=await this._rpcRequest("getConfirmedSignaturesForAddress2",s),i=T(o,Dc);if("error"in i)throw new M(i.error,"failed to get confirmed signatures for address");return i.result}async getSignaturesForAddress(e,t,n){const s=this._buildArgsAtLeastConfirmed([e.toBase58()],n,void 0,t),o=await this._rpcRequest("getSignaturesForAddress",s),i=T(o,zc);if("error"in i)throw new M(i.error,"failed to get signatures for address");return i.result}async getAddressLookupTable(e,t){const{context:n,value:s}=await this.getAccountInfoAndContext(e,t);let o=null;return s!==null&&(o=new Qr({key:e,state:Qr.deserialize(s.data)})),{context:n,value:o}}async getNonceAndContext(e,t){const{context:n,value:s}=await this.getAccountInfoAndContext(e,t);let o=null;return s!==null&&(o=dr.fromAccountData(s.data)),{context:n,value:o}}async getNonce(e,t){return await this.getNonceAndContext(e,t).then(n=>n.value).catch(n=>{throw new Error("failed to get nonce for account "+e.toBase58()+": "+n)})}async requestAirdrop(e,t){const n=await this._rpcRequest("requestAirdrop",[e.toBase58(),t]),s=T(n,yu);if("error"in s)throw new M(s.error,`airdrop to ${e.toBase58()} failed`);return s.result}async _blockhashWithExpiryBlockHeight(e){if(!e){for(;this._pollingBlockhash;)await St(100);const n=Date.now()-this._blockhashInfo.lastFetch>=ic;if(this._blockhashInfo.latestBlockhash!==null&&!n)return this._blockhashInfo.latestBlockhash}return await this._pollNewBlockhash()}async _pollNewBlockhash(){this._pollingBlockhash=!0;try{const e=Date.now(),t=this._blockhashInfo.latestBlockhash,n=t?t.blockhash:null;for(let s=0;s<50;s++){const o=await this.getLatestBlockhash("finalized");if(n!==o.blockhash)return this._blockhashInfo={latestBlockhash:o,lastFetch:Date.now(),transactionSignatures:[],simulatedSignatures:[]},o;await St(tc/2)}throw new Error(`Unable to obtain a new blockhash after ${Date.now()-e}ms`)}finally{this._pollingBlockhash=!1}}async getStakeMinimumDelegation(e){const{commitment:t,config:n}=le(e),s=this._buildArgs([],t,"base64",n),o=await this._rpcRequest("getStakeMinimumDelegation",s),i=T(o,pe(f()));if("error"in i)throw new M(i.error,"failed to get stake minimum delegation");return i.result}async simulateTransaction(e,t,n){if("message"in e){const p=e.serialize(),m=K.from(p).toString("base64");if(Array.isArray(t)||n!==void 0)throw new Error("Invalid arguments");const I=t||{};I.encoding="base64","commitment"in I||(I.commitment=this.commitment);const _=[m,I],d=await this._rpcRequest("simulateTransaction",_),R=T(d,es);if("error"in R)throw new Error("failed to simulate transaction: "+R.error.message);return R.result}let s;if(e instanceof at){let y=e;s=new at,s.feePayer=y.feePayer,s.instructions=e.instructions,s.nonceInfo=y.nonceInfo,s.signatures=y.signatures}else s=at.populate(e),s._message=s._json=void 0;if(t!==void 0&&!Array.isArray(t))throw new Error("Invalid arguments");const o=t;if(s.nonceInfo&&o)s.sign(...o);else{let y=this._disableBlockhashCaching;for(;;){const p=await this._blockhashWithExpiryBlockHeight(y);if(s.lastValidBlockHeight=p.lastValidBlockHeight,s.recentBlockhash=p.blockhash,!o)break;if(s.sign(...o),!s.signature)throw new Error("!signature");const m=s.signature.toString("base64");if(!this._blockhashInfo.simulatedSignatures.includes(m)&&!this._blockhashInfo.transactionSignatures.includes(m)){this._blockhashInfo.simulatedSignatures.push(m);break}else y=!0}}const i=s._compile(),a=i.serialize(),l=s._serialize(a).toString("base64"),u={encoding:"base64",commitment:this.commitment};if(n){const y=(Array.isArray(n)?n:i.nonProgramIds()).map(p=>p.toBase58());u.accounts={encoding:"base64",addresses:y}}o&&(u.sigVerify=!0);const w=[l,u],v=await this._rpcRequest("simulateTransaction",w),g=T(v,es);if("error"in g){let y;if("data"in g.error&&(y=g.error.data.logs,y&&Array.isArray(y))){const p=`
    `,m=p+y.join(p);console.error(g.error.message,m)}throw new Xr("failed to simulate transaction: "+g.error.message,y)}return g.result}async sendTransaction(e,t,n){if("version"in e){if(t&&Array.isArray(t))throw new Error("Invalid arguments");const i=e.serialize();return await this.sendRawTransaction(i,t)}if(t===void 0||!Array.isArray(t))throw new Error("Invalid arguments");const s=t;if(e.nonceInfo)e.sign(...s);else{let i=this._disableBlockhashCaching;for(;;){const a=await this._blockhashWithExpiryBlockHeight(i);if(e.lastValidBlockHeight=a.lastValidBlockHeight,e.recentBlockhash=a.blockhash,e.sign(...s),!e.signature)throw new Error("!signature");const c=e.signature.toString("base64");if(this._blockhashInfo.transactionSignatures.includes(c))i=!0;else{this._blockhashInfo.transactionSignatures.push(c);break}}}const o=e.serialize();return await this.sendRawTransaction(o,n)}async sendRawTransaction(e,t){const n=Et(e).toString("base64");return await this.sendEncodedTransaction(n,t)}async sendEncodedTransaction(e,t){const n={encoding:"base64"},s=t&&t.skipPreflight,o=t&&t.preflightCommitment||this.commitment;t&&t.maxRetries!=null&&(n.maxRetries=t.maxRetries),t&&t.minContextSlot!=null&&(n.minContextSlot=t.minContextSlot),s&&(n.skipPreflight=s),o&&(n.preflightCommitment=o);const i=[e,n],a=await this._rpcRequest("sendTransaction",i),c=T(a,mu);if("error"in c){let l;throw"data"in c.error&&(l=c.error.data.logs),new Xr("failed to send transaction: "+c.error.message,l)}return c.result}_wsOnOpen(){this._rpcWebSocketConnected=!0,this._rpcWebSocketHeartbeat=setInterval(()=>{(async()=>{try{await this._rpcWebSocket.notify("ping")}catch{}})()},5e3),this._updateSubscriptions()}_wsOnError(e){this._rpcWebSocketConnected=!1,console.error("ws error:",e.message)}_wsOnClose(e){if(this._rpcWebSocketConnected=!1,this._rpcWebSocketGeneration=(this._rpcWebSocketGeneration+1)%Number.MAX_SAFE_INTEGER,this._rpcWebSocketIdleTimeout&&(clearTimeout(this._rpcWebSocketIdleTimeout),this._rpcWebSocketIdleTimeout=null),this._rpcWebSocketHeartbeat&&(clearInterval(this._rpcWebSocketHeartbeat),this._rpcWebSocketHeartbeat=null),e===1e3){this._updateSubscriptions();return}this._subscriptionCallbacksByServerSubscriptionId={},Object.entries(this._subscriptionsByHash).forEach(([t,n])=>{this._setSubscription(t,{...n,state:"pending"})})}_setSubscription(e,t){const n=this._subscriptionsByHash[e]?.state;if(this._subscriptionsByHash[e]=t,n!==t.state){const s=this._subscriptionStateChangeCallbacksByHash[e];s&&s.forEach(o=>{try{o(t.state)}catch{}})}}_onSubscriptionStateChange(e,t){var o;const n=this._subscriptionHashByClientSubscriptionId[e];if(n==null)return()=>{};const s=(o=this._subscriptionStateChangeCallbacksByHash)[n]||(o[n]=new Set);return s.add(t),()=>{s.delete(t),s.size===0&&delete this._subscriptionStateChangeCallbacksByHash[n]}}async _updateSubscriptions(){if(Object.keys(this._subscriptionsByHash).length===0){this._rpcWebSocketConnected&&(this._rpcWebSocketConnected=!1,this._rpcWebSocketIdleTimeout=setTimeout(()=>{this._rpcWebSocketIdleTimeout=null;try{this._rpcWebSocket.close()}catch(n){n instanceof Error&&console.log(`Error when closing socket connection: ${n.message}`)}},500));return}if(this._rpcWebSocketIdleTimeout!==null&&(clearTimeout(this._rpcWebSocketIdleTimeout),this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketConnected=!0),!this._rpcWebSocketConnected){this._rpcWebSocket.connect();return}const e=this._rpcWebSocketGeneration,t=()=>e===this._rpcWebSocketGeneration;await Promise.all(Object.keys(this._subscriptionsByHash).map(async n=>{const s=this._subscriptionsByHash[n];if(s!==void 0)switch(s.state){case"pending":case"unsubscribed":if(s.callbacks.size===0){delete this._subscriptionsByHash[n],s.state==="unsubscribed"&&delete this._subscriptionCallbacksByServerSubscriptionId[s.serverSubscriptionId],await this._updateSubscriptions();return}await(async()=>{const{args:o,method:i}=s;try{this._setSubscription(n,{...s,state:"subscribing"});const a=await this._rpcWebSocket.call(i,o);this._setSubscription(n,{...s,serverSubscriptionId:a,state:"subscribed"}),this._subscriptionCallbacksByServerSubscriptionId[a]=s.callbacks,await this._updateSubscriptions()}catch(a){if(a instanceof Error&&console.error(`${i} error for argument`,o,a.message),!t())return;this._setSubscription(n,{...s,state:"pending"}),await this._updateSubscriptions()}})();break;case"subscribed":s.callbacks.size===0&&await(async()=>{const{serverSubscriptionId:o,unsubscribeMethod:i}=s;if(this._subscriptionsAutoDisposedByRpc.has(o))this._subscriptionsAutoDisposedByRpc.delete(o);else{this._setSubscription(n,{...s,state:"unsubscribing"}),this._setSubscription(n,{...s,state:"unsubscribing"});try{await this._rpcWebSocket.call(i,[o])}catch(a){if(a instanceof Error&&console.error(`${i} error:`,a.message),!t())return;this._setSubscription(n,{...s,state:"subscribed"}),await this._updateSubscriptions();return}}this._setSubscription(n,{...s,state:"unsubscribed"}),await this._updateSubscriptions()})();break}}))}_handleServerNotification(e,t){const n=this._subscriptionCallbacksByServerSubscriptionId[e];n!==void 0&&n.forEach(s=>{try{s(...t)}catch(o){console.error(o)}})}_wsOnAccountNotification(e){const{result:t,subscription:n}=T(e,Mc);this._handleServerNotification(n,[t.value,t.context])}_makeSubscription(e,t){const n=this._nextClientSubscriptionId++,s=Jr([e.method,t]),o=this._subscriptionsByHash[s];return o===void 0?this._subscriptionsByHash[s]={...e,args:t,callbacks:new Set([e.callback]),state:"pending"}:o.callbacks.add(e.callback),this._subscriptionHashByClientSubscriptionId[n]=s,this._subscriptionDisposeFunctionsByClientSubscriptionId[n]=async()=>{delete this._subscriptionDisposeFunctionsByClientSubscriptionId[n],delete this._subscriptionHashByClientSubscriptionId[n];const i=this._subscriptionsByHash[s];ue(i!==void 0,`Could not find a \`Subscription\` when tearing down client subscription #${n}`),i.callbacks.delete(e.callback),await this._updateSubscriptions()},this._updateSubscriptions(),n}onAccountChange(e,t,n){const s=this._buildArgs([e.toBase58()],n||this._commitment||"finalized","base64");return this._makeSubscription({callback:t,method:"accountSubscribe",unsubscribeMethod:"accountUnsubscribe"},s)}async removeAccountChangeListener(e){await this._unsubscribeClientSubscription(e,"account change")}_wsOnProgramAccountNotification(e){const{result:t,subscription:n}=T(e,Hc);this._handleServerNotification(n,[{accountId:t.value.pubkey,accountInfo:t.value.account},t.context])}onProgramAccountChange(e,t,n,s){const o=this._buildArgs([e.toBase58()],n||this._commitment||"finalized","base64",s?{filters:s}:void 0);return this._makeSubscription({callback:t,method:"programSubscribe",unsubscribeMethod:"programUnsubscribe"},o)}async removeProgramAccountChangeListener(e){await this._unsubscribeClientSubscription(e,"program account change")}onLogs(e,t,n){const s=this._buildArgs([typeof e=="object"?{mentions:[e.toString()]}:e],n||this._commitment||"finalized");return this._makeSubscription({callback:t,method:"logsSubscribe",unsubscribeMethod:"logsUnsubscribe"},s)}async removeOnLogsListener(e){await this._unsubscribeClientSubscription(e,"logs")}_wsOnLogsNotification(e){const{result:t,subscription:n}=T(e,wu);this._handleServerNotification(n,[t.value,t.context])}_wsOnSlotNotification(e){const{result:t,subscription:n}=T(e,Wc);this._handleServerNotification(n,[t])}onSlotChange(e){return this._makeSubscription({callback:e,method:"slotSubscribe",unsubscribeMethod:"slotUnsubscribe"},[])}async removeSlotChangeListener(e){await this._unsubscribeClientSubscription(e,"slot change")}_wsOnSlotUpdatesNotification(e){const{result:t,subscription:n}=T(e,jc);this._handleServerNotification(n,[t])}onSlotUpdate(e){return this._makeSubscription({callback:e,method:"slotsUpdatesSubscribe",unsubscribeMethod:"slotsUpdatesUnsubscribe"},[])}async removeSlotUpdateListener(e){await this._unsubscribeClientSubscription(e,"slot update")}async _unsubscribeClientSubscription(e,t){const n=this._subscriptionDisposeFunctionsByClientSubscriptionId[e];n?await n():console.warn(`Ignored unsubscribe request because an active subscription with id \`${e}\` for '${t}' events could not be found.`)}_buildArgs(e,t,n,s){const o=t||this._commitment;if(o||n||s){let i={};n&&(i.encoding=n),o&&(i.commitment=o),s&&(i=Object.assign(i,s)),e.push(i)}return e}_buildArgsAtLeastConfirmed(e,t,n,s){const o=t||this._commitment;if(o&&!["confirmed","finalized"].includes(o))throw new Error("Using Connection with default commitment: `"+this._commitment+"`, but method requires at least `confirmed`");return this._buildArgs(e,t,n,s)}_wsOnSignatureNotification(e){const{result:t,subscription:n}=T(e,Vc);t.value!=="receivedSignature"&&this._subscriptionsAutoDisposedByRpc.add(n),this._handleServerNotification(n,t.value==="receivedSignature"?[{type:"received"},t.context]:[{type:"status",result:t.value},t.context])}onSignature(e,t,n){const s=this._buildArgs([e],n||this._commitment||"finalized"),o=this._makeSubscription({callback:(i,a)=>{if(i.type==="status"){t(i.result,a);try{this.removeSignatureListener(o)}catch{}}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},s);return o}onSignatureWithOptions(e,t,n){const{commitment:s,...o}={...n,commitment:n&&n.commitment||this._commitment||"finalized"},i=this._buildArgs([e],s,void 0,o),a=this._makeSubscription({callback:(c,l)=>{t(c,l);try{this.removeSignatureListener(a)}catch{}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},i);return a}async removeSignatureListener(e){await this._unsubscribeClientSubscription(e,"signature result")}_wsOnRootNotification(e){const{result:t,subscription:n}=T(e,Zc);this._handleServerNotification(n,[t])}onRootChange(e){return this._makeSubscription({callback:e,method:"rootSubscribe",unsubscribeMethod:"rootUnsubscribe"},[])}async removeRootChangeListener(e){await this._unsubscribeClientSubscription(e,"root change")}}class Yt{constructor(e){this._keypair=void 0,this._keypair=e??$r()}static generate(){return new Yt($r())}static fromSecretKey(e,t){if(e.byteLength!==64)throw new Error("bad secret key size");const n=e.slice(32,64);if(!t||!t.skipValidation){const s=e.slice(0,32),o=Wn(s);for(let i=0;i<32;i++)if(n[i]!==o[i])throw new Error("provided secretKey is invalid")}return new Yt({publicKey:n,secretKey:e})}static fromSeed(e){const t=Wn(e),n=new Uint8Array(64);return n.set(e),n.set(t,32),new Yt({publicKey:t,secretKey:n})}get publicKey(){return new W(this._keypair.publicKey)}get secretKey(){return new Uint8Array(this._keypair.secretKey)}}Object.freeze({CreateLookupTable:{index:0,layout:z([H("instruction"),At("recentSlot"),ne("bumpSeed")])},FreezeLookupTable:{index:1,layout:z([H("instruction")])},ExtendLookupTable:{index:2,layout:z([H("instruction"),At(),Ee(Q(),pt(H(),-8),"addresses")])},DeactivateLookupTable:{index:3,layout:z([H("instruction")])},CloseLookupTable:{index:4,layout:z([H("instruction")])}});new W("AddressLookupTab1e1111111111111111111111111");Object.freeze({RequestUnits:{index:0,layout:z([ne("instruction"),H("units"),H("additionalFee")])},RequestHeapFrame:{index:1,layout:z([ne("instruction"),H("bytes")])},SetComputeUnitLimit:{index:2,layout:z([ne("instruction"),H("units")])},SetComputeUnitPrice:{index:3,layout:z([ne("instruction"),At("microLamports")])}});new W("ComputeBudget111111111111111111111111111111");z([ne("numSignatures"),ne("padding"),qe("signatureOffset"),qe("signatureInstructionIndex"),qe("publicKeyOffset"),qe("publicKeyInstructionIndex"),qe("messageDataOffset"),qe("messageDataSize"),qe("messageInstructionIndex")]);new W("Ed25519SigVerify111111111111111111111111111");cs.utils.isValidPrivateKey;cs.getPublicKey;z([ne("numSignatures"),qe("signatureOffset"),ne("signatureInstructionIndex"),qe("ethAddressOffset"),ne("ethAddressInstructionIndex"),qe("messageDataOffset"),qe("messageDataSize"),ne("messageInstructionIndex"),ce(20,"ethAddress"),ce(64,"signature"),ne("recoveryId")]);new W("KeccakSecp256k11111111111111111111111111111");new W("StakeConfig11111111111111111111111111111111");class rs{constructor(e,t,n){this.unixTimestamp=void 0,this.epoch=void 0,this.custodian=void 0,this.unixTimestamp=e,this.epoch=t,this.custodian=n}}rs.default=new rs(0,0,W.default);Object.freeze({Initialize:{index:0,layout:z([H("instruction"),Na(),qa()])},Authorize:{index:1,layout:z([H("instruction"),Q("newAuthorized"),H("stakeAuthorizationType")])},Delegate:{index:2,layout:z([H("instruction")])},Split:{index:3,layout:z([H("instruction"),Te("lamports")])},Withdraw:{index:4,layout:z([H("instruction"),Te("lamports")])},Deactivate:{index:5,layout:z([H("instruction")])},Merge:{index:7,layout:z([H("instruction")])},AuthorizeWithSeed:{index:8,layout:z([H("instruction"),Q("newAuthorized"),H("stakeAuthorizationType"),vt("authoritySeed"),Q("authorityOwner")])}});new W("Stake11111111111111111111111111111111111111");Object.freeze({InitializeAccount:{index:0,layout:z([H("instruction"),Da()])},Authorize:{index:1,layout:z([H("instruction"),Q("newAuthorized"),H("voteAuthorizationType")])},Withdraw:{index:3,layout:z([H("instruction"),Te("lamports")])},AuthorizeWithSeed:{index:10,layout:z([H("instruction"),za()])}});new W("Vote111111111111111111111111111111111111111");new W("Va1idator1nfo111111111111111111111111111111");k({name:L(),website:G(L()),details:G(L()),keybaseUsername:G(L())});new W("Vote111111111111111111111111111111111111111");z([Q("nodePubkey"),Q("authorizedWithdrawer"),ne("commission"),me(),Ee(z([me("slot"),H("confirmationCount")]),pt(H(),-8),"votes"),ne("rootSlotValid"),me("rootSlot"),me(),Ee(z([me("epoch"),Q("authorizedVoter")]),pt(H(),-8),"authorizedVoters"),z([Ee(z([Q("authorizedPubkey"),me("epochOfLastAuthorizedSwitch"),me("targetEpoch")]),32,"buf"),me("idx"),ne("isEmpty")],"priorVoters"),me(),Ee(z([me("epoch"),me("credits"),me("prevCredits")]),pt(H(),-8),"epochCredits"),z([me("slot"),me("timestamp")],"lastTimestamp")]);export{Eu as C,Yt as K,W as P,io as V,we as b};
